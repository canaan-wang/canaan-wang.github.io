# 面向对象与设计原则

## 面向对象编程（Object-Oriented Programming，OOP）

一种以对象为核心的程序设计范式，通过封装、继承、多态等特性来组织代码。
Java 是完全面向对象的编程语言，所有代码都必须在类中定义。

### 核心概念

#### 类（Class）
- **定义**：对象的抽象描述，用于表示一组对象的创建模板
- **作用**：定义对象的属性（成员变量）和行为（方法）
- **特性**：
  - 类是对象的蓝图
  - 类可以包含构造器、成员变量、方法、内部类等
  - 类支持访问修饰符控制可见性

#### 对象（Object）
- **定义**：系统用来描述客观事物的一个实体，构成系统的基本单位
- **特性**：
  - 对象是类的实例
  - 每个对象都有唯一的标识（内存地址）
  - 对象包含状态（属性值）和行为（方法）

#### 实例化过程

Java 提供了多种创建对象的方式，每种方式都有其特定的使用场景：

##### 1. 使用 new 关键字（最常用）
```java
// 类定义
public class Person {
    private String name;
    private int age;
    
    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }
    
    public void introduce() {
        System.out.println("我叫" + name + ", 今年" + age + "岁");
    }
}

// 对象创建
Person person = new Person("张三", 25);
person.introduce();
```

##### 2. 使用 Class 类的 newInstance() 方法（反射）
```java
try {
    // 通过反射创建对象
    Class<?> personClass = Class.forName("Person");
    Person person = (Person) personClass.newInstance();
    
    // 或者使用 getDeclaredConstructor()
    Constructor<Person> constructor = Person.class.getDeclaredConstructor(String.class, int.class);
    Person person2 = constructor.newInstance("李四", 30);
} catch (Exception e) {
    e.printStackTrace();
}
```

##### 3. 使用 Constructor 类的 newInstance() 方法
```java
try {
    Constructor<Person> constructor = Person.class.getConstructor(String.class, int.class);
    Person person = constructor.newInstance("王五", 28);
} catch (Exception e) {
    e.printStackTrace();
}
```

##### 4. 使用 clone() 方法（对象克隆）
```java
public class Person implements Cloneable {
    private String name;
    private int age;
    
    // 必须实现 Cloneable 接口
    @Override
    protected Object clone() throws CloneNotSupportedException {
        return super.clone();
    }
}

// 使用克隆创建对象
Person original = new Person("赵六", 35);
Person cloned = (Person) original.clone();
```

##### 5. 使用反序列化
```java
import java.io.*;

public class Person implements Serializable {
    private String name;
    private int age;
    
    // 序列化
    public static void serialize(Person person, String filename) throws IOException {
        try (ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(filename))) {
            oos.writeObject(person);
        }
    }
    
    // 反序列化
    public static Person deserialize(String filename) throws IOException, ClassNotFoundException {
        try (ObjectInputStream ois = new ObjectInputStream(new FileInputStream(filename))) {
            return (Person) ois.readObject();
        }
    }
}

// 使用反序列化创建对象
Person original = new Person("钱七", 40);
Person.serialize(original, "person.ser");
Person deserialized = Person.deserialize("person.ser");
```

##### 6. 使用工厂方法模式
```java
// 工厂类
public class PersonFactory {
    public static Person createPerson(String name, int age) {
        return new Person(name, age);
    }
    
    public static Person createDefaultPerson() {
        return new Person("默认", 0);
    }
}

// 使用工厂方法创建对象
Person person1 = PersonFactory.createPerson("孙八", 45);
Person person2 = PersonFactory.createDefaultPerson();
```

##### 7. 使用 Builder 模式
```java
public class Person {
    private final String name;
    private final int age;
    
    private Person(Builder builder) {
        this.name = builder.name;
        this.age = builder.age;
    }
    
    public static class Builder {
        private String name = "默认";
        private int age = 0;
        
        public Builder name(String name) {
            this.name = name;
            return this;
        }
        
        public Builder age(int age) {
            this.age = age;
            return this;
        }
        
        public Person build() {
            return new Person(this);
        }
    }
}

// 使用 Builder 模式创建对象
Person person = new Person.Builder()
    .name("周九")
    .age(50)
    .build();
```

##### 8. 使用静态工厂方法
```java
public class Person {
    private String name;
    private int age;
    
    private Person(String name, int age) {
        this.name = name;
        this.age = age;
    }
    
    // 静态工厂方法
    public static Person createWithName(String name) {
        return new Person(name, 0);
    }
    
    public static Person createWithAge(int age) {
        return new Person("未知", age);
    }
}

// 使用静态工厂方法创建对象
Person person1 = Person.createWithName("吴十");
Person person2 = Person.createWithAge(55);
```

##### 总结对比

| 创建方式 | 优点 | 缺点 | 适用场景 |
|---------|------|------|----------|
| new 关键字 | 简单直观，性能好 | 耦合度高 | 常规对象创建 |
| 反射 | 灵活性高，动态创建 | 性能较差，代码复杂 | 框架、插件系统 |
| clone() | 快速复制对象 | 需要实现接口，浅拷贝问题 | 对象复制 |
| 反序列化 | 持久化对象 | 需要序列化接口，性能开销 | 对象持久化 |
| 工厂方法 | 解耦合，易于扩展 | 增加复杂度 | 复杂对象创建 |
| Builder 模式 | 参数灵活，可读性好 | 代码量多 | 多参数对象创建 |
| 静态工厂 | 方法名有意义，可缓存 | 构造器私有 | 替代构造器 |

### 面向对象的三大特征

#### 封装（Encapsulation）
- **定义**：隐藏对象的属性和实现细节，仅对外提供访问方法
- **目的**：
  - 提高代码的安全性
  - 降低代码的耦合度
  - 便于维护和修改
- **实现方式**：
  - 使用 private 修饰成员变量
  - 提供 public 的 getter 和 setter 方法

#### 继承（Inheritance）
- **定义**：从已有类继承信息定义新类的过程（父类/基类 -> 派生类/子类）
- **目的**：
  - 代码复用
  - 建立类之间的层次关系
  - 支持多态
- **特性**：
  - Java 支持单继承（一个类只能继承一个父类）
  - 所有类都直接或间接继承自 Object 类
  - 子类可以重写父类的方法

#### 多态（Polymorphism）
- **定义**：不同类型的子类对同一方法做出不同的行为
- **类型**：
  - 编译时多态：方法重载（Overload）
  - 运行时多态：方法重写（Override）
- **实现条件**：
  - 继承关系
  - 方法重写
  - 父类引用指向子类对象

### 多态的实现方式

#### 代码实现方式
1. **接口实现**：通过实现接口定义的方法
2. **继承父类重写方法**：子类重写父类的方法
3. **方法重载**：同一类中定义多个同名但参数不同的方法

#### 虚拟机实现机制
- **动态绑定技术**：执行期间判断所引用对象的实际类型，根据实际类型调用对应的方法
- **方法表**：每个类都有一个方法表，存储方法的实际地址
- **虚方法调用**：通过方法表实现动态分派

### 方法重载（Overload）

#### 定义
在同一个类中，允许存在多个同名方法，只要它们的参数列表不同。

#### 规则
- 发生在一个类中
- 方法名必须相同
- 参数列表必须不同（类型、个数、顺序）
- 返回值类型可以不同
- 访问修饰符可以不同
- 抛出的异常可以不同

#### 示例
```java
public class Calculator {
    // 整数加法
    public int add(int a, int b) {
        return a + b;
    }
    
    // 浮点数加法
    public double add(double a, double b) {
        return a + b;
    }
    
    // 三个整数加法
    public int add(int a, int b, int c) {
        return a + b + c;
    }
}
```

### 方法重写（Override）

#### 定义
子类重新定义父类中已有的方法，提供特定的实现。

#### 规则
- 发生在子类继承父类中
- 方法名必须相同
- 参数列表必须相同
- 返回值类型必须相同或是父类返回类型的子类
- 访问权限不能比父类更严格
- 抛出的异常不能比父类更广泛

#### @Override 注解
- 用于标记重写的方法
- 编译器会检查是否符合重写规则
- 提高代码的可读性

#### 示例
```java
class Animal {
    public void makeSound() {
        System.out.println("动物发出声音");
    }
}

class Dog extends Animal {
    @Override
    public void makeSound() {
        System.out.println("汪汪汪");
    }
}
```

### 构造器（Constructor）

#### 定义
用于创建对象时初始化对象的特殊方法。

#### 特性
- 方法名与类名相同
- 没有返回值类型（连 void 都没有）
- 可以重载
- 不能被继承，但子类可以调用父类的构造器

#### 构造器调用顺序
1. 父类静态代码块
2. 子类静态代码块
3. 父类构造代码块
4. 父类构造器
5. 子类构造代码块
6. 子类构造器

#### 示例
```java
public class Person {
    private String name;
    
    // 默认构造器
    public Person() {
        this.name = "未知";
    }
    
    // 带参数构造器
    public Person(String name) {
        this.name = name;
    }
}
```

### 接口（Interface）

#### 定义
定义一组抽象方法的契约，实现类必须实现这些方法。

#### 意义
- 实现多态
- 定义规范
- 解耦合

## 设计原则

### SOLID 原则

#### 1. 单一职责原则（Single Responsibility Principle, SRP）
- **定义**：一个类应该只有一个引起变化的原因
- **目的**：提高类的内聚性，降低耦合度
- **示例**：
  - 违反：一个类既处理用户信息又处理订单信息
  - 遵循：将用户信息和订单信息分别放在不同的类中

#### 2. 开闭原则（Open/Closed Principle, OCP）
- **定义**：软件实体应该对扩展开放，对修改关闭
- **目的**：提高系统的可维护性和可扩展性
- **实现方式**：使用抽象和接口，通过继承和多态实现扩展

#### 3. 里氏替换原则（Liskov Substitution Principle, LSP）
- **定义**：子类必须能够替换掉它们的父类
- **目的**：确保继承关系的正确性
- **要求**：子类不应该改变父类的行为，只能扩展功能

#### 4. 接口隔离原则（Interface Segregation Principle, ISP）
- **定义**：客户端不应该依赖它不需要的接口
- **目的**：避免接口臃肿，提高系统的灵活性
- **实现方式**：将大接口拆分为多个小接口

#### 5. 依赖倒置原则（Dependency Inversion Principle, DIP）
- **定义**：高层模块不应该依赖低层模块，二者都应该依赖抽象
- **目的**：降低模块间的耦合度
- **实现方式**：使用接口或抽象类作为依赖关系的中介

### 其他重要设计原则

#### 迪米特法则（Law of Demeter, LoD）
- **定义**：一个对象应该对其他对象有最少的了解
- **别名**：最少知识原则
- **目的**：降低类之间的耦合度

#### 合成复用原则（Composite Reuse Principle, CRP）
- **定义**：尽量使用对象组合，而不是继承来达到复用的目的
- **目的**：提高系统的灵活性和可维护性

#### 关注点分离原则（Separation of Concerns, SoC）
- **定义**：将系统分解为不同的部分，每个部分解决一个特定的问题
- **目的**：提高系统的可维护性和可理解性

## 设计原则的应用

### 在实际开发中的应用
1. **代码重构**：根据设计原则优化现有代码结构
2. **架构设计**：在系统设计阶段考虑设计原则
3. **代码审查**：使用设计原则作为代码质量的评判标准

### 设计原则与设计模式的关系
- 设计原则是指导思想，设计模式是具体实现
- 设计模式是设计原则的具体体现
- 遵循设计原则有助于更好地理解和应用设计模式

## 总结

面向对象编程和设计原则是软件设计的核心基础。掌握这些概念不仅有助于编写高质量的代码，还能提高系统的可维护性和可扩展性。在实际开发中，应该根据具体场景灵活应用这些原则，而不是机械地套用。