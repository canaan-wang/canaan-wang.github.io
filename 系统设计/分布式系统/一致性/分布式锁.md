# 分布式锁

# 一、分布式锁的核心认知

## 1.1 什么是分布式锁？

分布式锁是一种跨进程、跨机器、跨网络的锁机制，用于保证分布式系统中多个节点对共享资源的互斥访问。其核心目标防止并发操作导致的数据不一致（如超卖、重复下单、数据重复写入等问题），但作用范围扩展到了整个分布式集群。

## 1.2 分布式锁的核心特性

一个可靠的分布式锁必须满足以下核心特性，否则可能导致锁失效或出现异常场景：

- **互斥性**：这是最基本的特性，同一时间只能有一个节点（进程）持有锁，保证共享资源不会被并发修改。

- **安全性**：锁只能被持有它的节点释放，其他节点不能强制释放别人的锁，防止误释放导致的互斥失效。

- **容错性**：当持有锁的节点意外宕机（如服务器断电、网络中断）时，锁必须能被正常释放（或自动过期），避免出现“死锁”，导致资源永久不可用。

- **可用性**：分布式锁服务本身要具备高可用性，即使部分锁服务节点故障，仍能提供锁服务，避免成为系统瓶颈。

- **可重入性（可选）**：同一节点的同一线程如果再次请求已持有的锁，应能成功获取，避免自身死锁（类似ReentrantLock的特性，根据业务需求选择是否需要）。

- **公平性（可选）**：多个节点竞争锁时，应按照请求顺序获取锁，避免“饥饿”问题（部分节点长期获取不到锁），通常公平性会牺牲一定的性能。

# 二、分布式锁的常见实现方案及对比

分布式锁的实现依赖于一个“第三方共享存储”，所有节点通过操作该存储来实现锁的获取、释放和竞争。常见的实现方案包括基于数据库、Redis、ZooKeeper（或etcd）的方案，不同方案在性能、容错性、实现复杂度上各有优劣。

## 2.1 基于数据库的分布式锁

利用数据库的唯一性约束（如主键、唯一索引）来实现互斥性，核心思路是：通过插入一条包含锁标识的记录来“获取锁”，通过删除该记录来“释放锁”，利用唯一约束保证同一时间只能插入成功一条记录。

### 2.1.1 实现方式（以MySQL为例）

1. **创建锁表**：设计一张锁表，包含锁ID（唯一索引）、持有节点ID、过期时间等字段，确保锁ID的唯一性。

```sql

CREATE TABLE `distributed_lock` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `lock_key` varchar(64) NOT NULL COMMENT '锁标识（如“order:1001”）',
  `holder_id` varchar(64) NOT NULL COMMENT '持有锁的节点ID/进程ID',
  `expire_time` datetime NOT NULL COMMENT '锁过期时间',
  PRIMARY KEY (`id`),
  UNIQUE KEY `uk_lock_key` (`lock_key`) COMMENT '唯一索引保证互斥'
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
```

2. **获取锁**：节点请求锁时，插入一条lock_key为目标资源标识的记录，若插入成功则表示获取锁；若因唯一约束冲突插入失败，则表示锁已被占用。为避免死锁，需设置过期时间（如当前时间+30秒）。

```sql

INSERT INTO distributed_lock (lock_key, holder_id, expire_time)
VALUES ('order:1001', 'node-001', DATE_ADD(NOW(), INTERVAL 30 SECOND));
```

3. **释放锁**：节点完成业务后，删除自己持有的锁记录（需指定holder_id，防止释放别人的锁）。

```sql

DELETE FROM distributed_lock
WHERE lock_key = 'order:1001' AND holder_id = 'node-001';
```

4. **容错处理**：若节点宕机未释放锁，需有“定时任务”清理过期的锁记录（如删除expire_time<当前时间的记录）。

### 2.1.2 优缺点对比

|优点|缺点|
|---|---|
|1. 实现简单，无需引入额外中间件（如Redis、ZooKeeper）；2. 基于数据库事务，可结合业务逻辑实现原子操作；3. 兼容性好，所有开发语言都支持数据库操作。|1. 性能较差：数据库插入/删除操作是IO密集型，并发高时容易成为瓶颈；2. 容错性依赖数据库高可用（需部署主从、集群）；3. 死锁风险：定时任务清理过期锁存在延迟，可能导致短暂的锁冲突；4. 可重入性、公平性实现复杂（需额外设计表结构和逻辑）。|
### 2.1.3 适用场景

并发量较低、业务逻辑简单、不想引入额外中间件的小型分布式系统（如内部管理系统、低并发接口）。

## 2.2 基于Redis的分布式锁

Redis作为高性能的内存数据库，支持原子操作，是目前工业界最常用的分布式锁实现方案之一。核心思路是利用Redis的**SETNX命令（SET if Not Exists）**的原子性：若键不存在则设置值（获取锁成功），若键已存在则设置失败（获取锁失败）。

### 2.2.1 核心实现（基于Redis命令）

Redis的SET命令在2.6.12版本后支持多参数，可一次性实现“SETNX+设置过期时间”的原子操作，避免分步操作导致的锁失效（如先SETNX再EXPIRE，两步之间节点宕机则锁无过期时间）。

1. **获取锁**：使用SETNX命令（SET if Not Exists），指定锁键、锁值（建议用UUID等唯一值作为holder_id，避免误释放）、过期时间，且仅在键不存在时设置（NX参数）。

```redis

# 命令格式：SET lock_key 唯一标识 NX EX 过期时间（秒）
# 示例：获取“order:1001”的锁，标识为“node-001:uuid-xxx”，过期30秒
SET order:1001 node-001:uuid-xxx NX EX 30
```

返回“OK”表示获取锁成功，返回“nil”表示锁已被占用。

2. **释放锁**：不能直接用DEL命令（可能删除别人的锁），需先判断锁值是否为自己的标识，再删除，且这两步需原子操作（通过Lua脚本实现，Redis保证Lua脚本执行的原子性）。

```lua

# Lua脚本：判断锁值是否为指定值，是则删除
if redis.call('GET', KEYS[1]) == ARGV[1] then
    return redis.call('DEL', KEYS[1])
else
    return 0
end
# 执行脚本（KEYS[1]为lock_key，ARGV[1]为唯一标识）
EVAL "上述脚本" 1 order:1001 node-001:uuid-xxx
```

3. **容错与续期**：若业务执行时间超过锁过期时间，锁会自动释放，可能导致并发问题。解决方案是“锁续期”（如Java中的Redisson客户端自带“看门狗”机制，每隔过期时间的1/3自动续期，直到业务完成）。

### 2.2.2 进阶：Redisson客户端的分布式锁

手动实现Redis锁需处理续期、可重入、公平锁等复杂逻辑，实际开发中推荐使用成熟的客户端（如Java的Redisson），其封装了完整的分布式锁实现，支持多种锁类型：

- **可重入锁（ReentrantLock）**：基于Redis的Hash结构实现，记录持有次数，支持重入。

- **公平锁（FairLock）**：基于Redis的列表结构实现，按请求顺序分配锁，避免饥饿。

- **读写锁（ReadWriteLock）**：支持“读多写少”场景，多个读锁可共存，写锁与其他锁互斥。

```java

// Redisson可重入锁示例（Java）
Config config = new Config();
config.useSingleServer().setAddress("redis://127.0.0.1:6379");
RedissonClient redisson = Redisson.create(config);
// 获取锁
RLock lock = redisson.getLock("order:1001");
try {
    // 尝试获取锁，最多等待10秒，锁过期时间30秒
    boolean locked = lock.tryLock(10, 30, TimeUnit.SECONDS);
    if (locked) {
        // 执行业务逻辑（如创建订单、扣减库存）
        processOrder(1001);
    }
} finally {
    // 释放锁（若未获取到锁，释放无影响）
    if (lock.isHeldByCurrentThread()) {
        lock.unlock();
    }
}
redisson.shutdown();
```

### 2.2.3 优缺点对比

|优点|缺点|
|---|---|
|1. 性能极高：Redis是内存数据库，SET/DEL操作响应时间毫秒级，支持高并发；2. 实现简洁：基于原子命令和Lua脚本，成熟客户端（Redisson）可直接复用；3. 高可用：支持主从、哨兵、集群部署，避免单点故障。|1. 锁过期时间难设置：过短可能导致业务未完成锁已释放，过长可能导致死锁后资源占用时间久；2. 主从复制延迟问题：主节点锁已写入但未同步到从节点时主节点宕机，从节点升级为主节点后可能出现“锁丢失”（可通过Redis Cluster的Redlock算法优化，但会牺牲性能）；3. 不支持天然公平锁（需额外实现）。|
### 2.2.4 适用场景

并发量高、对性能要求高的业务场景（如电商秒杀、高频交易、分布式任务调度），是目前最主流的分布式锁方案。

## 2.3 基于ZooKeeper的分布式锁

ZooKeeper是一个分布式协调服务，具有强一致性、临时有序节点等特性，天然适合实现分布式锁。核心思路是：利用ZooKeeper的**临时有序子节点**和**Watcher监听机制**，实现锁的竞争和释放。

### 2.3.1 实现方式

1. **创建根节点**：在ZooKeeper中创建一个持久根节点作为锁的根目录（如“/distributed/lock”）。

2. **竞争锁（创建临时有序子节点）**：节点请求锁时，在根节点下创建一个临时有序子节点（如“/distributed/lock/lock-”），ZooKeeper会自动为子节点分配递增序号（如lock-0000000001、lock-0000000002）。

3. **判断是否持有锁**：获取根节点下所有子节点，按序号排序。若当前节点创建的子节点是序号最小的，则表示获取锁成功；否则，监听前一个序号的子节点（“前驱节点”）。

4. **释放锁**：有两种释放方式：① 业务完成后，主动删除自己创建的子节点；② 节点宕机后，ZooKeeper的临时节点会自动删除（天然实现容错，避免死锁）。

5. **锁竞争触发**：当持有锁的节点释放锁（子节点被删除），其“后继节点”会通过Watcher机制感知到，然后判断自己是否为当前最小节点，若是则获取锁成功。

### 2.3.2 进阶：Curator客户端的分布式锁

ZooKeeper的锁实现需处理节点创建、Watcher监听、序号排序等逻辑，实际开发中推荐使用Apache Curator客户端，其封装了多种分布式锁实现（如InterProcessMutex、InterProcessReadWriteLock）。

```java

// Curator可重入锁示例（Java）
// 1. 创建Curator客户端
CuratorFramework client = CuratorFrameworkFactory.builder()
        .connectString("127.0.0.1:2181")
        .sessionTimeoutMs(5000)
        .connectionTimeoutMs(3000)
        .retryPolicy(new ExponentialBackoffRetry(1000, 3))
        .build();
client.start();
// 2. 获取分布式锁
InterProcessMutex lock = new InterProcessMutex(client, "/distributed/lock/order:1001");
try {
    // 尝试获取锁，最多等待10秒
    boolean locked = lock.acquire(10, TimeUnit.SECONDS);
    if (locked) {
        // 执行业务逻辑
        processOrder(1001);
    }
} finally {
    // 释放锁
    if (lock.isAcquiredInThisProcess()) {
        lock.release();
    }
}
client.close();
```

### 2.3.3 优缺点对比

|优点|缺点|
|---|---|
|1. 天然容错：临时节点自动删除，避免死锁；2. 天然公平锁：按子节点序号排序，按顺序获取锁，无饥饿问题；3. 强一致性：ZooKeeper集群通过ZAB协议保证数据强一致，锁不会丢失；4. 支持可重入、读写锁等高级特性（Curator封装）。|1. 性能较低：ZooKeeper是CP架构，强一致性依赖集群同步，节点创建、Watcher监听等操作响应时间比Redis慢，并发能力较弱；2. 部署复杂：需维护ZooKeeper集群（至少3个节点），增加运维成本；3. Watcher机制可能导致“惊群效应”（大量节点监听同一节点，释放时同时触发）。|
### 2.3.4 适用场景

并发量适中、对公平性和一致性要求高的场景（如分布式选举、分布式事务协调），不适合高并发场景（如秒杀）。

### 2.4 三种实现方案核心对比

|对比维度|数据库锁|Redis锁|ZooKeeper锁|
|---|---|---|---|
|性能|低|高|中|
|互斥性|可靠（依赖唯一索引）|较可靠（需注意主从延迟）|非常可靠（强一致性）|
|容错性|依赖数据库集群|主从/集群部署，较高|集群部署，高（临时节点）|
|公平性|难实现|需额外实现|天然支持|
|实现复杂度|简单（基础版）|简单（用Redisson）|复杂（推荐用Curator）|
|运维成本|低（复用现有数据库）|中（Redis集群）|高（ZooKeeper集群）|
# 三、总结

分布式锁是解决分布式系统资源竞争的核心技术，其核心是通过第三方共享存储实现跨节点互斥。选择实现方案时，需结合业务的并发量、一致性要求、运维成本综合判断：

- 高并发、高性能场景（如秒杀、机器人充电抢占）：优先选**Redis锁**（推荐Redisson客户端）；

- 公平性、强一致性要求高的场景（如任务调度、分布式选举）：优先选**ZooKeeper锁**（推荐Curator客户端）；

- 低并发、简单场景：可选用**数据库锁**（复用现有数据库，降低复杂度）。

在机器人等终端设备场景中，需特别注意锁的粒度、过期时间和重试策略，结合设备运行特性（如移动过程中网络波动、电量变化）优化锁逻辑，确保系统稳定可靠。