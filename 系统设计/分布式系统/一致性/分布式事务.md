# 分布式事务

# 一、什么是分布式事务？先搞懂两个基础概念

在讲分布式事务前，先回顾两个前提概念，理解后会更清晰：

- **本地事务**：单台数据库上的事务，比如我们熟悉的“银行转账”——从A账户扣钱、给B账户加钱，这两步在同一数据库里执行，满足“ACID”四大特性（原子性、一致性、隔离性、持久性）。

- **分布式事务**：当事务操作涉及**多个独立的数据库节点**（或服务对应的数据库）时，就构成了分布式事务。比如电商“下单支付”场景：订单服务往订单库写数据，支付服务往支付库写数据，库存服务往库存库扣减库存，这三步需要同时成功或同时失败，否则会出现“下单了但没扣库存”“扣了库存但没支付”等数据不一致问题。

简单说：**分布式事务 = 多个本地事务的协同，目标是让这些本地事务要么全成功，要么全失败**。

# 二、分布式事务的核心难题：为何不能直接用本地事务？

本地事务能靠数据库自身机制保证ACID，但分布式场景下，有两个“天生障碍”导致问题变复杂：

1. **网络不可靠**：多个服务间通信依赖网络，可能出现“服务A执行成功，给服务B发通知时网络中断”的情况，导致B没执行。

2. **节点独立性**：每个数据库节点都是独立的，没有办法像本地事务那样“一键回滚”所有节点的操作。比如服务A扣了库存，服务B支付失败，A的扣减操作没法让B的数据库来触发回滚。

核心矛盾：如何在“网络不可靠”和“节点独立”的前提下，保证多个本地事务的一致性？

# 三、分布式事务的核心理论：CAP与BASE

聊分布式事务，绕不开这两个理论，它们是所有解决方案的“设计准则”：

## 1. CAP定理：不可能三角

分布式系统中，有三个核心需求：

- **C（一致性）**：所有节点的数据始终保持一致，比如下单后，订单、支付、库存数据必须同步更新。

- **A（可用性）**：服务随时能响应请求，不会因为某个节点故障就瘫痪。

- **P（分区容错性）**：当网络出现“分区”（比如部分节点断连）时，系统依然能正常工作。

CAP定理的结论是：**分布式系统中，C、A、P三者无法同时满足，必须舍弃一个**。而由于网络故障是常态，“P（分区容错性）”是必须保留的，因此实际设计中只能在“CP”和“AP”之间权衡：

- **CP优先**：牺牲可用性保一致性，比如银行转账、金融交易，必须保证数据准确，哪怕短暂无法服务。

- **AP优先**：牺牲强一致性保可用性，比如电商商品详情页、朋友圈点赞，允许短暂数据不一致，但服务必须能用。

## 2. BASE理论：最终一致性的“妥协方案”

由于CAP定理中“强一致性”（C）和“高可用性”（A）难以兼得，BASE理论应运而生，它是对CAP的延伸，核心是：**放弃强一致性，追求“最终一致性”**——允许系统在短期内数据不一致，但经过一段时间后，数据能自动同步到一致状态。

BASE由三个词缩写而来，不用死记，理解核心即可：基本可用（Basically Available）、软状态（Soft State）、最终一致性（Eventually Consistent）。

# 四、常用分布式事务解决方案：5种方案+适用场景

## 1. 2PC（两阶段提交）：强一致性的“经典方案”

核心思想：引入一个“协调者”（比如事务管理器），把分布式事务拆成“准备阶段”和“提交阶段”两步，强制所有节点统一执行结果。

1. **准备阶段**：协调者给所有节点发“准备指令”，节点执行本地事务（但不提交），执行成功就回复“就绪”，失败就回复“拒绝”。

2. **提交阶段**：如果协调者收到所有节点的“就绪”，就发“提交指令”，所有节点执行提交；只要有一个节点“拒绝”，就发“回滚指令”，所有节点执行回滚。

**优点**：实现简单，强一致性；
**缺点**：协调者是单点故障（一旦挂了，所有节点阻塞），整个过程是“同步阻塞”，性能差。

**适用场景**：小型分布式系统，对一致性要求极高、并发量不高的场景，比如传统金融核心系统。

## 2. 3PC（三阶段提交）：优化2PC的“阻塞问题”

核心改进：在2PC基础上拆分“准备阶段”为“预准备阶段”和“准备阶段”，并引入“超时机制”，三个阶段具体操作如下：

1. **预准备阶段（CanCommit）**：协调者向所有节点发送“预准备指令”，仅询问节点“是否能执行事务”，节点无需执行实际事务，仅返回“能执行”或“不能执行”的状态。

2. **准备阶段（PreCommit）**：若协调者收到所有节点“能执行”的回复，就发送“准备指令”，节点执行本地事务（不提交）并回复“就绪”；若有节点“不能执行”，则发送“中断指令”。

3. **提交阶段（DoCommit）**：若协调者收到所有节点“就绪”，发送“提交指令”；若有节点“未就绪”或超时，发送“回滚指令”；同时节点超时后会自动提交，避免阻塞。

**优点**：

- 1. 预准备阶段过滤无效节点，减少后续操作开销；

- 2. 超时机制解决2PC中协调者故障导致的节点长期阻塞问题；

- 3. 阶段拆分使故障恢复更灵活。

**缺点**：

- 1. 仍为强一致性模型，同步通信特性导致性能提升有限；

- 2. 节点超时自动提交机制可能引发数据不一致（如部分节点超时提交，部分收到回滚指令）；

- 3. 新增一个阶段使协议复杂度大幅提升，运维成本高。

**适用场景**：对阻塞问题有一定要求，但仍需强一致性，且能接受较高复杂度的特定场景，如部分传统金融非核心交易系统（实际因复杂度高，应用远少于2PC和其他方案）。

## 3. TCC（Try-Confirm-Cancel）：高性能的“业务侵入式方案”

核心思想：不依赖数据库自身的事务机制，而是通过“业务代码”手动实现事务的“提交”和“回滚”，把分布式事务拆成三个业务操作：

1. **Try（尝试）**：预留资源，比如下单时先冻结库存（不是直接扣减）、冻结用户余额。

2. **Confirm（确认）**：如果所有节点的Try都成功，就执行确认操作，比如把冻结的库存扣减、余额扣减。

3. **Cancel（取消）**：如果有节点Try失败，就执行取消操作，释放预留的资源，比如解冻库存、解冻余额。

**资源解冻时机**：TCC中Try阶段冻结的资源不会自动解冻，仅在以下两种明确场景下触发解冻，未触发时始终保持冻结状态，避免资源被误操作：

- **正常确认后解冻（实际为资源消耗）**：所有节点Try执行成功，进入Confirm阶段并全部执行完成后，冻结资源从“预留状态”转为“实际消耗状态”（如冻结库存转为实际扣减、冻结余额转为实际支付），完成资源状态的合法变更。

- **回滚后解冻（资源释放）**：当存在节点Try超时未执行、或Confirm执行失败且重试无效时，触发全局回滚，通过Cancel接口释放所有节点的冻结资源，恢复至事务执行前的初始状态。

**回滚逻辑**：针对“多节点中部分失败/超时”的核心场景，回滚流程分三步执行，保障数据一致性：

1. **异常检测**：协调者通过事务日志实时记录各节点Try/Confirm状态，若检测到节点超时未响应（如10个节点中1个超时）、或节点返回执行失败，触发重试机制。

2. **重试前置处理**：优先对失败/超时节点进行重试（最多3次为例），因Try阶段已完成资源冻结，重试过程不会引发资源竞争，且需通过事务ID保证Confirm/Try逻辑幂等，避免重复执行。

3. **全局回滚执行**：若重试多次仍失败，协调者触发全局回滚：

**优点**：

- 1. 纯业务层实现，不依赖数据库，性能根基扎实；

- 2. 核心优势是“同步非阻塞”——各节点Try阶段并行执行，无需像2PC那样全局同步等待，无全局阻塞点；

- 3. 资源冻结为业务层轻量操作，非数据库级排他锁，不阻塞读操作及非冲突资源并发处理；

- 4. 失败通过异步补偿处理，不影响主流程性能，因此能支撑高并发；

**缺点**：侵入业务代码，需手动编写Try/Confirm/Cancel逻辑及失败处理机制，开发成本高。

**适用场景**：高并发、对性能要求极高的场景，比如电商秒杀、支付系统。

## 4. 消息队列事务（可靠消息最终一致性）：低耦合的“通用方案”

核心思想：利用消息队列的“可靠投递”和“事务消息”机制，把分布式事务转化为“消息发送”和“消息消费”两个独立的本地事务，最终通过消息同步达到一致。

以“下单扣库存”为例：

1. 订单服务执行“创建订单”本地事务，同时发送“扣库存”的事务消息到消息队列（消息先处于“待发送”状态）。

2. 如果订单创建成功，消息队列确认发送；如果失败，消息队列丢弃消息。

3. 库存服务监听消息队列，收到消息后执行“扣库存”本地事务；如果执行失败，消息队列会重试发送，直到成功。

**优点**：服务间解耦，性能好，开发成本低；
**缺点**：依赖消息队列的可靠性，存在短暂的数据不一致（比如订单创建后，库存还没扣减）。

**适用场景**：大多数分布式系统，尤其是对一致性要求不严格、追求高可用的场景，比如电商、社交、物流等。

# 五、总结：如何选择合适的方案？

分布式事务没有“银弹”，核心是根据业务场景权衡“一致性”“可用性”和“性能”，给出选择建议：

|业务场景|推荐方案|核心考量|
|---|---|---|
|金融交易、核心账务（强一致+低并发）|2PC/3PC|数据绝对一致优先|
|秒杀、支付（高并发+强一致）|TCC|性能优先，允许业务侵入|
|订单全流程、供应链（长事务+低耦合）|SAGA|流程长，需补偿机制|
|电商、社交（高可用+低耦合）|消息队列事务|性价比高，通用场景|
# 六、关键提醒：避坑指南

1. 不要盲目追求“强一致性”：大多数业务场景下，“最终一致性”完全满足需求，强一致性会牺牲性能和可用性。

2. 重试机制必不可少：无论是TCC的Cancel、SAGA的补偿还是消息队列的消费，都要考虑“执行失败”的情况，需设计幂等重试（避免重复执行）。

3. 监控与对账：分布式事务可能出现“异常状态”，需配套监控告警和定期对账机制，及时修复数据不一致问题。