# 里氏替换原则

## 一、什么是里氏替换原则（LSP）？

里氏替换原则是面向对象设计（OOD）五大基本原则（SOLID）中的重要原则，由芭芭拉·利斯科夫（Barbara Liskov）于1987年提出，是实现开闭原则的重要保障。

**核心定义**：如果对每一个类型为S的对象o1，都存在一个类型为T的对象o2，使得以T定义的所有程序P在所有对象o1替换成o2时，程序P的行为没有发生变化，那么类型S是类型T的子类型。

通俗提炼：“子类可替换父类，且不改变程序正确性”——子类应能无缝替代父类，同时保证原有程序逻辑正常运行。

## 二、原则的本质：维护继承的正确性

LSP的本质是规范**继承关系的设计**，避免因不当继承导致“子类破坏父类契约”。继承的核心价值是代码复用与多态，但若子类随意修改父类的核心行为（如前置条件强化、后置条件弱化、异常类型变更等），会使继承关系失去意义，还会引入潜在Bug。

核心契约要求：子类在继承父类时，需遵守父类定义的行为规范，包括方法的输入输出规则、异常抛出约定、业务逻辑约束等，确保替换后程序行为一致。

## 三、为什么要遵守LSP？

- **保障多态安全**：LSP是多态的“安全锁”，确保子类对象在替换父类对象时，不会破坏原有程序逻辑，让多态机制可靠运行。

- **强化代码复用**：符合LSP的继承关系，子类可真正复用父类代码，无需修改父类或在使用时额外处理子类差异，提升复用效率。

- **降低维护成本**：若子类违反LSP，使用时需针对子类单独处理，增加代码复杂度；遵循LSP可减少“特殊处理”逻辑，降低维护难度。

- **支撑开闭原则**：只有子类能无缝替换父类，才能通过新增子类扩展功能（符合开闭原则），否则扩展时需修改原有使用父类的代码。

## 四、常见违反LSP的场景与反例

LSP的违反往往体现在子类破坏父类的行为契约，以下是三个典型场景及反例，帮助快速识别问题。

### 1. 场景一：子类强化父类前置条件

父类方法对输入参数无严格限制，子类却增加输入校验，导致父类能处理的参数子类无法处理，无法替换。

```java

// 父类：矩形类，支持设置宽和高
public class Rectangle {
    protected int width;
    protected int height;
    
    public void setWidth(int width) {
        this.width = width;
    }
    
    public void setHeight(int height) {
        this.height = height;
    }
    
    public int getArea() {
        return width * height;
    }
}

// 子类：正方形类，继承矩形（逻辑上正方形是特殊矩形）
public class Square extends Rectangle {
    // 违反LSP：强化前置条件，强制宽高相等
    @Override
    public void setWidth(int width) {
        super.setWidth(width);
        super.setHeight(width); // 设宽时同步设高
    }
    
    @Override
    public void setHeight(int height) {
        super.setHeight(height);
        super.setWidth(height); // 设高时同步设宽
    }
}

// 测试：父类场景子类无法替换
public class Test {
    // 父类逻辑：设置宽高为2和3，面积应为6
    public static void calculateArea(Rectangle rectangle) {
        rectangle.setWidth(2);
        rectangle.setHeight(3);
        System.out.println("面积：" + rectangle.getArea());
    }
    
    public static void main(String[] args) {
        Rectangle rectangle = new Rectangle();
        calculateArea(rectangle); // 正常输出6
        
        Square square = new Square();
        calculateArea(square); // 输出9（宽高被同步为3），破坏原有逻辑
    }
}

```

问题：正方形子类通过重写set方法强化了前置条件（宽高必须相等），导致父类能正常处理的“宽2高3”场景，子类替换后结果错误，违反LSP。

### 2. 场景二：子类弱化父类后置条件

父类方法承诺返回特定范围的结果，子类却返回超出范围的结果，破坏父类的输出契约。

```java

// 父类：计算器类，承诺返回正数结果
public class Calculator {
    // 父类契约：返回两个正数的和（前置条件：参数为正）
    public int addPositive(int a, int b) {
        if (a <= 0 || b <= 0) {
            throw new IllegalArgumentException("参数必须为正");
        }
        return a + b; // 后置条件：结果为正
    }
}

// 子类：违规计算器，返回负数
public class IllegalCalculator extends Calculator {
    // 违反LSP：弱化后置条件，可能返回负数
    @Override
    public int addPositive(int a, int b) {
        // 移除父类前置校验，允许负数参数
        return a + b; // 当a=1、b=-2时，返回-1，破坏父类后置契约
    }
}

// 测试：子类替换后结果异常
public class Test {
    public static void useCalculator(Calculator calculator) {
        try {
            int result = calculator.addPositive(1, -2);
            System.out.println("结果：" + result); // 父类会抛异常，子类返回-1
        } catch (IllegalArgumentException e) {
            System.out.println("参数错误：" + e.getMessage());
        }
    }
    
    public static void main(String[] args) {
        Calculator normal = new Calculator();
        useCalculator(normal); // 输出参数错误
        
        IllegalCalculator illegal = new IllegalCalculator();
        useCalculator(illegal); // 输出结果：-1，逻辑异常
    }
}

```

### 3. 场景三：子类抛出父类未声明的异常

父类方法未声明某种异常，子类重写后却抛出该异常，导致调用者未处理而崩溃。

```java

// 父类：文件读取类，不抛IO异常（简化示例）
public class FileReader {
    public String readContent(String path) {
        // 父类逻辑：简化处理，不抛异常
        return "模拟内容";
    }
}

// 子类：真实文件读取类，抛出IO异常
public class RealFileReader extends FileReader {
    // 违反LSP：抛出父类未声明的异常
    @Override
    public String readContent(String path) {
        try {
            // 真实读取逻辑，可能抛IO异常
            return new java.io.BufferedReader(new java.io.FileReader(path)).readLine();
        } catch (java.io.IOException e) {
            throw new RuntimeException(e); // 抛出父类未声明的运行时异常
        }
    }
}

// 测试：子类替换后抛出未预期异常
public class Test {
    public static void read(FileReader reader) {
        String content = reader.readContent("test.txt"); // 父类正常，子类可能抛异常
        System.out.println("内容：" + content);
    }
    
    public static void main(String[] args) {
        FileReader fake = new FileReader();
        read(fake); // 正常输出
        
        RealFileReader real = new RealFileReader();
        read(real); // 抛出RuntimeException，程序崩溃
    }
}

```

## 五、如何遵守LSP？优化示范

遵守LSP的核心是**确保子类与父类行为一致**，避免破坏父类契约。针对上述反例，可通过以下方式优化。

### 1. 优化场景一：重构继承为组合

正方形与矩形的“is-a”关系在行为上不成立（宽高约束不同），应改为“has-a”组合关系，消除不当继承。

```java

// 优化1：定义形状抽象接口（稳定行为）
public interface Shape {
    int getArea();
}

// 优化2：矩形类实现形状接口
public class Rectangle implements Shape {
    private int width;
    private int height;
    
    public void setWidth(int width) {
        this.width = width;
    }
    
    public void setHeight(int height) {
        this.height = height;
    }
    
    @Override
    public int getArea() {
        return width * height;
    }
}

// 优化3：正方形类实现形状接口，内部组合矩形（而非继承）
public class Square implements Shape {
    private Rectangle rectangle;
    
    public Square() {
        this.rectangle = new Rectangle();
    }
    
    public void setSide(int side) {
        rectangle.setWidth(side);
        rectangle.setHeight(side);
    }
    
    @Override
    public int getArea() {
        return rectangle.getArea();
    }
}

// 测试：各自行为一致，无替换问题
public class Test {
    public static void calculateArea(Shape shape) {
        System.out.println("面积：" + shape.getArea());
    }
    
    public static void main(String[] args) {
        Rectangle rectangle = new Rectangle();
        rectangle.setWidth(2);
        rectangle.setHeight(3);
        calculateArea(rectangle); // 输出6
        
        Square square = new Square();
        square.setSide(3);
        calculateArea(square); // 输出9，行为符合预期
    }
}

```

### 2. 优化场景二、三：严格遵循父类契约

- **前置条件**：子类可弱化父类前置条件（如父类要求参数>10，子类可允许>5），但不可强化。

- **后置条件**：子类可强化父类后置条件（如父类返回正数，子类返回正偶数），但不可弱化。

- **异常处理**：子类重写方法时，可抛出父类异常的子类异常，或不抛异常，但不可抛出父类未声明的新异常。

```java

// 优化场景二：子类遵循父类契约
public class LegalCalculator extends Calculator {
    // 遵守LSP：要么继承父类前置校验，要么弱化（如允许0）
    @Override
    public int addPositive(int a, int b) {
        // 弱化前置条件：允许0，仍保证结果非负
        if (a < 0 || b < 0) {
            throw new IllegalArgumentException("参数不能为负");
        }
        return a + b; // 结果非负，符合父类核心契约
    }
}

```

## 六、实践中的关键注意点

1. **区分“is-a”与“is-a-kind-of”**：逻辑上的“属于”不代表适合继承，需判断行为契约是否一致。如“企鹅是鸟”，但鸟会飞而企鹅不会，直接继承Bird类会违反LSP，需重构为抽象Animal类。

2. **依赖抽象而非具体**：结合依赖倒置原则，使用抽象类或接口定义契约，子类实现时严格遵守，减少替换风险。

3. **避免子类重写父类非抽象方法**：父类非抽象方法通常代表稳定行为，子类重写易破坏契约。若需变化，应将父类方法设为抽象，由子类实现。

4. **通过单元测试验证LSP**：为父类编写测试用例，子类可直接复用该用例，若测试通过则符合LSP，否则存在契约破坏。

## 七、核心总结

里氏替换原则是**继承关系的“黄金法则”**，其核心是“子类行为与父类契约一致，可无缝替换”。违反LSP会导致多态失效、代码逻辑混乱，而遵循LSP能保障继承复用的安全性，为开闭原则提供支撑。实践中需谨慎设计继承关系，若行为契约不一致，优先采用组合替代继承，同时通过抽象定义清晰契约，并用测试验证替换可行性。
> （注：文档部分内容可能由 AI 生成）