# 事务

## 一、事务基础认知

事务（Transaction）是数据库操作的基本单元，用于保证一组数据库操作“要么全部成功，要么全部失败”，核心是满足**ACID特性**，这是事务一致性的基石：

- **原子性（Atomicity）**：事务中的操作不可分割，要么全执行，要么全回滚（如转账时“扣钱”和“加钱”必须同时成功或同时失败）；

- **一致性（Consistency）**：事务执行前后，数据库数据需符合业务规则（如转账前后两人总金额不变）；

- **隔离性（Isolation）**：多个事务并发执行时，相互不干扰，避免“脏读”“不可重复读”“幻读”等问题；

- **持久性（Durability）**：事务提交后，数据永久保存到数据库，即使系统崩溃也不会丢失。

Spring事务的核心价值：无需手动编写事务管理代码（如JDBC的begin、commit、rollback），通过声明式或编程式方式统一管理事务，降低开发复杂度。

## 二、Spring事务核心特性

### 1. 事务管理类型

Spring支持两种事务管理方式，实际开发中以声明式为主：

1. **声明式事务（推荐）**：通过注解（如`@Transactional`）或XML配置声明事务规则，Spring自动完成事务的开启、提交/回滚，无需侵入业务代码，符合“面向切面编程（AOP）”思想；

2. **编程式事务**：通过`TransactionTemplate`或`PlatformTransactionManager`手动控制事务，灵活性高但代码侵入性强，仅适用于特殊场景（如事务逻辑需动态调整）。

### 2. 事务隔离级别

Spring事务隔离级别对应数据库隔离级别，通过`isolation`属性配置，解决并发事务的干扰问题，常用级别如下：

|隔离级别|说明|解决问题|
|---|---|---|
|DEFAULT（默认）|继承数据库的隔离级别（如MySQL默认REPEATABLE READ）|随数据库配置|
|READ_UNCOMMITTED（读未提交）|允许读取未提交的事务数据|无（会出现脏读、不可重复读、幻读）|
|READ_COMMITTED（读已提交）|仅读取已提交的事务数据|解决脏读|
|REPEATABLE_READ（可重复读）|同一事务内多次读取同一数据结果一致|解决脏读、不可重复读|
|SERIALIZABLE（串行化）|事务串行执行，完全隔离|解决所有并发问题（性能最低）|
### 3. 事务传播行为

当一个事务方法调用另一个事务方法时，Spring通过**传播行为**决定新事务的开启规则，这是Spring事务的核心亮点（数据库本身无此特性），通过`propagation`属性配置，常用行为如下：

- **REQUIRED（默认）**：如果当前有事务，则加入；无事务则新建。最常用（如Service层方法调用DAO层方法，共用同一事务）；

- **REQUIRES_NEW**：无论当前是否有事务，都新建一个事务（原事务暂停）。适用于“独立事务”场景（如记录操作日志，即使主事务回滚，日志也要保留）；

- **SUPPORTS**：调用方无事务 → 被调用方法以非事务执行（不主动新建）；

- **NOT_SUPPORTED**：无论调用方有无，被调用方法都强制非事务（有则暂停）；

- **MANDATORY**：调用方无事务 → 直接抛异常（强制要求有事务）。

- **NESTED**：如果当前有事务，则在嵌套事务中执行（仅对特定数据库支持，如MySQL的SAVEPOINT）。调用方事务内嵌套子事务，子事务回滚不影响父事务，父事务回滚则子事务也回滚。

- **NEVER**：调用方无事务 → 被调用方法非事务执行（符合要求）；

### 4. 事务回滚规则

默认情况下，Spring事务仅在抛出**未检查异常（RuntimeException及其子类）和Error**时回滚，检查异常（如IOException）不回滚。可通过以下配置自定义：

- `rollbackFor`：指定需要回滚的异常（如`rollbackFor = Exception.class`表示所有异常都回滚）；

- `noRollbackFor`：指定不需要回滚的异常（如特定业务异常不回滚）。

## 三、Spring事务实现方式

### 1. 声明式事务（注解方式，最常用）

步骤简单，无需XML配置（Spring Boot自动支持）：

1. **添加依赖**：Spring Boot项目引入`spring-boot-starter-jdbc`或`spring-boot-starter-data-jpa`，自动注入事务管理器；

2. **开启事务支持**：在启动类添加`@EnableTransactionManagement`（Spring Boot可省略，自动开启）；

3. **添加注解**：在Service层的业务方法上添加`@Transactional`，并配置必要属性（如隔离级别、传播行为）。

示例代码：

```java

@Service
public class OrderService {
    @Autowired
    private OrderMapper orderMapper;
    
    // 声明式事务：默认REQUIRED传播，默认隔离级别，RuntimeException回滚
    @Transactional(rollbackFor = Exception.class) // 所有异常都回滚
    public void createOrder(Order order) {
        orderMapper.insert(order);
        // 调用其他服务方法（共用同一事务）
        payService.pay(order.getId());
    }
}
```

### 2. 编程式事务（TransactionTemplate）

适用于灵活控制事务场景，示例代码：

```java

@Service
public class LogService {
    @Autowired
    private TransactionTemplate transactionTemplate;
    @Autowired
    private LogMapper logMapper;
    
    public void saveLog(Log log) {
        // 编程式事务
        transactionTemplate.execute(status -> {
            try {
                logMapper.insert(log);
                return true; // 成功提交
            } catch (Exception e) {
                status.setRollbackOnly(); // 失败回滚
                return false;
            }
        });
    }
}
```

## 四、常见问题与注意事项

- **注解失效场景**：

① 非public方法（Spring事务仅对public方法生效）；

② 自调用（同一类中方法调用自身带`@Transactional`的方法，AOP无法拦截，需通过Spring上下文获取代理对象）；

③ 异常被手动捕获（未抛出异常，Spring无法感知回滚）；

- **事务粒度问题**：事务应加在**Service层业务方法**上，而非DAO层（避免单个SQL也开启事务，影响性能）；避免事务范围过大（如包含远程调用，增加锁时间）；

- **分布式事务**：单库事务用Spring本地事务即可，跨库/跨服务事务需用分布式事务方案（如Seata、Saga，Spring事务不直接支持）；

- **性能优化**：高并发场景下，避免使用串行化隔离级别；合理设置事务传播行为，减少不必要的事务创建。

## 五、核心总结

1. Spring事务核心是**声明式事务**，通过AOP实现无侵入式管理，核心特性为**传播行为**（区别于数据库事务）；

2. 关键配置：隔离级别（解决并发问题）、传播行为（解决方法间事务协同）、回滚规则（控制异常回滚逻辑）；

3. 避坑要点：确保注解作用于public方法、避免自调用、不手动吞异常；

4. 适用场景：单库的业务逻辑一致性控制，分布式场景需扩展分布式事务方案。
> （注：文档部分内容可能由 AI 生成）