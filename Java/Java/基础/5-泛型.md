# 泛型

本文档为 Java 泛型核心知识点总结，涵盖概念、优势、核心使用方式、通配符、类型擦除及常见问题，适合作为个人学习笔记快速查阅，也可用于 Blog 分享。

# 一、泛型是什么？

泛型（Generics）是 Java 5 引入的核心特性，本质是**参数化类型**——允许在定义类、接口、方法时不指定具体类型，而是通过“类型参数”来表示，在使用时再传入具体类型（如 String、Integer 等）。

核心作用：将类型检查从“运行时”提前到“编译时”，避免强制类型转换，提高代码复用性和安全性。


      举个直观例子：没有泛型时，List 默认存储 Object 类型，存 Integer 取出来要强制转型；有泛型后，List<Integer> 明确存储 Integer，编译时就会检查类型，取出无需转型。
    

# 二、为什么要用泛型？（核心优势）

1. **类型安全**：编译时检查传入的类型是否匹配，避免运行时抛出 ClassCastException。
例如：List<String> 中添加 Integer 会直接编译报错，而不是运行时崩溃。

2. **消除强制转型**：使用泛型定义的容器/类，获取元素时无需手动转型，代码更简洁。
对比：
无泛型：List list = new ArrayList(); list.add("abc"); String s = (String) list.get(0);
有泛型：List<String> list = new ArrayList<>(); list.add("abc"); String s = list.get(0);

3. **代码复用**：通过类型参数抽象共性逻辑，一套代码适配多种类型。
例如：一个泛型工具类 `Utils<T>` 可处理 String、Integer 等不同类型的对象，无需为每种类型写重复代码。

4. **支持通用算法**：结合集合框架，实现通用的排序、过滤等算法，适配不同类型集合。

# 三、泛型的核心使用场景

泛型主要用于**类、接口、方法**的定义，对应“泛型类”“泛型接口”“泛型方法”三种形式。

## 3.1 泛型类

定义类时声明类型参数，使用时指定具体类型。常用于容器类（如 ArrayList、HashMap）。

### 3.1.1 语法格式

```java

// 定义：类名后加 <类型参数标识符>，标识符通常用单个大写字母（如 T、E、K、V）
public class 类名<T> {
    // 成员变量可使用类型参数
    private T data;
    
    // 构造器、方法可使用类型参数
    public T getData() {
        return data;
    }
    
    public void setData(T data) {
        this.data = data;
    }
}

```

### 3.1.2 类型参数命名规范（约定俗成）

- T：Type（通用类型）

- E：Element（集合元素类型，如 List<E>）

- K：Key（键类型，如 Map<K,V>）

- V：Value（值类型，如 Map<K,V>）

- N：Number（数值类型）

- S、U、V：多类型参数时使用

### 3.1.3 使用示例

```java

// 1. 使用时指定具体类型（String）
GenericClass<String> strObj = new GenericClass<>();
strObj.setData("泛型测试");
String strData = strObj.getData(); // 无需转型

// 2. 指定 Integer 类型
GenericClass<Integer> intObj = new GenericClass<>();
intObj.setData(123);
Integer intData = intObj.getData();

```

## 3.2 泛型接口

定义接口时声明类型参数，实现接口时需指定具体类型或继续保留泛型。

### 3.2.1 语法格式

```java

// 定义泛型接口
public interface 接口名<T> {
    T method();
}

```

### 3.2.2 实现方式

```java

// 方式1：实现时指定具体类型（如 String）
public class ImplClass1 implements GenericInterface<String> {
    @Override
    public String method() {
        return "指定 String 类型实现";
    }
}

// 方式2：实现时保留泛型（泛型实现类）
public class ImplClass2<T> implements GenericInterface<T> {
    @Override
    public T method() {
        return null;
    }
}
// 使用方式2的类
ImplClass2<Integer> impl2 = new ImplClass2<>();
Integer result = impl2.method();

```

## 3.3 泛型方法

在方法声明时单独声明类型参数（与类/接口的泛型无关，即使类不是泛型类，也可定义泛型方法）。

### 3.3.1 关键特征

方法返回值前必须加 `<T>` 声明类型参数，否则 T 会被当作具体类名。

### 3.3.2 语法格式

```java

// 普通类中的泛型方法
public class GenericMethodDemo {
    // 泛型方法：<T> 声明类型参数，T 为返回值类型，param 为参数类型
    public <T> T getValue(T param) {
        return param;
    }
    
    // 静态泛型方法（同理，需加 <T>）
    public static <T> void print(T param) {
        System.out.println(param);
    }
}

```

### 3.3.3 使用示例

```java

GenericMethodDemo demo = new GenericMethodDemo();

// 1. 自动类型推断（无需指定 T，编译器根据参数推断）
String str = demo.getValue("hello");
Integer num = demo.getValue(123);

// 2. 显式指定类型（在方法名前加 <类型>）
Boolean flag = demo.<Boolean>getValue(true);

// 3. 静态泛型方法使用
GenericMethodDemo.<String>print("静态泛型方法");
GenericMethodDemo.print(456); // 自动推断

```

# 四、泛型通配符（?）

当不确定泛型的具体类型，或需要适配多种类型时，使用**通配符 ?**。通配符有三种形式：无界通配符、上界通配符、下界通配符。

## 4.1 无界通配符（?）

表示“任意类型”，但获取元素时只能当作 Object 处理，且不能向容器中添加元素（除了 null）。

### 4.1.1 使用场景

仅读取泛型对象的内容，不修改（如打印集合元素）。

### 4.1.2 示例

```java

// 打印任意类型的 List 集合
public void printList(List<?> list) {
    for (Object obj : list) {
        System.out.println(obj);
    }
    // list.add("abc"); // 编译报错：无法确定类型，禁止添加非 null 元素
    list.add(null); // 允许添加 null
}

// 调用
List<String> strList = Arrays.asList("a", "b");
List<Integer> intList = Arrays.asList(1, 2);
printList(strList); // 适配
printList(intList); // 适配

```

## 4.2 上界通配符（? extends T）

表示“T 及其子类的任意类型”，限定了类型的**上限**。

### 4.2.1 核心特点

- 可读取：能安全获取 T 类型的元素（因为子类对象可向上转型为父类）。

- 不可写入：不能向容器中添加元素（除了 null），因为无法确定具体是 T 的哪个子类。

### 4.2.2 使用场景

需要读取泛型对象，且对象类型是某个父类的子类（如统计数字集合的总和，数字是 Number 的子类）。

### 4.2.3 示例

```java

// 计算 Number 及其子类（Integer、Double）集合的总和
public double sum(List<? extends Number> list) {
    double total = 0;
    for (Number num : list) {
        total += num.doubleValue(); // 安全读取，转型为 Number
    }
    // list.add(1); // 编译报错：无法确定是 Integer 还是 Double 等子类
    return total;
}

// 调用
List<Integer> intList = Arrays.asList(1, 2, 3);
List<Double> doubleList = Arrays.asList(1.5, 2.5);
System.out.println(sum(intList)); // 6.0
System.out.println(sum(doubleList)); // 4.0

```

## 4.3 下界通配符（? super T）

表示“T 及其父类的任意类型”，限定了类型的**下限**。

### 4.3.1 核心特点

- 可写入：能向容器中添加 T 类型或其子类的元素（因为子类可向上转型为父类）。

- 不可读取：获取元素时只能当作 Object 处理，因为无法确定具体是 T 的哪个父类。

### 4.3.2 使用场景

需要向泛型对象中添加元素，且元素类型是某个子类的父类（如向集合中添加 Integer，集合类型可以是 Number 或 Object）。

### 4.3.3 示例

```java

// 向集合中添加 Integer 元素（集合类型可为 Integer、Number、Object）
public void addInteger(List<? super Integer> list) {
    list.add(1); // 允许添加 Integer 及其子类（如 Integer 本身）
    list.add(2);
    // Integer num = list.get(0); // 编译报错：获取时只能当作 Object
    Object obj = list.get(0); // 允许
}

// 调用
List<Integer> intList = new ArrayList<>();
List<Number> numList = new ArrayList<>();
List<Object> objList = new ArrayList<>();

addInteger(intList); // 适配
addInteger(numList); // 适配
addInteger(objList); // 适配

```


      通配符记忆口诀：上界 extends 读安全，下界 super 写安全，无界 ? 只读不写（除 null）。
    

# 五、泛型的核心限制：类型擦除

Java 泛型是“伪泛型”——**编译时会将泛型的类型参数擦除为原始类型（Raw Type）**，运行时 JVM 不感知泛型类型信息。这是为了兼容 Java 5 之前的版本。

## 5.1 类型擦除规则

1. 无界泛型：擦除为 Object（如 List<T> → List）。

2. 上界泛型：擦除为上界类型（如 List<? extends Number> → List<Number>）。

3. 下界泛型：擦除为 Object（如 List<? super Integer> → List<Object>）。

## 5.2 类型擦除带来的影响

### 5.2.1 不能实例化类型参数

```java

public <T> void createObj() {
    // T t = new T(); // 编译报错：类型擦除后 T 变为 Object，无法确定具体构造器
}

```

解决办法：通过反射传入 Class 对象实例化。

```java

public <T> T createObj(Class<T> clazz) throws InstantiationException, IllegalAccessException {
    return clazz.newInstance(); // 反射实例化
}

```

### 5.2.2 不能使用基本类型作为类型参数

因为类型擦除后会变为 Object，而基本类型（int、char 等）不是 Object 的子类，需使用对应的包装类（Integer、Character）。

```java

// List<int> list = new ArrayList<>(); // 编译报错
List<Integer> list = new ArrayList<>(); // 正确

```

### 5.2.3 不能使用泛型数组

```java

// List<String>[] arr = new List<String>[10]; // 编译报错
List<?>[] arr = new List<?>[10]; // 允许（通配符数组）
List<String> list = new ArrayList<>();
arr[0] = list;

```

### 5.2.4 泛型类的静态方法不能使用类的泛型参数

静态方法加载时，泛型类的类型参数尚未确定（需实例化时才指定），因此静态方法需单独声明泛型参数（即静态泛型方法）。

```java

public class GenericClass<T> {
    // public static T getValue() { ... } // 编译报错：静态方法不能使用类的 T
    public static <T> T getValue() { ... } // 正确：静态泛型方法
}

```

### 5.2.5 不能判断泛型类型（instanceof 不支持）

运行时泛型类型已擦除，无法通过 instanceof 判断具体类型。

```java

List<String> list = new ArrayList<>();
// if (list instanceof List<String>) { ... } // 编译报错
if (list instanceof List) { ... } // 正确：判断原始类型

```

# 六、其他重要知识点

## 6.1 原始类型（Raw Type）

原始类型是泛型类/接口未指定类型参数时的默认类型（如 List 是 List<T> 的原始类型），用于兼容 Java 5 之前的代码。


      警告：避免使用原始类型！使用原始类型会丢失泛型的类型安全校验，可能导致运行时 ClassCastException。
    

```java

// 原始类型使用（不推荐）
List rawList = new ArrayList();
rawList.add("abc");
rawList.add(123); // 编译不报错
String s = (String) rawList.get(1); // 运行时抛 ClassCastException

```

## 6.2 泛型限定（Bounds）

定义泛型时，可通过 `extends` 限定类型参数的上界（只能是指定类的子类或指定接口的实现类），支持多个上界（类在前，接口在后，用 & 连接）。

```java

// 1. 单上界（T 必须是 Number 的子类）
public class GenericBound1<T extends Number> { ... }

// 2. 多上界（T 必须是 Serializable 且是 Comparable 的实现类）
public class GenericBound2<T extends Serializable & Comparable> { ... }

// 错误示例：类不能有多个（只能有一个类上界，且在最前面）
// public class GenericBound3<T extends Number & String> { ... }

```

## 6.3 泛型与继承的关系

泛型不支持协变（即 Parent 是 Child 的父类，但 List<Parent> 不是 List<Child> 的父类），需通过通配符实现兼容。

```java

class Parent {}
class Child extends Parent {}

// 错误：泛型不支持协变
// List<Parent> parentList = new ArrayList<Child>();

// 正确：使用上界通配符实现兼容
List<? extends Parent> parentList = new ArrayList<Child>();

```

# 七、常见问题与解决方案

|常见问题|原因|解决方案|
|---|---|---|
|无法实例化 T|类型擦除后 T 变为 Object，无法确定构造器|通过反射传入 Class<T> 实例化，或使用工厂模式|
|泛型数组编译报错|类型擦除导致数组无法确定元素类型|使用通配符数组（List<?>[]），或用集合替代数组|
|instanceof 无法判断泛型类型|运行时泛型类型已擦除|判断原始类型（如 List），或通过反射获取泛型参数|
|静态方法不能使用类泛型参数|静态方法加载时泛型类未实例化，类型参数未确定|将静态方法定义为静态泛型方法（单独声明 <T>）|
# 八、核心知识点总结

- 泛型是参数化类型，核心价值是类型安全、消除转型、代码复用。

- 三大使用形式：泛型类、泛型接口、泛型方法（方法需单独声明 <T>）。

- 通配符三形式：无界（?）、上界（? extends T）、下界（? super T），分别对应不同读写场景。

- 关键限制：类型擦除导致运行时无泛型信息，需规避实例化 T、基本类型作为参数等问题。

- 泛型不支持协变，需通过上界通配符实现继承关系兼容。
> （注：文档部分内容可能由 AI 生成）