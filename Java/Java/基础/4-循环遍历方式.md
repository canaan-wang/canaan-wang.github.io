# 循环遍历方式

## 一、基础循环遍历（适用于数组、集合通用）

### 1. 普通 for 循环（索引遍历）

**核心原理**：通过索引（下标）访问容器中的元素，需明确容器的长度（数组用`length`，集合用`size()`），手动控制索引递增/递减。

**适用场景**：数组、支持索引访问的集合（如ArrayList）；需要在遍历中修改索引（如跳步遍历、反向遍历）；需要获取元素索引。

**优缺点**：

- 优点：可灵活控制遍历顺序和步长，能获取索引，支持元素修改（通过索引赋值）。

- 缺点：代码相对繁琐，需手动维护索引；对于非索引集合（如LinkedList），通过索引访问效率极低（时间复杂度O(n²)）。

### 2. 增强for循环（foreach循环）

**核心原理**：JDK5 引入，底层依赖迭代器（Iterator）实现，无需手动维护索引，直接遍历容器中的每个元素。

**适用场景**：数组、所有实现`Iterable`接口的集合（Java中大部分集合如List、Set、Map的entrySet等都实现了该接口）；仅需遍历元素，无需索引或修改遍历顺序。

**优缺点**：

- 优点：代码简洁优雅，减少索引相关的错误（如数组越界）。

- 缺点：无法获取元素索引；遍历过程中**禁止修改容器结构**（如add/remove元素），否则会抛出`ConcurrentModificationException`；无法修改基本类型数组的元素（值传递）。

**代码示例**：

```java

// 1. 遍历数组
int[] arr = {1, 2, 3, 4, 5};
for (int num : arr) {
    System.out.println("数组元素：" + num);
    // 注意：修改num不会改变原数组（值传递）
    num = 10;
}

// 2. 遍历List
List<String> list = new ArrayList<>(Arrays.asList("A", "B", "C"));
for (String str : list) {
    System.out.println("List元素：" + str);
}

// 3. 遍历Set（Set无索引，foreach是常用方式）
Set<Integer> set = new HashSet<>(Arrays.asList(10, 20, 30));
for (Integer num : set) {
    System.out.println("Set元素：" + num);
}

// 4. 遍历Map（需先转entrySet或keySet）
Map<String, Integer> map = new HashMap<>();
map.put("A", 1);
map.put("B", 2);
// 遍历键值对（推荐）
for (Map.Entry<String, Integer> entry : map.entrySet()) {
    System.out.println("键：" + entry.getKey() + "，值：" + entry.getValue());
}
// 仅遍历键
for (String key : map.keySet()) {
    System.out.println("键：" + key);
}
```

## 二、集合专用遍历（依赖集合框架接口）

针对Java集合框架（Collection、Map）设计的遍历方式，更贴合集合的特性，如迭代器支持fail-fast机制，Map专用遍历适配键值对结构。

### 1. 迭代器（Iterator）遍历

**核心原理**：Java集合框架的标准遍历接口（`Iterator`），定义了`hasNext()`（判断是否有下一个元素）和`next()`（获取下一个元素）方法，增强for循环底层就是通过它实现的。

**适用场景**：所有实现`Iterable`接口的集合（List、Set、Queue等）；需要在遍历过程中**安全修改容器结构**（如remove元素）。

**优缺点**：

- 优点：支持在遍历中通过`remove()`方法安全删除元素（避免并发修改异常）；是集合遍历的标准方式，兼容性强。

- 缺点：代码比foreach繁琐；仅支持正向遍历；无法直接获取元素索引（需手动计数）。

**代码示例**：

```java

// 1. 遍历List
List<String> list = new ArrayList<>(Arrays.asList("A", "B", "C", "D"));
Iterator<String> iterator = list.iterator();
while (iterator.hasNext()) {
    String str = iterator.next();
    // 遍历中安全删除元素（避免ConcurrentModificationException）
    if (str.equals("B")) {
        iterator.remove(); // 正确方式
        // list.remove(str); // 错误方式，会抛出异常
    }
    System.out.println("List元素：" + str);
}

// 2. 遍历Set
Set<Integer> set = new HashSet<>(Arrays.asList(10, 20, 30));
Iterator<Integer> setIterator = set.iterator();
while (setIterator.hasNext()) {
    System.out.println("Set元素：" + setIterator.next());
}
```

### 2. 列表迭代器（ListIterator）遍历

**核心原理**：`Iterator`的子接口，仅适用于List集合，扩展了反向遍历、获取索引、添加/修改元素等功能。

**适用场景**：仅List集合；需要反向遍历、获取元素索引，或在遍历中添加/修改元素。

**优缺点**：

- 优点：支持正向+反向遍历；能获取元素的索引（`nextIndex()`/`previousIndex()`）；支持遍历中添加（`add()`）、修改（`set()`）元素。

- 缺点：仅适用于List，不支持Set、Map等其他集合；代码相对复杂。

**代码示例**：

```java

List<String> list = new ArrayList<>(Arrays.asList("A", "B", "C"));
ListIterator<String> listIterator = list.listIterator();

// 1. 正向遍历（类似Iterator）
System.out.println("正向遍历：");
while (listIterator.hasNext()) {
    // 获取下一个元素的索引
    int index = listIterator.nextIndex();
    String str = listIterator.next();
    System.out.println("索引：" + index + "，元素：" + str);
    // 遍历中修改元素（将"B"改为"B1"）
    if (str.equals("B")) {
        listIterator.set("B1");
    }
}

// 2. 反向遍历（需先正向遍历到末尾，或从指定索引开始）
System.out.println("反向遍历：");
while (listIterator.hasPrevious()) {
    int index = listIterator.previousIndex();
    String str = listIterator.previous();
    System.out.println("索引：" + index + "，元素：" + str);
    // 遍历中添加元素（在当前元素前添加）
    if (str.equals("A")) {
        listIterator.add("A0");
    }
}

System.out.println("最终List：" + list); // 输出：[A0, A, B1, C]
```

### 3. Map专用遍历（键值对遍历）

**核心原理**：Map不实现`Iterable`接口，无法直接用foreach或Iterator遍历，需通过`keySet()`（键集合）、`values()`（值集合）或`entrySet()`（键值对集合）转换为可遍历的集合后再遍历。

**适用场景**：所有Map实现类（HashMap、TreeMap、LinkedHashMap等），根据需求选择遍历键、值或键值对。

**效率对比**：`entrySet()` > `keySet()`（`keySet()`需通过键二次获取值，多一次查找）；`values()`仅遍历值，效率与`entrySet()`相当。

**代码示例**：

```java

Map<String, Integer> map = new HashMap<>();
map.put("Java", 100);
map.put("Python", 90);
map.put("C++", 85);

// 方式1：遍历键值对（推荐，效率最高）
System.out.println("遍历键值对：");
for (Map.Entry<String, Integer> entry : map.entrySet()) {
    String key = entry.getKey();
    Integer value = entry.getValue();
    System.out.println(key + "：" + value);
}

// 方式2：遍历键，再通过键获取值（效率较低）
System.out.println("遍历键：");
for (String key : map.keySet()) {
    Integer value = map.get(key);
    System.out.println(key + "：" + value);
}

// 方式3：仅遍历值
System.out.println("遍历值：");
for (Integer value : map.values()) {
    System.out.println("值：" + value);
}

// 方式4：通过Iterator遍历entrySet（支持遍历中删除）
System.out.println("Iterator遍历Map：");
Iterator<Map.Entry<String, Integer>> mapIterator = map.entrySet().iterator();
while (mapIterator.hasNext()) {
    Map.Entry<String, Integer> entry = mapIterator.next();
    if (entry.getKey().equals("Python")) {
        mapIterator.remove(); // 安全删除
    }
    System.out.println(entry.getKey() + "：" + entry.getValue());
}
```

## 三、JDK8+ 新特性遍历（函数式编程风格）

JDK8引入Lambda表达式和Stream API后，遍历方式更加简洁，支持链式调用和并行遍历，适合复杂的遍历+处理场景。

### 1. 集合 forEach() 方法（ Lambda 表达式）

**核心原理**：JDK8为`Iterable`接口新增`forEach(Consumer<? super T> action)`方法，接收Lambda表达式（消费型接口），底层仍依赖迭代器，属于函数式编程风格的遍历。

**适用场景**：所有实现`Iterable`的集合（List、Set）及Map的子集合（entrySet、keySet、values）；希望用简洁的Lambda表达式遍历，或结合方法引用。

**优缺点**：

- 优点：代码极简，支持方法引用（如`System.out::println`）；遍历逻辑与业务逻辑分离。

- 缺点：遍历中**禁止修改容器结构**（会抛出并发修改异常）；调试相对困难（Lambda表达式无行号）。

**代码示例**：

```java

// 1. 遍历List
List<String> list = new ArrayList<>(Arrays.asList("A", "B", "C"));
// 基础Lambda
list.forEach(str -> System.out.println("List元素：" + str));
// 方法引用（更简洁）
list.forEach(System.out::println);

// 2. 遍历Set
Set<Integer> set = new HashSet<>(Arrays.asList(10, 20, 30));
set.forEach(num -> {
    if (num > 15) {
        System.out.println("Set中大于15的元素：" + num);
    }
});

// 3. 遍历Map（通过entrySet、keySet等）
Map<String, Integer> map = new HashMap<>();
map.put("Java", 100);
map.put("Python", 90);
// 遍历键值对
map.entrySet().forEach(entry -> {
    System.out.println(entry.getKey() + "：" + entry.getValue());
});
// 仅遍历值
map.values().forEach(value -> System.out.println("值：" + value));
```

### 2. Stream API 遍历

**核心原理**：JDK8引入的Stream（流）是数据处理的管道，通过`stream()`（串行流）或`parallelStream()`（并行流）获取流对象后，结合`forEach()`或`forEachOrdered()`遍历，支持中间操作（如过滤、映射）和终止操作。

**适用场景**：复杂的遍历场景（如遍历前过滤元素、转换元素类型、排序等）；需要并行遍历提升效率（大数据量场景）。

**优缺点**：

- 优点：支持链式调用（如过滤+遍历一步完成）；支持并行遍历（自动利用多核CPU）；可结合大量中间操作简化业务逻辑。

- 缺点：并行流存在线程安全问题（需使用线程安全的集合或处理方式）；有一定学习成本；不适合简单的纯遍历场景（性能略低于普通遍历）。

**代码示例**：

```java

List<Integer> list = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9);

// 1. 串行流遍历（结合过滤、映射）
System.out.println("串行流：过滤偶数并乘2");
list.stream()
    .filter(num -> num % 2 == 0) // 中间操作：过滤偶数
    .map(num -> num * 2) // 中间操作：元素乘2
    .forEach(System.out::println); // 终止操作：遍历输出

// 2. 并行流遍历（大数据量效率更高）
System.out.println("并行流：过滤奇数并求和（遍历过程中累加）");
AtomicInteger sum = new AtomicInteger(0);
list.parallelStream()
    .filter(num -> num % 2 != 0) // 过滤奇数
    .forEach(num -> sum.addAndGet(num)); // 累加（使用原子类保证线程安全）
System.out.println("奇数和：" + sum.get());

// 3. forEachOrdered（并行流中保证遍历顺序，性能略降）
System.out.println("并行流保证顺序：");
list.parallelStream()
    .forEachOrdered(num -> System.out.print(num + " ")); // 输出顺序与原集合一致

// 4. Map的Stream遍历
Map<String, Integer> map = new HashMap<>();
map.put("Java", 100);
map.put("Python", 90);
map.put("C++", 85);
// 过滤值大于85的键值对并遍历
map.entrySet().stream()
    .filter(entry -> entry.getValue() > 85)
    .forEach(entry -> System.out.println(entry.getKey() + "：" + entry.getValue()));
```

## 四、遍历方式选择指南

根据不同场景选择最优遍历方式，可提升代码效率和可读性：

|场景需求|推荐遍历方式|不推荐方式|
|---|---|---|
|数组遍历（需索引/修改元素）|普通for循环|增强for循环（无法修改元素）|
|数组遍历（仅读，无索引需求）|增强for循环|普通for循环（代码繁琐）|
|List遍历（需索引/反向遍历）|普通for循环、ListIterator|Iterator（无索引）|
|List/Set遍历（仅读，无索引）|增强for循环、forEach(Lambda)|普通for循环（Set无索引）|
|遍历中删除元素|Iterator、ListIterator|增强for循环、forEach(Lambda)|
|Map遍历（键值对）|entrySet() + 增强for/forEach|keySet() + get()（效率低）|
|复杂逻辑（过滤、映射、排序）|Stream API|普通for循环（代码冗余）|
|大数据量遍历（多核优化）|parallelStream（需注意线程安全）|串行遍历（效率低）|
## 五、常见问题与注意事项

### 1. 并发修改异常（ConcurrentModificationException）

**原因**：增强for循环、forEach(Lambda)底层依赖迭代器，遍历过程中修改容器结构（add/remove）会导致迭代器的预期修改次数与实际不一致。

**解决方案**：使用Iterator的`remove()`方法；使用线程安全集合（如CopyOnWriteArrayList）；遍历前复制一份集合。

### 2. 并行流的线程安全问题

**问题**：并行流遍历非线程安全集合（如ArrayList）时，若进行add/remove操作，会导致数据错乱。

**解决方案**：使用线程安全集合（如ConcurrentHashMap）；使用`collect()`方法收集结果（而非手动修改集合）；避免在并行流中修改共享变量（如需修改，使用原子类如AtomicInteger）。

### 3. 索引获取问题

增强for循环、Iterator、forEach(Lambda)无法直接获取索引，如需索引可通过以下方式：

- 普通for循环（手动维护索引）；

- ListIterator的`nextIndex()`方法；

- Stream API的`IntStream.range(0, list.size()).forEach(i -> ...)`。