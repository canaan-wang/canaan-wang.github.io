## 访问修饰符

|修饰符|当前类|同包|子类|其他包|
|---|---|---|---|---|
|public|√|√|√|√|
|protected|√|√|√|×|
|default|√|√|×|×|
|private|√|×|×|×|

## static
作用：用于修饰类成员，表示全局唯一。

使用方法：
- 饰成员变量、方法、初始化块、内部类。
- 不可以修饰构造器。
- 静态成员只可以访问静态成员。

加载：在类加载的准备阶段进行初始化。

## final
作用：表示“最终”

使用方法：
- 修饰类：表示该类不可被继承
- 修饰方法：表示该方法不可被重写
- 修饰变量：表示变量只能赋值一次，以后不能被修改（常量）(可以修饰成员变量、局部变量、形参)。
  - 成员变量：需要在定义时设定初始值，也可以在初始化模块 or 构造函数中设定初始值，不然会有语法问题
  - 局部变量：定义时已经指定默认值

## synchronized
作用：用于并发场景下定义临界区

实现方式：
- 通过 “CAS + Monitor 对象信息（对象头中的 Mark Word）” 实现。
- 隐式锁，无需显式获取、释放锁，依赖 Monitor（同步监视器）实现线程通信
- Monitor 使用 Object 中的 wait、notify、notifyAll 实现线程同步
    - 调用 wait 会释放锁并等待
    - notify 会唤醒等待的一个线程
    - notifyAll 唤醒等待的所有线程

使用方法：
- 加在普通方法上,则 Monitor 是当前的实例（this）
- 加在静态方法上,则 Monitor 是当前类的 Class 对象。
- 加在代码块上,则需要在关键字后面的小括号里,显式指定一个对象作为 Monitor。

## volatile
作用：用于并发场景下修饰共享资源

实现方式：
- 底层采用内存屏障实现，在编译时期在指令序列中插入内存屏障禁止特定类型的指令重排序（Javac 编译优化）。
- volatile 通过影响内存可见性实现变量的 可见行、原子性。
- 读内存语义：读一个 volatile 变量时，线程本地内存会置为无效，强制从主内存中读取。
- 写内存语义：会把线程本地内存变量的值刷到主内存。

特性：
- 可见行：读 volatile 变量，总是读到最新值。
- 原子性：单个 volatile 的读写是原子的。但是使用 volatile++  volatile-- 这种复合操作不具有原子性。

优势：
- 执行成本比 synchronized 低，不会引起线程上下文的切换和调度

## transient
作用：类中属性不进行序列化