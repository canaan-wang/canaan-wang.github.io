# Java 修饰符

## 定义与作用
修饰符是 Java 中用于控制类、变量、方法等访问权限和行为的特殊关键字。通过合理使用修饰符，可以实现封装、控制访问权限、保证线程安全等功能。

## 访问修饰符

### 概述
访问修饰符用于控制类、变量、方法的可见性范围。

### 分类与特性

| 修饰符 | 作用范围 | 可见性 | 使用场景 |
|--------|----------|--------|----------|
| public | 所有类 | 全局可见 | 公共API、工具类方法 |
| protected | 同一包内或不同包的子类 | 包内及子类可见 | 需要被子类重写的方法 |
| default（默认） | 同一包内 | 包内可见 | 包内工具类、内部实现 |
| private | 仅本类 | 类内可见 | 内部实现、封装细节 |

### 访问范围对比
```java
package com.example;

public class AccessModifierDemo {
    public String publicField = "public";
    protected String protectedField = "protected";
    String defaultField = "default";
    private String privateField = "private";
    
    public void showAccess() {
        // 本类内部：所有修饰符都可见
        System.out.println(publicField);
        System.out.println(protectedField);
        System.out.println(defaultField);
        System.out.println(privateField);
    }
}

class SamePackageClass {
    public void testAccess() {
        AccessModifierDemo demo = new AccessModifierDemo();
        System.out.println(demo.publicField);     // ✅ 可见
        System.out.println(demo.protectedField); // ✅ 可见
        System.out.println(demo.defaultField);   // ✅ 可见
        // System.out.println(demo.privateField); // ❌ 不可见
    }
}
```

## 非访问修饰符

### static 修饰符

#### 定义与作用
static 关键字用于创建类级别的成员，这些成员属于类本身而非类的实例。

#### 静态变量（类变量）
- **特性**：所有对象共享同一份数据
- **生命周期**：类加载时创建，程序结束时销毁
- **访问方式**：类名.变量名 或 对象.变量名

```java
public class Counter {
    // 静态变量：所有对象共享
    private static int count = 0;
    
    // 实例变量：每个对象独立
    private int instanceCount = 0;
    
    public Counter() {
        count++;
        instanceCount++;
    }
    
    public static int getTotalCount() {
        return count;
    }
    
    public int getInstanceCount() {
        return instanceCount;
    }
}

// 使用示例
Counter c1 = new Counter();
Counter c2 = new Counter();
System.out.println(Counter.getTotalCount());    // 输出：2
System.out.println(c1.getInstanceCount());      // 输出：1
System.out.println(c2.getInstanceCount());      // 输出：1
```

#### 静态方法
- **特性**：属于类而非对象，不能访问非静态成员
- **调用方式**：类名.方法名()
- **使用场景**：工具方法、工厂方法

```java
public class MathUtils {
    // 静态方法：工具方法
    public static int max(int a, int b) {
        return a > b ? a : b;
    }
    
    // 静态工厂方法
    public static Date createDate(int year, int month, int day) {
        Calendar calendar = Calendar.getInstance();
        calendar.set(year, month - 1, day);
        return calendar.getTime();
    }
}

// 直接通过类名调用
int maxValue = MathUtils.max(10, 20);
Date date = MathUtils.createDate(2024, 1, 15);
```

#### 静态代码块
- **执行时机**：类加载时执行，仅执行一次
- **使用场景**：初始化静态变量、加载资源

```java
public class DatabaseConfig {
    private static Properties config;
    
    // 静态代码块：类加载时执行
    static {
        config = new Properties();
        try {
            config.load(DatabaseConfig.class.getResourceAsStream("/db.properties"));
            System.out.println("数据库配置加载完成");
        } catch (IOException e) {
            System.err.println("配置文件加载失败");
        }
    }
    
    public static String getConfig(String key) {
        return config.getProperty(key);
    }
}
```

### final 修饰符

#### 定义与作用
final 关键字用于表示"不可改变"的含义。

#### final 变量
- **特性**：常量，一旦赋值不可修改
- **命名规范**：全大写，单词间用下划线分隔
- **初始化时机**：必须在声明时或构造器中初始化

```java
public class Constants {
    // 编译时常量
    public static final int MAX_SIZE = 100;
    public static final String APP_NAME = "MyApp";
    
    // 运行时常量
    public final long createdAt;
    
    public Constants() {
        this.createdAt = System.currentTimeMillis();
    }
    
    public void testFinal() {
        final int localFinal = 10;
        // localFinal = 20; // ❌ 编译错误：不能修改final变量
    }
}
```

#### final 方法
- **特性**：不能被子类重写
- **使用场景**：防止关键方法被修改、提高性能（早期内联优化）

```java
class Parent {
    // final方法：不能被子类重写
    public final void criticalOperation() {
        System.out.println("关键操作");
    }
    
    // 普通方法：可以被子类重写
    public void normalOperation() {
        System.out.println("普通操作");
    }
}

class Child extends Parent {
    // @Override
    // public void criticalOperation() { } // ❌ 编译错误：不能重写final方法
    
    @Override
    public void normalOperation() {
        System.out.println("子类重写的普通操作");
    }
}
```

#### final 类
- **特性**：不能被继承
- **使用场景**：工具类、安全类（如String、Math）

```java
// final类：不能被继承
public final class UtilityClass {
    private UtilityClass() {
        // 私有构造器，防止实例化
    }
    
    public static void utilityMethod() {
        System.out.println("工具方法");
    }
}

// class SubClass extends UtilityClass { } // ❌ 编译错误：不能继承final类
```

### synchronized 修饰符

#### 定义与作用
synchronized 关键字用于实现线程同步，保证多线程环境下的数据安全。

#### 同步方法
- **特性**：同一时间只能有一个线程访问该方法
- **锁对象**：实例方法锁this，静态方法锁类对象

```java
public class Counter {
    private int count = 0;
    
    // 同步实例方法：锁this对象
    public synchronized void increment() {
        count++;
    }
    
    // 同步静态方法：锁类对象
    public static synchronized void staticIncrement() {
        // 静态同步代码
    }
    
    public int getCount() {
        return count;
    }
}
```

#### 同步代码块
- **特性**：更细粒度的同步控制
- **优势**：减少锁的范围，提高性能

```java
public class FineGrainedSync {
    private final Object lock1 = new Object();
    private final Object lock2 = new Object();
    private int value1 = 0;
    private int value2 = 0;
    
    public void incrementValue1() {
        synchronized (lock1) {
            value1++;
        }
    }
    
    public void incrementValue2() {
        synchronized (lock2) {
            value2++;
        }
    }
    
    // 两个操作可以并行执行，提高性能
    public void parallelIncrement() {
        Thread t1 = new Thread(this::incrementValue1);
        Thread t2 = new Thread(this::incrementValue2);
        t1.start();
        t2.start();
    }
}
```

### volatile 修饰符

#### 定义与作用
volatile 关键字用于保证变量的可见性和禁止指令重排序。

#### 可见性保证
- **问题**：多线程环境下，线程可能读取到过期的变量值
- **解决**：volatile 保证变量的修改对所有线程立即可见

```java
public class VolatileExample {
    private volatile boolean running = true;
    
    public void stop() {
        running = false;
    }
    
    public void work() {
        while (running) {
            // 工作逻辑
        }
        System.out.println("工作线程停止");
    }
}

// 主线程修改running后，工作线程能立即看到变化
```

#### 禁止指令重排序
- **问题**：JVM 可能对指令进行重排序优化
- **解决**：volatile 建立内存屏障，防止重排序

```java
public class Singleton {
    private static volatile Singleton instance;
    
    private Singleton() {}
    
    public static Singleton getInstance() {
        if (instance == null) {
            synchronized (Singleton.class) {
                if (instance == null) {
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}
```

### transient 修饰符

#### 定义与作用
transient 关键字用于标记不需要序列化的变量。

#### 使用场景
- 敏感信息（如密码）
- 临时计算的结果
- 依赖运行时环境的资源

```java
import java.io.Serializable;

public class User implements Serializable {
    private String username;
    private transient String password;  // 不序列化密码
    private transient Date loginTime;    // 不序列化登录时间
    
    public User(String username, String password) {
        this.username = username;
        this.password = password;
        this.loginTime = new Date();
    }
    
    // 序列化时password和loginTime不会被保存
    // 反序列化时这些字段为null或默认值
}
```

## 其他修饰符

### abstract 修饰符
- **作用**：定义抽象类或抽象方法
- **特性**：抽象类不能实例化，抽象方法必须被子类实现

### native 修饰符
- **作用**：表示方法由本地代码（如C/C++）实现
- **使用场景**：Java Native Interface (JNI)

### strictfp 修饰符
- **作用**：确保浮点数运算在不同平台上结果一致
- **使用场景**：需要跨平台一致性的金融计算

## 修饰符组合使用

### 常见组合
- `public static final`：公共常量
- `private static`：类内共享的静态变量
- `protected abstract`：需要被子类实现的抽象方法
- `public synchronized`：公共的同步方法

### 组合示例
```java
public class Example {
    // 公共常量
    public static final int MAX_CONNECTIONS = 100;
    
    // 私有静态变量
    private static int instanceCount = 0;
    
    // 受保护的抽象方法
    protected abstract void doWork();
    
    // 公共同步方法
    public synchronized void criticalSection() {
        // 临界区代码
    }
}
```

## 最佳实践

### 访问控制原则
1. **最小权限原则**：使用最严格的访问修饰符
2. **封装性原则**：成员变量尽量使用private，通过方法访问
3. **接口隔离原则**：公共接口要稳定，内部实现可以变化

### 性能考虑
1. **合理使用static**：避免不必要的静态变量
2. **同步粒度控制**：尽量使用同步代码块而非同步方法
3. **volatile使用场景**：只在真正需要可见性保证时使用

### 代码可读性
1. **命名规范**：final常量使用全大写
2. **注释说明**：复杂的同步逻辑要添加注释
3. **一致性**：同类功能的修饰符使用要保持一致

## 总结
Java 修饰符是控制程序行为的重要工具，合理使用修饰符可以提高代码的安全性、可维护性和性能。理解各种修饰符的作用和使用场景，是编写高质量 Java 代码的基础。

最后更新时间：2024-01-15