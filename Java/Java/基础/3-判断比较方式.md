# 判断比较方式

## 一、基本数据类型的判断比较 == 运算符

基本数据类型（byte、short、int、long、float、double、char、boolean）是Java中的"值类型"，直接存储数据本身，其比较核心是**值的相等性**，仅需使用 `==` 运算符。

### 1.1 常见基本类型比较示例

```java

public class BasicTypeComparison {
    public static void main(String[] args) {
        // 整数类型比较
        int a = 10;
        int b = 10;
        int c = 20;
        System.out.println(a == b); // true（值相等）
        System.out.println(a == c); // false（值不相等）
        
        // 浮点类型比较（注意：浮点数有精度问题，不建议直接用==）
        float f1 = 0.1f;
        float f2 = 0.1f;
        System.out.println(f1 == f2); // true（此处值相同，但非绝对可靠）
        
        // 字符类型比较（本质是比较ASCII码值）
        char ch1 = 'A';
        char ch2 = 'A';
        char ch3 = 'B';
        System.out.println(ch1 == ch2); // true（ASCII码均为65）
        System.out.println(ch1 == ch3); // false（65 != 66）
        
        // 布尔类型比较（仅比较true/false）
        boolean flag1 = true;
        boolean flag2 = false;
        System.out.println(flag1 == flag1); // true
        System.out.println(flag1 == flag2); // false
    }
}
```

### 1.2 浮点类型比较的关键注意事项


        浮点类型（float、double）由于二进制存储特性，存在精度损失，**绝对不能直接用==判断相等**！  
        例如：0.1 + 0.2 不等于 0.3，直接比较会返回false。推荐使用 `BigDecimal` 工具类处理，尤其适用于高精度场景。
    

更精准的方案是使用 Java 提供的 `java.math.BigDecimal` 工具类，它专为高精度小数运算设计，能从根本上避免二进制存储导致的精度损失，使用时需注意通过字符串构造方法初始化，避免直接传入浮点数带入误差：

```Plain Text

public class FloatComparison {
    public static void main(String[] args) {
        // 错误方式：直接用double比较
        double d1 = 0.1 + 0.2;
        double d2 = 0.3;
        System.out.println(d1 == d2); // false（精度损失导致不相等）

        // 正确方式：使用BigDecimal工具类比较
        // 关键：通过String构造方法初始化，避免double转BigDecimal时的精度误差
        BigDecimal bd1 = new BigDecimal("0.1").add(new BigDecimal("0.2"));
        BigDecimal bd2 = new BigDecimal("0.3");
        
        // 核心方法compareTo：返回-1（小于）、0（等于）、1（大于）
        int compareResult = bd1.compareTo(bd2);
        boolean isEqual = compareResult == 0;
        System.out.println("BigDecimal比较结果：" + isEqual); // true
    }
}
```

## 二、引用数据类型的判断比较

引用数据类型（类、接口、数组、枚举等）存储的是**对象在堆内存中的地址**，因此比较分为两种场景：**地址比较**和**内容比较**，二者核心区别是比较的目标不同。

### 2.1 地址比较  == 运算符

引用类型使用 `==` 时，比较的是两个引用变量是否**指向同一个对象**（即地址是否相同），与对象内容无关。

```java

public class ReferenceAddressComparison {
    public static void main(String[] args) {
        // 字符串示例（注意：字符串常量池影响，下文会详细说明）
        String s1 = "abc";
        String s2 = "abc";
        String s3 = new String("abc");
        System.out.println(s1 == s2); // true（s1和s2指向常量池同一对象）
        System.out.println(s1 == s3); // false（s3指向堆中新建的对象，地址不同）
        
        // 自定义对象示例
        User u1 = new User("张三", 20);
        User u2 = u1; // u2指向u1的对象
        User u3 = new User("张三", 20);
        System.out.println(u1 == u2); // true（同一对象，地址相同）
        System.out.println(u1 == u3); // false（不同对象，地址不同，即使内容相同）
    }
}

class User {
    private String name;
    private int age;
    public User(String name, int age) {
        this.name = name;
        this.age = age;
    }
}
```

### 2.2 内容比较  equals() 方法

若需比较引用对象的**内容是否相同**，需使用 `equals()` 方法。该方法是 `Object` 类的核心方法，默认实现与==一致（比较地址），因此自定义类需**重写equals()方法**才能实现内容比较。

#### 2.2.1 Object类默认的equals()实现

```java

public class Object {
    public boolean equals(Object obj) {
        return (this == obj); // 本质是地址比较
    }
}
```

#### 2.2.2 常见内置类的equals()（已重写，支持内容比较）

Java核心类（如String、Integer、List等）已重写equals()，直接支持内容比较：

```java

public class BuiltInEqualsComparison {
    public static void main(String[] args) {
        // String类：重写后比较字符序列
        String s1 = "abc";
        String s3 = new String("abc");
        System.out.println(s1.equals(s3)); // true（内容相同）
        
        // Integer类：重写后比较包装的数值
        Integer i1 = new Integer(100);
        Integer i2 = new Integer(100);
        System.out.println(i1.equals(i2)); // true（数值相同）
        
        // List集合：重写后比较元素的个数和每个元素的内容
        List<String> list1 = Arrays.asList("a", "b");
        List<String> list2 = Arrays.asList("a", "b");
        List<String> list3 = Arrays.asList("a", "c");
        System.out.println(list1.equals(list2)); // true（元素内容一致）
        System.out.println(list1.equals(list3)); // false（元素内容不同）
    }
}
```

#### 2.2.3 自定义类重写equals()的规范

重写equals()需遵循**等价性原则**：自反性、对称性、传递性、一致性，同时建议结合hashCode()一起重写（否则会影响HashMap等集合的使用）。

重写步骤：1. 判空；2. 判地址（同一对象直接返回true）；3. 判类型（不同类型返回false）；4. 强转后比较核心属性。

```java

import java.util.Objects;

class User {
    private String name;
    private int age;
    private String idCard; // 唯一标识，核心属性
    
    public User(String name, int age, String idCard) {
        this.name = name;
        this.age = age;
        this.idCard = idCard;
    }
    
    // 手动重写equals()（结合IDEA自动生成规范）
    @Override
    public boolean equals(Object o) {
        // 1. 同一对象：直接返回true
        if (this == o) return true;
        // 2. 空对象或类型不同：返回false
        if (o == null || getClass() != o.getClass()) return false;
        // 3. 强转后比较核心属性（此处以idCard为唯一标识，也可组合多个属性）
        User user = (User) o;
        return Objects.equals(idCard, user.idCard);
    }
    
    // 必须重写hashCode()，与equals()保持一致（核心属性相同则hashCode相同）
    @Override
    public int hashCode() {
        return Objects.hash(idCard);
    }
}

// 测试自定义equals()
public class CustomEqualsTest {
    public static void main(String[] args) {
        User u1 = new User("张三", 20, "110101199001011234");
        User u2 = new User("张三", 21, "110101199001011234"); // 年龄不同，身份证相同
        User u3 = new User("李四", 20, "110101199001015678");
        
        System.out.println(u1.equals(u2)); // true（核心属性idCard相同）
        System.out.println(u1.equals(u3)); // false（idCard不同）
    }
}
```

## 三、字符串比较的特殊点：常量池与intern()

### 3.1 字符串的两种创建方式差异

1. **字面量创建**：`String s = "abc"`，优先从字符串常量池获取对象，若不存在则创建后存入常量池；

2. **new关键字创建**：`String s = new String("abc")`，直接在堆中新建对象，若常量池无"abc"则同时在常量池创建一份。

```java

public class StringComparison {
    public static void main(String[] args) {
        String s1 = "abc"; // 常量池对象
        String s2 = "abc"; // 复用常量池对象
        String s3 = new String("abc"); // 堆对象（地址与常量池不同）
        String s4 = new String("abc"); // 新的堆对象
        
        // 地址比较
        System.out.println(s1 == s2); // true（同一常量池对象）
        System.out.println(s1 == s3); // false（堆 vs 常量池）
        System.out.println(s3 == s4); // false（不同堆对象）
        
        // 内容比较
        System.out.println(s1.equals(s3)); // true（内容相同）
        System.out.println(s3.equals(s4)); // true（内容相同）
        
        // intern()：将堆对象的引用存入常量池（若不存在），返回常量池引用
        String s5 = s3.intern();
        System.out.println(s1 == s5); // true（s5指向常量池的s1）
    }
}
```

### 3.2 字符串比较结论


        字符串比较**永远用equals()判断内容**，除非明确需要判断是否为同一对象（如单例模式），才用==。
    

## 四、包装类的比较：缓存机制与equals()

Java为8种基本类型提供了包装类（如Integer、Long），其比较需注意**缓存机制**对==的影响。

### 4.1 包装类的缓存机制

对于Integer、Short等包装类，Java默认缓存了-128~127范围内的对象，使用字面量创建时会复用缓存对象，超出范围则新建对象。

```java

public class WrapperClassComparison {
    public static void main(String[] args) {
        // 1. 缓存范围内（-128~127）：字面量创建复用缓存，==返回true
        Integer i1 = 100;
        Integer i2 = 100;
        System.out.println(i1 == i2); // true（复用缓存对象）
        System.out.println(i1.equals(i2)); // true（内容相同）
        
        // 2. 超出缓存范围：字面量创建新建对象，==返回false
        Integer i3 = 200;
        Integer i4 = 200;
        System.out.println(i3 == i4); // false（不同对象，地址不同）
        System.out.println(i3.equals(i4)); // true（内容相同）
        
        // 3. new关键字创建：无论是否在缓存范围，均新建对象
        Integer i5 = new Integer(100);
        System.out.println(i1 == i5); // false（缓存对象 vs 新对象）
    }
}
```

### 4.2 包装类比较结论

包装类比较**优先用equals()**，避免依赖缓存机制导致的==判断错误；若需比较数值，也可调用`intValue()`等方法转为基本类型后用==。

## 五、自定义对象的进阶比较：Comparable与Comparator

equals()仅能判断"是否相等"，若需对对象进行**排序（即比较大小）**，需使用`Comparable`接口（自然排序）或`Comparator`接口（定制排序）。

### 5.1 Comparable接口：自然排序

自定义类实现Comparable接口，重写`compareTo(T o)`方法，定义"自然排序规则"（如按年龄升序）。返回值：正数（当前对象大）、负数（当前对象小）、0（相等）。

```java

import java.util.Arrays;

// 实现Comparable接口，指定排序类型为User
class User implements Comparable<User> {
    private String name;
    private int age;
    
    public User(String name, int age) {
        this.name = name;
        this.age = age;
    }
    
    // 重写compareTo：按年龄升序排序（自然排序规则）
    @Override
    public int compareTo(User o) {
        return this.age - o.age; // 升序：当前年龄 - 目标年龄；降序则反之
    }
    
    @Override
    public String toString() {
        return "User{name='" + name + "', age=" + age + "}";
    }
}

// 测试自然排序
public class ComparableTest {
    public static void main(String[] args) {
        User[] users = {
            new User("张三", 25),
            new User("李四", 20),
            new User("王五", 30)
        };
        // 调用Arrays.sort()，会自动使用compareTo()进行排序
        Arrays.sort(users);
        System.out.println(Arrays.toString(users));
        // 输出：[User{name='李四', age=20}, User{name='张三', age=25}, User{name='王五', age=30}]
    }
}
```

### 5.2 Comparator接口：定制排序

若无法修改自定义类的代码（如第三方类），或需要临时改变排序规则（如按姓名长度排序），可使用Comparator接口，通过匿名内部类或Lambda表达式实现。

```java

import java.util.Arrays;
import java.util.Comparator;

// 无需修改User类（不实现Comparable）
class User {
    private String name;
    private int age;
    
    public User(String name, int age) {
        this.name = name;
        this.age = age;
    }
    
    // getter方法（用于Comparator中获取属性）
    public String getName() { return name; }
    public int getAge() { return age; }
    
    @Override
    public String toString() {
        return "User{name='" + name + "', age=" + age + "}";
    }
}

// 测试定制排序
public class ComparatorTest {
    public static void main(String[] args) {
        User[] users = {
            new User("张三", 25),
            new User("李四", 20),
            new User("王五", 30)
        };
        
        // 1. 按姓名长度升序排序（Lambda表达式简化Comparator）
        Arrays.sort(users, (u1, u2) -> u1.getName().length() - u2.getName().length());
        System.out.println("按姓名长度排序：" + Arrays.toString(users));
        
        // 2. 按年龄降序排序（使用Comparator静态方法）
        Arrays.sort(users, Comparator.comparingInt(User::getAge).reversed());
        System.out.println("按年龄降序排序：" + Arrays.toString(users));
    }
}
```

### 5.3 两者区别

|维度|Comparable|Comparator|
|---|---|---|
|实现位置|自定义类内部实现|类外部单独实现|
|排序规则|固定自然排序|灵活定制，可多个规则|
|核心方法|compareTo(T o)|compare(T o1, T o2)|
## 六、流程控制中的条件判断：if-else 与 switch

除了上述值和对象的“相等性”或“大小”比较外，Java 中的判断还体现在流程控制语句中，用于根据不同条件执行不同的代码块。核心的条件判断语句包括 `if-else`（灵活的条件判断）和 `switch`（多分支匹配判断）。

### 6.1 if-else 语句：灵活的条件判断

`if-else` 语句是最基础且灵活的条件判断结构，它根据 **布尔表达式（true/false）** 的结果来决定执行哪一段代码。可以单独使用 `if`，也可以结合 `else if` 实现多条件分支，最后用 `else` 处理剩余情况。

#### 6.1.1 三种常见结构

1. **单 if 结构**：满足条件则执行，不满足则跳过。

2. **if-else 结构**：二选一，满足条件执行 if 块，否则执行 else 块。

3. **if-else if-else 结构**：多选一，依次判断条件，满足第一个匹配的条件后执行对应块，后续不再判断。

```java

public class IfElseDemo {
    public static void main(String[] args) {
        int score = 85;
        
        // 1. 单 if 结构：检查是否及格
        if (score >= 60) {
            System.out.println("成绩及格"); // 输出：成绩及格
        }
        
        // 2. if-else 结构：判断是否优秀
        if (score >= 90) {
            System.out.println("优秀");
        } else {
            System.out.println("非优秀"); // 输出：非优秀
        }
        
        // 3. if-else if-else 结构：成绩评级
        if (score >= 90) {
            System.out.println("等级：A");
        } else if (score >= 80) {
            System.out.println("等级：B"); // 输出：等级：B
        } else if (score >= 60) {
            System.out.println("等级：C");
        } else {
            System.out.println("等级：D（不及格）");
        }
    }
}
```

#### 6.1.2 核心注意事项

- **布尔表达式必须是 boolean 类型**：Java 不允许像 C/C++ 那样将整数隐式转为布尔值。例如 `if (score)` 是错误的，必须写成 `if (score > 0)`。

- **代码块的大括号**：如果代码块只有一行语句，大括号 `{}` 可以省略，但为了代码可读性和避免 bug（如后续误加语句），**强烈建议始终加上大括号**。

- **else 的匹配规则**：`else` 总是与**最近的、未匹配的**`if` 配对。

### 6.2 switch 语句：多分支匹配

`switch` 语句用于处理**多个固定值的匹配场景**，通过比较一个表达式的值与多个 `case` 标签的值，执行匹配的分支。Java 7 及以上支持 `String` 类型作为 switch 表达式，Java 14 及以上支持 `switch 表达式`（可直接返回值）。

#### 6.2.1 传统 switch 语句（语句形式）

```java

public class SwitchDemo {
    public static void main(String[] args) {
        String dayOfWeek = "MONDAY";
        
        switch (dayOfWeek) {
            case "MONDAY":
            case "TUESDAY":
            case "WEDNESDAY":
            case "THURSDAY":
            case "FRIDAY":
                System.out.println("工作日"); // 输出：工作日
                break; // 跳出 switch，不执行后续 case
            case "SATURDAY":
            case "SUNDAY":
                System.out.println("休息日");
                break;
            default: // 所有 case 都不匹配时执行
                System.out.println("无效的星期");
        }
    }
}
```

#### 6.2.2 现代 switch 表达式（Java 14+，推荐）

使用箭头 `->` 替代 `case` 和 `break`，代码更简洁，且可以直接返回值（使用 `yield` 关键字）。

```java

public class SwitchExpressionDemo {
    public static void main(String[] args) {
        int month = 3;
        
        // 1. 简化的 switch 语句
        switch (month) {
            case 1, 2, 12 -> System.out.println("冬季");
            case 3, 4, 5 -> System.out.println("春季"); // 输出：春季
            case 6, 7, 8 -> System.out.println("夏季");
            case 9, 10, 11 -> System.out.println("秋季");
            default -> System.out.println("无效月份");
        }
        
        // 2. switch 表达式（返回值）
        String season = switch (month) {
            case 1, 2, 12 -> "冬季";
            case 3, 4, 5 -> "春季";
            case 6, 7, 8 -> "夏季";
            case 9, 10, 11 -> "秋季";
            default -> {
                System.out.println("输入有误，默认返回冬季");
                yield "冬季"; // 用于返回值
            }
        };
        System.out.println("当前季节：" + season); // 输出：当前季节：春季
    }
}
```

#### 6.2.3 核心注意事项

- **case 标签的值必须唯一且为常量**：不能是变量或表达式。例如 `case a + 1:` 是错误的（除非 a 是常量）。

- **break 关键字的作用**：传统 switch 中，如果没有 `break`，会发生“穿透”现象，即匹配成功后会继续执行后续所有 case 的代码，直到遇到 break 或 switch 结束。现代 switch 表达式（箭头语法）默认不穿透。

- **default 分支**：可选，但建议加上，用于处理意外的输入，增强代码健壮性。default 不一定要放在最后。

- **支持的类型**：byte、short、int、char、枚举（enum）、String（Java 7+），以及对应的包装类（会自动拆箱）。

### 6.3 if-else vs switch：如何选择？

|判断场景|推荐使用 if-else|推荐使用 switch|
|---|---|---|
|条件类型|复杂条件（范围比较、逻辑组合，如 score > 80 && age < 20）|固定值匹配（如具体的数字、字符串、枚举值）|
|分支数量|分支数量较少或不确定|分支数量较多且固定|
|代码可读性|复杂条件下更清晰|固定值匹配时更简洁，避免冗长的 else if 链|
## 七、总结：Java判断比较方式全景指南

- **基本类型值比较**：直接用==；浮点类型推荐使用 `BigDecimal` 工具类比较，避免精度损失；

- **引用类型比较**：equals()判断内容，==判断地址（仅在确认同一对象时使用）；

- **字符串比较**：强制用equals()判断内容，警惕==的常量池陷阱；

- **包装类比较**：优先用equals()，或转基本类型用==，注意缓存机制；

- **对象排序比较**：需排序时用Comparable（固定自然排序）或Comparator（灵活定制排序）；

- **流程条件判断**：复杂条件或范围判断用if-else，多固定值匹配用switch（现代箭头语法更推荐）。
> （注：文档部分内容可能由 AI 生成）