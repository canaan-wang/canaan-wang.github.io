# 反射

本文为 Java 反射机制的系统性笔记，涵盖核心概念、核心类、关键操作、应用场景、优缺点及注意事项，适用于知识点回顾与快速查询。

# 一、反射的核心概念

## 1.1 定义

Java 反射（Reflection）是 Java 语言的核心特性之一，属于 java.lang.reflect 包的核心能力。它允许程序在**运行时**获取类的完整结构信息（如类名、父类、接口、字段、方法、构造器等），并能动态操作类的实例（如创建对象、调用方法、修改字段值），即使在编译期未知该类的具体信息。

## 1.2 核心思想

打破 Java 的“编译期类型固定”限制，实现“运行时动态探知”和“动态操作”，是 Java 实现“准动态语言”特性的关键。

## 1.3 反射的前提

获取目标类的 `Class` 对象——这是反射操作的“入口”，所有反射操作都围绕 `Class` 对象展开。

# 二、反射的核心类（java.lang.reflect 包）

Java 提供了一套专门的 API 支持反射，核心类及作用如下表：

|核心类|主要作用|
|---|---|
|Class|反射的入口，代表一个类的“元数据”，封装了类的结构信息|
|Constructor|代表类的构造器，用于创建对象（支持调用无参/有参构造）|
|Method|代表类的方法，用于调用对象的方法（支持带参数调用）|
|Field|代表类的字段（成员变量），用于获取/修改字段值|
|Modifier|工具类，用于解析类/字段/方法的访问修饰符（如 public、private、static 等）|
|Parameter|代表方法的参数，用于获取参数信息（如参数类型、参数名）|
# 三、反射的核心操作步骤

所有反射操作的第一步都是“获取 Class 对象”，后续操作基于 Class 对象展开。

## 3.1 步骤1：获取 Class 对象的 3 种核心方式

三种方式的适用场景不同，需根据编译期是否已知类信息选择：

1. **类名.class 方式**适用场景：编译期已知目标类（直接能写类名）。
优点：简洁高效，无异常风险。
示例：`Class<User> userClass = User.class;`

2. **对象.getClass() 方式**适用场景：已有类的实例对象（编译期已知实例类型）。
示例：`User user = new User(); Class<? extends User> userClass = user.getClass();`

3. **Class.forName(全类名) 方式**适用场景：编译期未知目标类，仅知道类的“全类名”（包名+类名），是反射灵活性的核心体现。
注意：需抛出 `ClassNotFoundException` 异常。
示例：`Class<?> userClass = Class.forName("com.example.pojo.User");`


      补充：基本类型的 Class 对象获取方式为“类型.class”（如 int.class），其包装类可通过“TYPE”字段获取（如 Integer.TYPE 等价于 int.class）。
    

## 3.2 步骤2：基于 Class 对象的核心操作

以下操作均以“User 类”为例，假设 User 类结构：

```java

package com.example.pojo;

public class User {
    // 字段
    private Integer id;
    public String name;
    protected Integer age;
    
    // 构造器
    public User() {}
    private User(Integer id, String name) {
        this.id = id;
        this.name = name;
    }
    
    // 方法
    public String getName() { return name; }
    private void setId(Integer id) { this.id = id; }
    public static void showInfo() { System.out.println("This is User class"); }
}

```

### 3.2.1 操作1：获取类的基本信息

通过 Class 对象获取类的元数据，常用方法：

```java

Class<?> userClass = Class.forName("com.example.pojo.User");

// 1. 获取类名相关
String className = userClass.getName(); // 全类名：com.example.pojo.User
String simpleName = userClass.getSimpleName(); // 简单类名：User

// 2. 获取父类
Class<? super ?> superClass = userClass.getSuperclass(); // 若未显式继承，返回 Object.class

// 3. 获取实现的接口
Class<?>[] interfaces = userClass.getInterfaces(); // 返回接口数组（无则为空数组）

// 4. 获取访问修饰符
int modifiers = userClass.getModifiers(); // 返回修饰符对应的int值，需用Modifier解析
boolean isPublic = Modifier.isPublic(modifiers); // 判断是否为public

```

### 3.2.2 操作2：获取并操作构造器（创建对象）

通过 `Constructor` 类操作构造器，支持调用私有构造器（需设置访问权限）。

```java

Class<?> userClass = Class.forName("com.example.pojo.User");

// 1. 获取构造器（重载方法）
Constructor<?>[] allConstructors = userClass.getDeclaredConstructors(); // 获取所有构造器（包括私有）
Constructor<?> publicConstructor = userClass.getConstructor(); // 获取无参公共构造器（无则抛异常）
Constructor<?> privateConstructor = userClass.getDeclaredConstructor(Integer.class, String.class); // 获取指定参数的私有构造器

// 2. 调用构造器创建对象（关键：setAccessible(true)突破私有访问限制）
// 2.1 调用无参公共构造器
User user1 = (User) publicConstructor.newInstance();

// 2.2 调用私有构造器（必须先设置访问权限）
privateConstructor.setAccessible(true); // 忽略访问修饰符检查（核心！）
User user2 = (User) privateConstructor.newInstance(1, "张三");

```

### 3.2.3 操作3：获取并调用方法

通过 `Method` 类调用方法，支持调用私有方法、静态方法。

```java

Class<?> userClass = Class.forName("com.example.pojo.User");
User user = (User) userClass.getConstructor().newInstance(); // 先创建对象

// 1. 获取方法（重载方法）
Method[] allMethods = userClass.getDeclaredMethods(); // 获取所有方法（包括私有、静态）
Method publicMethod = userClass.getMethod("getName"); // 获取公共无参方法getName
Method privateMethod = userClass.getDeclaredMethod("setId", Integer.class); // 获取私有方法setId
Method staticMethod = userClass.getDeclaredMethod("showInfo"); // 获取静态方法showInfo

// 2. 调用方法（invoke方法：参数1为实例对象，静态方法可传null；参数2为方法参数）
// 2.1 调用公共实例方法
String name = (String) publicMethod.invoke(user); // 无参数，第二个参数传null或不写

// 2.2 调用私有实例方法（需先设置访问权限）
privateMethod.setAccessible(true);
privateMethod.invoke(user, 1001); // 传入实例对象和方法参数

// 2.3 调用静态方法（实例对象参数传null）
staticMethod.invoke(null);

```

### 3.2.4 操作4：获取并修改字段值

通过 `Field` 类操作字段，支持修改私有字段值（需设置访问权限）。

```java

Class<?> userClass = Class.forName("com.example.pojo.User");
User user = (User) userClass.getConstructor().newInstance();

// 1. 获取字段（重载方法）
Field[] allFields = userClass.getDeclaredFields(); // 获取所有字段（包括私有）
Field publicField = userClass.getField("name"); // 获取公共字段name
Field privateField = userClass.getDeclaredField("id"); // 获取私有字段id

// 2. 操作字段值（get获取，set修改）
// 2.1 操作公共字段
publicField.set(user, "李四"); // 给user对象的name字段设值
String userName = (String) publicField.get(user); // 获取user对象的name字段值

// 2.2 操作私有字段（需先设置访问权限）
privateField.setAccessible(true);
privateField.set(user, 1002); // 给私有字段id设值
Integer userId = (Integer) privateField.get(user); // 获取私有字段id值

```

# 四、反射的应用场景

反射的核心价值在于“动态性”，主要应用于框架开发和工具类实现，常见场景：

1. **框架开发（核心场景）**Spring、MyBatis 等框架的核心依赖反射：
- Spring：IOC 容器通过反射创建 Bean（根据配置文件中的全类名动态实例化）；AOP 基于反射增强方法。
- MyBatis：通过反射将数据库查询结果映射为 Java 对象（动态给字段设值）。

2. **工具类实现**如 Apache Commons BeanUtils、FastJSON 等：
- 实现“对象属性拷贝”（通过反射获取字段并赋值）；
- JSON 序列化/反序列化（通过反射解析对象字段并转换为 JSON，或反向解析）。

3. **单元测试框架**如 JUnit：通过反射调用@Test注解标记的方法，实现自动化测试。

4. **动态代理**JDK 动态代理的核心是通过反射调用目标对象的方法（Proxy.newProxyInstance 依赖反射生成代理类）。

5. **插件化/热更新**通过反射加载外部 Jar 包中的类，实现动态扩展功能（如 IDEA 插件、插件化 App）。

# 五、反射的优缺点

## 5.1 优点

- **动态性强**：编译期无需知道类信息，运行时动态操作，极大提升程序灵活性和扩展性。

- **解耦**：框架通过反射依赖“全类名”而非具体类，降低代码耦合度（如 Spring 配置文件替换类无需修改代码）。

- **通用性强**：可编写通用工具类（如对象拷贝、JSON 转换），适配任意 Java 类。

## 5.2 缺点

- **性能损耗**：反射需动态解析类元数据、突破访问权限检查，比直接调用（编译期确定）慢 10~100 倍，高频场景需谨慎。

- **破坏封装性**：通过 `setAccessible(true)` 可访问私有成员，违背“封装”设计原则，增加代码维护风险。

- **编译期类型不安全**：反射调用依赖字符串标识（如方法名、字段名），若拼写错误，编译期无法发现，仅运行时抛异常（如 NoSuchMethodException）。

- **代码可读性差**：反射代码比直接调用更繁琐，逻辑更隐晦，增加团队协作成本。

# 六、反射的注意事项

1. **避免高频场景使用**：如循环调用、接口响应逻辑等，可用“缓存 Class 对象/Method 对象”优化（减少重复解析元数据的开销）。

2. **谨慎使用 setAccessible(true)**：仅在必要场景（如框架开发）使用，避免滥用破坏封装，优先通过公共 API 操作对象。

3. **处理异常**：反射相关方法抛出大量受检异常（如 ClassNotFoundException、NoSuchMethodException），需妥善捕获或抛出，避免运行时崩溃。

4. **权限问题**：若程序运行在安全管理器（SecurityManager）环境下，反射可能被禁止访问某些类/方法，需提前适配。

5. **版本兼容性**：若目标类后续修改了方法名、字段名或构造器，反射代码会因“字符串标识不匹配”抛异常，需做好版本兼容说明。
> （注：文档部分内容可能由 AI 生成）