# CopyOnWriteArrayList

# 一、核心定义

CopyOnWriteArrayList 是 Java 并发包（`java.util.concurrent`）提供的**线程安全 ArrayList 实现**，核心采用“**写时复制（Copy-On-Write）**”机制，专为“读多写少”场景设计，平衡读操作高效性与写操作安全性。

与普通 ArrayList 核心差异：读操作直接访问原容器（无锁）；写操作（增删改）不修改原容器，而是复制副本修改后替换原引用（加锁保证安全）。

# 二、核心原理：写时复制

## 2.1 核心逻辑

底层维护**volatile 修饰的不可变数组**（保证引用可见性），读操作直接访问该数组；写操作遵循“加锁→复制→修改→替换→解锁”五步流程：

1. **加锁**：通过 ReentrantLock 保证同一时间仅一个线程执行写操作；

2. **复制副本**：创建新数组（长度随操作类型调整，如添加则+1），复制原数组元素；

3. **执行写操作**：在新数组上完成增删改；

4. **替换引用**：将原数组引用指向新数组（volatile 保证其他线程可见）；

5. **解锁**：释放锁，允许其他写线程执行。

## 2.2 关键成员变量

- `final transient ReentrantLock lock`：独占锁，控制并发写，避免副本混乱；

- `private transient volatile Object[] array`：存储元素的核心数组，volatile 仅保证引用可见性。数组本身"不可变"并非语法限制，而是通过写时复制机制约定——原数组创建后其元素和长度不再修改，写操作必创建新数组并替换该引用，实现逻辑上的不可变。

# 三、核心方法

## 3.1 读操作：无锁高效

直接访问 array 数组，无锁设计，时间复杂度均为 O(1)：

- **get(int index)**：获取当前数组→校验索引→返回元素，线程安全（访问稳定原数组）；

- **size()**：直接返回当前数组长度（无需维护单独 size 变量）。

## 3.2 写操作：加锁复制

均需遵循“复制前加锁、引用替换后解锁”的规则，复制数组完成写操作，时间复杂度 O(n)（复制成本）：

- **add(E e)**：复制原数组（长度+1）→末尾加元素→替换引用，读操作可并行；

- **remove(int index)**：复制原数组（长度-1）**过程中**跳过待删元素→替换引用，读可能访问旧数据（最终一致）；

- **set(int index, E element)**：复制原数组→**复制完成后**修改新数组对应元素→替换引用，即使单元素修改也需全量复制。

## 3.3 迭代器：弱一致性

迭代器，表现为“快照迭代”：

- 创建时保存当前数组快照，迭代过程仅访问该快照；

- 后续写操作修改的新数组，迭代器无法感知（弱一致性）；

- 不支持迭代中写操作（如 remove/add），否则抛 UnsupportedOperationException。

# 四、适用边界

## 4.1 适用场景

- **读多写少**：如配置缓存、字典表，读高效+写低频可接受；

- **读响应优先**：允许读弱一致、写延迟，如日志查询；

- **简化线程安全**：替代 Collections.synchronizedList，避免读写锁冲突。

## 4.2 不适用场景

- **写频繁**：大数组复制成本极高，性能骤降；

- **内存敏感**：写时双数组共存，可能内存溢出（如百万级元素）；

- **强一致需求**：如金融交易、库存管理，需实时获取最新数据。

# 五、优缺点总结

## 5.1 优点

1. **读性能极致**：无锁设计，读写并发无阻塞；

2. **安全易用**：底层保证线程安全，API 与 ArrayList 一致；

3. **无并发修改异常**：快照迭代避免 ConcurrentModificationException。

## 5.2 缺点

1. **写成本高**：全量复制数组，O(n) 时间+额外内存；

2. **弱一致性**：读可能访问旧数据；

3. **内存压力大**：写时双数组占用内存。

# 六、注意事项

- **元素不可变优先**：存储可变对象需额外同步内部状态，建议用 String、Integer 等；

- **正视弱一致性**：避免依赖迭代器实时性，需最新数据可重新获取迭代器；

- **大数组慎用**：元素过多时写复制成本激增，建议拆分容器；

- **批量写优化**：用 addAll() 替代多次 add()，减少复制次数。

# 七、核心知识点速记


      1. 核心思想：写时复制，读无锁、写加锁；
      2. 底层结构：volatile 数组 + ReentrantLock；
      3. 迭代器特性：弱一致性，基于快照迭代；
      4. 性能特点：读快写慢，内存占用高；
      5. 适用场景：读多写少、弱一致性可接受。