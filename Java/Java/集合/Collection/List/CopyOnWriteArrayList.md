# CopyOnWriteArrayList

## 一、基本概念：是什么？

CopyOnWriteArrayList 是 Java 并发包（java.util.concurrent）提供的一个**线程安全的 ArrayList 变体**，基于“**写时复制（Copy-On-Write）**”的核心思想实现。

与普通 ArrayList 相比，其核心差异在于：当对容器进行写操作（添加、删除、修改）时，不会直接修改原容器，而是先复制一份原容器的副本，在副本上执行写操作，完成后再将原容器的引用指向新副本；而读操作始终访问原容器（或已完成复制的稳定副本），无需加锁。

核心定位：解决“读多写少”场景下的线程安全问题，兼顾读操作的高效性和写操作的安全性。

## 二、核心原理：写时复制（Copy-On-Write）

### 2.1 原理拆解

CopyOnWriteArrayList 的底层维护了一个**不可变的数组（array）**，所有读操作都是直接访问这个数组，因此读操作无需同步，效率极高；当发生写操作时，流程如下：

1. **加锁**：通过 ReentrantLock 加锁，保证同一时间只有一个线程执行写操作，避免并发写导致的副本混乱。

2. **复制副本**：创建一个新的数组，长度为原数组长度+1（或根据写操作类型调整，如删除则长度-1），并将原数组的所有元素复制到新数组中。

3. **执行写操作**：在新数组上执行添加、删除或修改操作。

4. **替换引用**：将原数组的引用指向新数组。

5. **解锁**：释放 ReentrantLock 锁。

### 2.2 关键成员变量

从源码角度看，CopyOnWriteArrayList 的核心成员变量支撑了写时复制逻辑：

- `final transient ReentrantLock lock`：独占锁，控制并发写操作，确保同一时间只有一个线程执行复制和修改。

- `private transient volatile Object[] array`：存储元素的核心数组，用 volatile 修饰，保证线程间的可见性（当数组引用替换后，其他线程能立即看到新数组）。

注意：array 数组本身是不可变的（每次写操作都会替换为新数组），volatile 仅保证数组引用的可见性，而非数组元素的可见性（但因写操作会替换数组，读操作访问的是稳定数组，无需担心元素可见性问题）。

## 三、常用方法解析

CopyOnWriteArrayList 实现了 List 接口，大部分方法与 ArrayList 用法一致，但核心方法的实现因写时复制机制存在差异，重点解析关键方法：

### 3.1 读操作：无锁高效

读操作直接访问 array 数组，无需加锁，效率与普通 ArrayList 一致：

- **get(int index)**：
        源码逻辑：获取当前 array 数组，检查索引合法性，返回对应位置元素。特点：无锁，O(1) 时间复杂度，线程安全（访问的是稳定的原数组）。

- **size()**：
        源码逻辑：返回当前 array 数组的长度。特点：无锁，O(1) 时间复杂度（因数组长度固定，无需像 ArrayList 那样维护单独的 size 变量）。

### 3.2 写操作：加锁复制

所有写操作均需通过锁控制，并执行复制逻辑，时间复杂度为 O(n)（需复制原数组）：

- **add(E e)**：
        源码逻辑：加锁 → 复制原数组到新数组（长度+1）→ 新数组末尾添加元素 → 替换 array 引用 → 解锁。注意：添加操作不会修改原数组，读操作可同时进行，无冲突。

- **remove(int index)**：
        源码逻辑：加锁 → 复制原数组到新数组（长度-1），跳过待删除索引元素 → 替换 array 引用 → 解锁。注意：删除后原数组仍存在（直至被 GC 回收），读操作可能仍访问到已删除元素（最终一致性）。

- **set(int index, E element)**：
        源码逻辑：加锁 → 复制原数组到新数组 → 修改新数组对应索引元素 → 替换 array 引用 → 解锁。注意：即使修改元素，也需复制整个数组，成本较高。

### 3.3 迭代器：弱一致性

CopyOnWriteArrayList 的迭代器（COWIterator）具有**弱一致性**，这是其核心特性之一：

- **创建时机**：迭代器创建时，会保存当前 array 数组的快照（引用）。

- **迭代过程**：迭代时始终访问快照数组，即使后续发生写操作（替换了 array 引用），迭代器也不会感知到新数组的变化。

- **禁止写操作**：迭代器不支持 remove()、add() 等写操作，调用会抛出 UnsupportedOperationException。

示例：迭代器创建后，其他线程添加元素，迭代器不会遍历到新添加的元素，这就是弱一致性的体现（保证最终一致，但不保证实时一致）。

## 四、适用场景与不适用场景

CopyOnWriteArrayList 的设计决定了其有明确的适用边界，需根据业务场景选择：

### 4.1 适用场景

- **读多写少**：这是最核心的适用场景，如配置缓存、字典表等。读操作无需加锁，效率极高；写操作虽成本高，但因频率低，整体性能优异。

- **读操作响应优先**：场景中对读操作的延迟要求严格，允许写操作有一定延迟，且能接受读操作的弱一致性（如日志查询、历史数据展示）。

- **线程安全需求**：需要避免手动加锁实现线程安全，且不希望因读锁和写锁冲突导致性能损耗（如替代 Collections.synchronizedList(ArrayList)）。

### 4.2 不适用场景

- **写操作频繁**：每次写操作都需复制整个数组，当数组元素较多时，复制成本极高（时间+内存），会导致性能急剧下降。

- **内存敏感场景**：写操作时会同时存在原数组和新数组两个副本，内存占用翻倍，对于大数组（如百万级元素），可能导致内存溢出。

- **强一致性需求**：场景要求读操作必须实时获取最新数据（如金融交易、库存管理），弱一致性无法满足需求。

## 五、优缺点总结

### 5.1 优点

1. **读操作高效**：无锁设计，读操作与写操作可并发执行，不会出现读-写冲突导致的阻塞。

2. **线程安全且易用**：底层通过锁和写时复制保证线程安全，无需手动加锁，API 与 ArrayList 一致，学习成本低。

3. **避免并发修改异常**：迭代时访问快照数组，不会因其他线程修改容器而抛出 ConcurrentModificationException（与 ArrayList 不同）。

### 5.2 缺点

1. **写操作成本高**：每次写操作需复制整个数组，时间复杂度 O(n)，且占用额外内存。

2. **弱一致性**：读操作可能访问到旧数据，无法实时获取最新修改结果。

3. **内存占用问题**：写操作时双数组共存，大数组场景下内存压力大。

## 六、与类似容器的对比

|对比维度|CopyOnWriteArrayList|Collections.synchronizedList(ArrayList)|ArrayList（非线程安全）|
|---|---|---|---|
|线程安全|是（写时复制+锁）|是（全方法加锁）|否|
|读操作性能|极高（无锁）|低（加锁阻塞）|高（无锁，但非线程安全）|
|写操作性能|低（复制数组+锁）|中（加锁阻塞）|高（无锁，但非线程安全）|
|一致性|弱一致性|强一致性|无保证|
|适用场景|读多写少|读写均衡|单线程或无并发写|
## 七、注意事项

1. **元素不可变性建议**：若元素为可变对象，即使容器本身线程安全，修改元素内部状态仍需额外同步（因读操作可能同时访问元素），建议存储不可变对象（如 String、Integer）。

2. **迭代器弱一致性**：开发时需明确迭代器不会获取最新数据，避免依赖迭代器的实时性。

3. **大数组慎用**：元素数量过多时，写操作的复制成本和内存占用会急剧增加，建议拆分或选择其他容器。

4. **避免批量写操作**：频繁调用 add() 等单元素写操作，不如一次性调用 addAll()（仅复制一次数组，效率更高）。

## 八、核心知识点速记


      1. 核心思想：写时复制，读无锁、写加锁；
      2. 底层结构：volatile 数组 + ReentrantLock；
      3. 迭代器特性：弱一致性，基于快照迭代；
      4. 性能特点：读快写慢，内存占用高；
      5. 适用场景：读多写少、弱一致性可接受的场景。
    
> （注：文档部分内容可能由 AI 生成）