# Java 泛型系统详解

## 定义与作用

### 什么是泛型
Java 泛型（Generics）是 JDK 5.0 引入的重要特性，它允许在定义类、接口和方法时使用类型参数（Type Parameters）。泛型提供了编译时类型安全检查机制，使得代码更加类型安全、可读性更强。

### 泛型的主要作用
1. **类型安全**：在编译时检查类型错误，避免运行时 ClassCastException
2. **代码复用**：编写可重用的类型安全代码
3. **消除强制类型转换**：减少显式的类型转换代码
4. **提高可读性**：代码意图更加清晰明确

## 泛型基础

### 泛型类
在类定义时使用类型参数：

```java
// 泛型类定义
public class Box<T> {
    private T content;
    
    public void setContent(T content) {
        this.content = content;
    }
    
    public T getContent() {
        return content;
    }
}

// 使用泛型类
Box<String> stringBox = new Box<>();
stringBox.setContent("Hello");
String content = stringBox.getContent(); // 无需类型转换

Box<Integer> intBox = new Box<>();
intBox.setContent(123);
Integer number = intBox.getContent();
```

### 泛型接口
在接口定义时使用类型参数：

```java
// 泛型接口定义
public interface List<T> {
    void add(T element);
    T get(int index);
    int size();
}

// 实现泛型接口
public class ArrayList<T> implements List<T> {
    private Object[] elements = new Object[10];
    private int size = 0;
    
    @Override
    public void add(T element) {
        elements[size++] = element;
    }
    
    @Override
    @SuppressWarnings("unchecked")
    public T get(int index) {
        return (T) elements[index];
    }
    
    @Override
    public int size() {
        return size;
    }
}
```

### 泛型方法
在方法定义时使用类型参数：

```java
// 泛型方法定义
public class Utility {
    // 静态泛型方法
    public static <T> T getFirst(List<T> list) {
        if (list == null || list.isEmpty()) {
            return null;
        }
        return list.get(0);
    }
    
    // 实例泛型方法
    public <E> void printArray(E[] array) {
        for (E element : array) {
            System.out.print(element + " ");
        }
        System.out.println();
    }
}

// 使用泛型方法
List<String> names = Arrays.asList("Alice", "Bob", "Charlie");
String first = Utility.getFirst(names); // 类型推断

Integer[] numbers = {1, 2, 3, 4, 5};
new Utility().printArray(numbers);
```

## 类型擦除

### 什么是类型擦除
Java 泛型是通过类型擦除（Type Erasure）实现的，这意味着泛型类型信息在编译时被擦除，运行时只保留原始类型（Raw Type）。

```java
// 编译前（源代码）
List<String> stringList = new ArrayList<>();
List<Integer> intList = new ArrayList<>();

// 编译后（字节码）
List stringList = new ArrayList();
List intList = new ArrayList();
```

### 类型擦除的影响
1. **运行时类型信息丢失**：无法在运行时获取泛型的具体类型参数
2. **instanceof 操作受限**：不能使用 `if (obj instanceof List<String>)`
3. **数组创建限制**：不能创建泛型数组 `new T[10]`
4. **重载限制**：不能仅通过类型参数不同来重载方法

### 绕过类型擦除的方法
```java
// 通过传递 Class 对象保留类型信息
public class TypeSafeContainer<T> {
    private final Class<T> type;
    private T value;
    
    public TypeSafeContainer(Class<T> type) {
        this.type = type;
    }
    
    public void setValue(T value) {
        if (value != null && !type.isInstance(value)) {
            throw new IllegalArgumentException("类型不匹配");
        }
        this.value = value;
    }
    
    public T getValue() {
        return value;
    }
    
    public Class<T> getType() {
        return type;
    }
}

// 使用示例
TypeSafeContainer<String> container = new TypeSafeContainer<>(String.class);
container.setValue("Hello");
System.out.println(container.getType()); // 输出 class java.lang.String
```

## 通配符

### 无界通配符
使用 `?` 表示未知类型：

```java
// 可以接受任何类型的 List
public void printList(List<?> list) {
    for (Object obj : list) {
        System.out.println(obj);
    }
}

// 使用示例
List<String> strings = Arrays.asList("a", "b", "c");
List<Integer> numbers = Arrays.asList(1, 2, 3);

printList(strings);  // 可以接受
printList(numbers);  // 可以接受
```

### 上界通配符
使用 `? extends T` 表示 T 或其子类型：

```java
// 只能读取，不能写入（生产者）
public double sum(List<? extends Number> numbers) {
    double total = 0.0;
    for (Number number : numbers) {
        total += number.doubleValue();
    }
    return total;
}

// 使用示例
List<Integer> integers = Arrays.asList(1, 2, 3);
List<Double> doubles = Arrays.asList(1.1, 2.2, 3.3);

System.out.println(sum(integers)); // 6.0
System.out.println(sum(doubles));  // 6.6

// 以下代码编译错误（不能写入）
// numbers.add(new Integer(1)); // 编译错误
```

### 下界通配符
使用 `? super T` 表示 T 或其父类型：

```java
// 只能写入，读取受限（消费者）
public void addNumbers(List<? super Integer> list) {
    for (int i = 1; i <= 5; i++) {
        list.add(i);
    }
}

// 使用示例
List<Number> numbers = new ArrayList<>();
List<Object> objects = new ArrayList<>();

addNumbers(numbers); // 可以添加
addNumbers(objects); // 可以添加

// 读取时只能作为 Object 类型
Object first = numbers.get(0);
```

### PECS 原则
Producer-Extends, Consumer-Super（生产者使用 extends，消费者使用 super）

```java
// 正确的通配符使用
public static <T> void copy(List<? extends T> src, List<? super T> dest) {
    for (T element : src) {
        dest.add(element);
    }
}

// 使用示例
List<Integer> integers = Arrays.asList(1, 2, 3);
List<Number> numbers = new ArrayList<>();

copy(integers, numbers); // 正确：Integer → Number
```

## 泛型的高级特性

### 多重类型参数
```java
// 定义包含两个类型参数的类
public class Pair<K, V> {
    private K key;
    private V value;
    
    public Pair(K key, V value) {
        this.key = key;
        this.value = value;
    }
    
    public K getKey() { return key; }
    public V getValue() { return value; }
    public void setKey(K key) { this.key = key; }
    public void setValue(V value) { this.value = value; }
}

// 使用示例
Pair<String, Integer> pair = new Pair<>("age", 25);
System.out.println(pair.getKey() + ": " + pair.getValue());
```

### 有界类型参数
限制类型参数的范围：

```java
// 类型参数必须实现 Comparable 接口
public class SortedList<T extends Comparable<T>> {
    private List<T> list = new ArrayList<>();
    
    public void add(T element) {
        list.add(element);
        Collections.sort(list);
    }
    
    public T get(int index) {
        return list.get(index);
    }
}

// 使用示例
SortedList<String> strings = new SortedList<>();
strings.add("banana");
strings.add("apple");
System.out.println(strings.get(0)); // 输出 "apple"（已排序）
```

### 递归类型边界
```java
// 类型参数必须实现 Comparable 接口，并且可以与自身比较
public static <T extends Comparable<T>> T max(List<T> list) {
    if (list == null || list.isEmpty()) {
        return null;
    }
    
    T max = list.get(0);
    for (T element : list) {
        if (element.compareTo(max) > 0) {
            max = element;
        }
    }
    return max;
}

// 使用示例
List<Integer> numbers = Arrays.asList(3, 1, 4, 1, 5, 9);
Integer maxNumber = max(numbers);
System.out.println("最大值: " + maxNumber); // 输出 9
```

## 泛型与数组

### 泛型数组的限制
Java 不允许创建泛型数组：

```java
// 以下代码编译错误
// T[] array = new T[10]; // 编译错误

// 正确的替代方案
@SuppressWarnings("unchecked")
public <T> T[] createArray(Class<T> type, int size) {
    return (T[]) Array.newInstance(type, size);
}

// 使用示例
String[] strings = createArray(String.class, 10);
```

### 泛型与可变参数
```java
// 安全的泛型可变参数方法
@SafeVarargs
public static <T> List<T> asList(T... elements) {
    List<T> list = new ArrayList<>();
    for (T element : elements) {
        list.add(element);
    }
    return list;
}

// 使用示例
List<String> names = asList("Alice", "Bob", "Charlie");
```

## 最佳实践

### 命名约定
- **E** - Element（集合中的元素）
- **K** - Key（映射中的键）
- **V** - Value（映射中的值）
- **N** - Number（数字类型）
- **T** - Type（通用类型）
- **S, U, V** - 第二、第三、第四类型

### 使用建议
1. **优先使用泛型**：在可能的情况下使用泛型提高类型安全
2. **避免原始类型**：不要使用 `List`，而应该使用 `List<String>`
3. **合理使用通配符**：遵循 PECS 原则
4. **注意类型擦除**：在需要运行时类型信息时使用 Class 对象
5. **文档化泛型约束**：对复杂的泛型约束添加详细注释

### 常见陷阱
1. **不能实例化泛型类型**：`new T()` 是不允许的
2. **不能创建泛型数组**：`new T[10]` 是不允许的
3. **静态上下文限制**：静态字段和方法不能使用类的类型参数
4. **类型擦除导致的混淆**：`List<String>` 和 `List<Integer>` 在运行时是相同的类型

## 总结

Java 泛型是提高代码类型安全性和可重用性的重要特性。通过合理使用泛型类、泛型接口、泛型方法以及通配符，可以编写出更加健壮和灵活的代码。虽然类型擦除带来了一些限制，但通过适当的设计模式和技术手段，这些限制是可以克服的。

最后更新时间：2024-01-15