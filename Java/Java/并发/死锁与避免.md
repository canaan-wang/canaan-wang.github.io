# 死锁与避免策略

## 定义与作用

死锁（Deadlock）是多线程编程中常见的并发问题，指两个或多个线程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力干涉，这些线程都将无法继续执行。

### 死锁的危害
- 程序挂起，无法继续执行
- 资源被永久占用，无法释放
- 系统性能严重下降
- 难以调试和定位问题

## 死锁的四个必要条件

死锁的发生必须同时满足以下四个条件：

### 1. 互斥条件（Mutual Exclusion）
资源一次只能被一个线程占用。

```java
// 互斥资源示例
private final Object lockA = new Object();
private final Object lockB = new Object();
```

### 2. 占有且等待条件（Hold and Wait）
线程已经持有了至少一个资源，但又等待获取其他线程持有的资源。

```java
public class HoldAndWaitExample {
    private final Object lock1 = new Object();
    private final Object lock2 = new Object();
    
    public void method1() {
        synchronized (lock1) {          // 占有lock1
            // 执行一些操作
            synchronized (lock2) {      // 等待lock2
                // 需要同时持有lock1和lock2的操作
            }
        }
    }
    
    public void method2() {
        synchronized (lock2) {          // 占有lock2
            // 执行一些操作
            synchronized (lock1) {      // 等待lock1
                // 需要同时持有lock1和lock2的操作
            }
        }
    }
}
```

### 3. 不可剥夺条件（No Preemption）
线程已获得的资源在未使用完之前，不能被其他线程强行剥夺。

### 4. 循环等待条件（Circular Wait）
存在一个线程等待序列：T1等待T2占有的资源，T2等待T3占有的资源，...，Tn等待T1占有的资源。

## 死锁示例分析

### 经典死锁示例

```java
public class ClassicDeadlock {
    private final Object lockA = new Object();
    private final Object lockB = new Object();
    
    public void methodA() {
        synchronized (lockA) {
            System.out.println(Thread.currentThread().getName() + " 获得 lockA");
            
            // 模拟一些工作
            try {
                Thread.sleep(100);
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
            
            synchronized (lockB) {
                System.out.println(Thread.currentThread().getName() + " 获得 lockB");
                // 执行需要同时持有lockA和lockB的操作
            }
        }
    }
    
    public void methodB() {
        synchronized (lockB) {
            System.out.println(Thread.currentThread().getName() + " 获得 lockB");
            
            // 模拟一些工作
            try {
                Thread.sleep(100);
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
            
            synchronized (lockA) {
                System.out.println(Thread.currentThread().getName() + " 获得 lockA");
                // 执行需要同时持有lockA和lockB的操作
            }
        }
    }
    
    public static void main(String[] args) {
        ClassicDeadlock deadlock = new ClassicDeadlock();
        
        Thread thread1 = new Thread(() -> deadlock.methodA(), "Thread-1");
        Thread thread2 = new Thread(() -> deadlock.methodB(), "Thread-2");
        
        thread1.start();
        thread2.start();
        
        // 程序可能在这里挂起，形成死锁
    }
}
```

### 数据库死锁示例

```java
public class DatabaseDeadlock {
    private final Connection connection;
    
    public DatabaseDeadlock(Connection connection) {
        this.connection = connection;
    }
    
    public void transferMoney(int fromAccount, int toAccount, BigDecimal amount) {
        try {
            connection.setAutoCommit(false);
            
            // 锁定转出账户
            PreparedStatement stmt1 = connection.prepareStatement(
                "SELECT * FROM accounts WHERE id = ? FOR UPDATE");
            stmt1.setInt(1, fromAccount);
            stmt1.executeQuery();
            
            // 锁定转入账户（可能形成死锁）
            PreparedStatement stmt2 = connection.prepareStatement(
                "SELECT * FROM accounts WHERE id = ? FOR UPDATE");
            stmt2.setInt(1, toAccount);
            stmt2.executeQuery();
            
            // 执行转账操作
            // ...
            
            connection.commit();
        } catch (SQLException e) {
            try {
                connection.rollback();
            } catch (SQLException ex) {
                ex.printStackTrace();
            }
        }
    }
}
```

## 死锁避免策略

### 1. 破坏互斥条件

**策略**：使用无锁数据结构或共享资源

```java
// 使用原子类替代锁
public class AtomicSolution {
    private AtomicInteger counter = new AtomicInteger(0);
    
    public void increment() {
        counter.incrementAndGet(); // 无锁操作
    }
    
    public int getValue() {
        return counter.get();
    }
}

// 使用并发容器
public class ConcurrentContainerSolution {
    private ConcurrentHashMap<String, String> map = new ConcurrentHashMap<>();
    
    public void put(String key, String value) {
        map.put(key, value); // 内部使用细粒度锁
    }
}
```

### 2. 破坏占有且等待条件

**策略**：一次性申请所有需要的资源

```java
public class AllOrNothingSolution {
    private final Object globalLock = new Object();
    private final Object resourceA = new Object();
    private final Object resourceB = new Object();
    
    public void safeOperation() {
        synchronized (globalLock) { // 使用全局锁
            // 一次性获得所有需要的资源
            synchronized (resourceA) {
                synchronized (resourceB) {
                    // 执行操作
                }
            }
        }
    }
}
```

### 3. 破坏不可剥夺条件

**策略**：使用可中断的锁或超时机制

```java
public class PreemptiveSolution {
    private final ReentrantLock lockA = new ReentrantLock();
    private final ReentrantLock lockB = new ReentrantLock();
    
    public boolean tryOperation(long timeout, TimeUnit unit) {
        try {
            // 尝试获取锁A（可中断）
            if (!lockA.tryLock(timeout, unit)) {
                return false;
            }
            
            try {
                // 尝试获取锁B（可中断）
                if (!lockB.tryLock(timeout, unit)) {
                    return false;
                }
                
                try {
                    // 执行操作
                    return true;
                } finally {
                    lockB.unlock();
                }
            } finally {
                lockA.unlock();
            }
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            return false;
        }
    }
}
```

### 4. 破坏循环等待条件

**策略**：统一加锁顺序

```java
public class OrderedLockSolution {
    private final Object lock1 = new Object();
    private final Object lock2 = new Object();
    
    // 统一的锁获取顺序
    private void acquireLocksInOrder(Object firstLock, Object secondLock) {
        // 确保总是先获取编号较小的锁
        Object lockA, lockB;
        if (System.identityHashCode(firstLock) < System.identityHashCode(secondLock)) {
            lockA = firstLock;
            lockB = secondLock;
        } else {
            lockA = secondLock;
            lockB = firstLock;
        }
        
        synchronized (lockA) {
            synchronized (lockB) {
                // 执行操作
            }
        }
    }
    
    public void method1() {
        acquireLocksInOrder(lock1, lock2);
    }
    
    public void method2() {
        acquireLocksInOrder(lock1, lock2); // 相同的顺序
    }
}
```

## 高级死锁避免技术

### 1. 锁超时机制

```java
public class TimeoutLockSolution {
    private final ReentrantLock lock = new ReentrantLock();
    
    public boolean performOperationWithTimeout() {
        try {
            // 尝试获取锁，最多等待5秒
            if (lock.tryLock(5, TimeUnit.SECONDS)) {
                try {
                    // 执行操作
                    return true;
                } finally {
                    lock.unlock();
                }
            } else {
                // 超时处理
                System.out.println("获取锁超时，执行降级策略");
                return false;
            }
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            return false;
        }
    }
}
```

### 2. 死锁检测与恢复

```java
public class DeadlockDetector {
    private final ThreadMXBean threadMXBean = ManagementFactory.getThreadMXBean();
    
    public void detectAndRecover() {
        // 检测死锁
        long[] deadlockedThreads = threadMXBean.findDeadlockedThreads();
        
        if (deadlockedThreads != null && deadlockedThreads.length > 0) {
            System.out.println("检测到死锁，涉及线程：" + deadlockedThreads.length);
            
            // 获取死锁信息
            ThreadInfo[] threadInfos = threadMXBean.getThreadInfo(deadlockedThreads);
            
            for (ThreadInfo threadInfo : threadInfos) {
                System.out.println("死锁线程：" + threadInfo.getThreadName());
                System.out.println("等待锁：" + threadInfo.getLockName());
                System.out.println("被线程持有：" + threadInfo.getLockOwnerName());
            }
            
            // 恢复策略：中断一个死锁线程
            if (deadlockedThreads.length > 0) {
                Thread thread = findThreadById(deadlockedThreads[0]);
                if (thread != null) {
                    thread.interrupt();
                    System.out.println("已中断线程：" + thread.getName());
                }
            }
        }
    }
    
    private Thread findThreadById(long threadId) {
        for (Thread thread : Thread.getAllStackTraces().keySet()) {
            if (thread.getId() == threadId) {
                return thread;
            }
        }
        return null;
    }
}
```

### 3. 资源分配图算法

```java
public class ResourceAllocationGraph {
    private final Map<Thread, Set<Object>> threadLocks = new ConcurrentHashMap<>();
    private final Map<Object, Thread> lockOwners = new ConcurrentHashMap<>();
    
    public boolean tryAcquireLock(Thread thread, Object lock) {
        // 检查是否会导致死锁
        if (wouldCauseDeadlock(thread, lock)) {
            return false;
        }
        
        // 安全获取锁
        threadLocks.computeIfAbsent(thread, k -> ConcurrentHashMap.newKeySet()).add(lock);
        lockOwners.put(lock, thread);
        return true;
    }
    
    public void releaseLock(Thread thread, Object lock) {
        Set<Object> locks = threadLocks.get(thread);
        if (locks != null) {
            locks.remove(lock);
        }
        lockOwners.remove(lock);
    }
    
    private boolean wouldCauseDeadlock(Thread requester, Object requestedLock) {
        Thread currentOwner = lockOwners.get(requestedLock);
        
        if (currentOwner == null) {
            return false; // 锁未被占用
        }
        
        if (currentOwner.equals(requester)) {
            return false; // 重入锁
        }
        
        // 检查循环等待
        return checkCircularWait(requester, currentOwner, new HashSet<>());
    }
    
    private boolean checkCircularWait(Thread start, Thread current, Set<Thread> visited) {
        if (visited.contains(current)) {
            return true; // 发现循环
        }
        
        visited.add(current);
        
        Set<Object> currentLocks = threadLocks.get(current);
        if (currentLocks == null) {
            return false;
        }
        
        for (Object lock : currentLocks) {
            Thread owner = lockOwners.get(lock);
            if (owner != null && !owner.equals(current)) {
                if (checkCircularWait(start, owner, visited)) {
                    return true;
                }
            }
        }
        
        return false;
    }
}
```

## 死锁调试技巧

### 1. 使用 jstack 检测死锁

```bash
# 获取Java进程PID
jps

# 生成线程转储
jstack <pid>

# 搜索死锁信息
grep -A 20 -B 5 "deadlock" jstack_output.txt
```

### 2. 使用 JConsole 或 VisualVM

```java
// 启用JMX监控
public class JMXMonitoring {
    public static void main(String[] args) {
        // 添加JMX参数
        // -Dcom.sun.management.jmxremote
        // -Dcom.sun.management.jmxremote.port=9999
        // -Dcom.sun.management.jmxremote.authenticate=false
        // -Dcom.sun.management.jmxremote.ssl=false
        
        // 程序逻辑...
    }
}
```

### 3. 编程式死锁检测

```java
public class ProgrammaticDeadlockDetection {
    private final ScheduledExecutorService scheduler = 
        Executors.newScheduledThreadPool(1);
    
    public void startDeadlockMonitoring() {
        scheduler.scheduleAtFixedRate(() -> {
            ThreadMXBean threadMXBean = ManagementFactory.getThreadMXBean();
            long[] deadlockedThreads = threadMXBean.findDeadlockedThreads();
            
            if (deadlockedThreads != null) {
                System.err.println("检测到死锁！");
                // 记录日志、发送告警等
            }
        }, 0, 30, TimeUnit.SECONDS); // 每30秒检测一次
    }
}
```

## 最佳实践

### 1. 锁设计原则

```java
public class LockDesignBestPractices {
    // 1. 尽量使用细粒度锁
    private final Map<String, Object> segmentLocks = new ConcurrentHashMap<>();
    
    public Object getSegmentLock(String key) {
        return segmentLocks.computeIfAbsent(key, k -> new Object());
    }
    
    // 2. 避免嵌套锁
    public void avoidNestedLocks() {
        // 重构嵌套锁为顺序锁
        Object lock1 = getLockForResource1();
        Object lock2 = getLockForResource2();
        
        // 统一获取顺序
        if (System.identityHashCode(lock1) < System.identityHashCode(lock2)) {
            synchronized (lock1) {
                synchronized (lock2) {
                    // 操作
                }
            }
        } else {
            synchronized (lock2) {
                synchronized (lock1) {
                    // 操作
                }
            }
        }
    }
    
    // 3. 使用读写锁分离读操作
    private final ReadWriteLock rwLock = new ReentrantReadWriteLock();
    
    public void readOperation() {
        rwLock.readLock().lock();
        try {
            // 读操作
        } finally {
            rwLock.readLock().unlock();
        }
    }
}
```

### 2. 资源管理最佳实践

```java
public class ResourceManagementBestPractices {
    // 1. 使用try-with-resources确保资源释放
    public void safeResourceUsage() {
        try (LockResource lock = acquireLock()) {
            // 使用资源
        } // 自动释放
    }
    
    // 2. 设置合理的超时时间
    public boolean safeOperationWithTimeout() {
        try {
            return performOperation(5, TimeUnit.SECONDS);
        } catch (TimeoutException e) {
            // 超时处理
            return false;
        }
    }
    
    // 3. 实现资源清理机制
    @Override
    protected void finalize() throws Throwable {
        try {
            cleanupResources();
        } finally {
            super.finalize();
        }
    }
}
```

## 总结

死锁是多线程编程中的严重问题，但通过合理的策略和工具可以有效地避免和解决：

### 关键预防措施
1. **统一锁顺序**：破坏循环等待条件
2. **使用超时机制**：避免无限期等待
3. **减少锁粒度**：降低死锁概率
4. **避免嵌套锁**：简化锁依赖关系

### 检测与恢复工具
1. **jstack**：命令行死锁检测
2. **JConsole/VisualVM**：图形化监控工具
3. **ThreadMXBean**：编程式死锁检测

### 最佳实践
- 设计阶段考虑并发安全性
- 使用现有的并发工具类
- 实现完善的错误处理和恢复机制
- 定期进行并发测试和代码审查

通过系统性地应用这些策略和工具，可以显著降低死锁发生的概率，提高多线程程序的稳定性和可靠性。

---

最后更新时间：2024-12-19