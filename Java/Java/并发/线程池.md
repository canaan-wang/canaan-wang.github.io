# Java 线程池详解

## 定义与作用

### 什么是线程池
线程池（Thread Pool）是一种线程管理机制，通过预先创建一定数量的线程并维护一个任务队列，实现对线程的复用和统一管理。Java 中的线程池主要通过 `ThreadPoolExecutor` 类实现。

### 线程池的主要作用
1. **线程复用**：避免频繁创建和销毁线程的开销，提高性能
2. **资源控制**：限制并发线程数量，防止系统资源耗尽
3. **任务管理**：提供任务队列、拒绝策略等管理机制
4. **监控统计**：支持线程池状态监控和性能统计

## 线程池核心组件

### ThreadPoolExecutor 核心参数
```java
ThreadPoolExecutor executor = new ThreadPoolExecutor(
    corePoolSize,     // 核心线程数
    maximumPoolSize,  // 最大线程数
    keepAliveTime,    // 非核心线程空闲存活时间
    unit,             // 时间单位
    workQueue,        // 任务队列
    threadFactory,    // 线程工厂
    handler          // 拒绝策略
);
```

### 1. 核心线程数（corePoolSize）
- **定义**：线程池中保持活动状态的最小线程数
- **作用**：即使没有任务执行，核心线程也不会被回收
- **默认值**：0（可根据需要设置）

### 2. 最大线程数（maximumPoolSize）
- **定义**：线程池允许创建的最大线程数量
- **作用**：当任务队列已满时，可以创建新线程处理任务
- **注意**：不能小于核心线程数

### 3. 存活时间（keepAliveTime）
- **定义**：非核心线程空闲时的最大存活时间
- **作用**：当线程空闲时间超过该值时，会被回收
- **单位**：TimeUnit（秒、毫秒等）

### 4. 任务队列（workQueue）
```java
// 常用队列类型
BlockingQueue<Runnable> queue1 = new ArrayBlockingQueue<>(100); // 有界队列
BlockingQueue<Runnable> queue2 = new LinkedBlockingQueue<>();   // 无界队列
BlockingQueue<Runnable> queue3 = new SynchronousQueue<>();      // 同步移交队列
BlockingQueue<Runnable> queue4 = new PriorityBlockingQueue<>(); // 优先级队列
```

### 5. 线程工厂（threadFactory）
```java
ThreadFactory factory = new ThreadFactory() {
    private final AtomicInteger threadNumber = new AtomicInteger(1);
    
    @Override
    public Thread newThread(Runnable r) {
        Thread thread = new Thread(r, "pool-thread-" + threadNumber.getAndIncrement());
        thread.setDaemon(false);
        thread.setPriority(Thread.NORM_PRIORITY);
        return thread;
    }
};
```

### 6. 拒绝策略（RejectedExecutionHandler）
```java
// 内置拒绝策略
RejectedExecutionHandler handler1 = new ThreadPoolExecutor.AbortPolicy();        // 抛出异常
RejectedExecutionHandler handler2 = new ThreadPoolExecutor.CallerRunsPolicy();  // 调用者执行
RejectedExecutionHandler handler3 = new ThreadPoolExecutor.DiscardPolicy();     // 直接丢弃
RejectedExecutionHandler handler4 = new ThreadPoolExecutor.DiscardOldestPolicy(); // 丢弃最旧任务
```

## 线程池工作流程

### 任务提交流程
```java
// 线程池执行流程图
public void execute(Runnable command) {
    if (command == null) throw new NullPointerException();
    
    int c = ctl.get();
    if (workerCountOf(c) < corePoolSize) {
        // 1. 当前线程数 < 核心线程数，创建新线程
        if (addWorker(command, true)) return;
        c = ctl.get();
    }
    
    if (isRunning(c) && workQueue.offer(command)) {
        // 2. 线程池运行中，任务入队成功
        int recheck = ctl.get();
        if (!isRunning(recheck) && remove(command))
            reject(command);
        else if (workerCountOf(recheck) == 0)
            addWorker(null, false);
    } else if (!addWorker(command, false)) {
        // 3. 队列已满，创建新线程失败，执行拒绝策略
        reject(command);
    }
}
```

### 线程池状态流转
线程池有 5 种状态，通过原子整型变量 `ctl` 的高 3 位表示：

1. **RUNNING**：运行状态，接受新任务并处理队列中的任务
2. **SHUTDOWN**：关闭状态，不接受新任务，但处理队列中的任务
3. **STOP**：停止状态，不接受新任务，不处理队列中的任务，中断正在执行的任务
4. **TIDYING**：整理状态，所有任务都已终止，workerCount 为 0
5. **TERMINATED**：终止状态，terminated() 方法执行完成

状态转换：RUNNING → SHUTDOWN → STOP → TIDYING → TERMINATED

## 常用线程池类型

### 1. FixedThreadPool（固定大小线程池）
```java
ExecutorService fixedPool = Executors.newFixedThreadPool(10);
// 特点：固定线程数，无界队列，适用于负载较重的服务器
```

### 2. CachedThreadPool（缓存线程池）
```java
ExecutorService cachedPool = Executors.newCachedThreadPool();
// 特点：线程数可扩展，60秒空闲回收，适用于短期异步任务
```

### 3. SingleThreadExecutor（单线程池）
```java
ExecutorService singlePool = Executors.newSingleThreadExecutor();
// 特点：单个工作线程，保证任务顺序执行
```

### 4. ScheduledThreadPool（定时线程池）
```java
ScheduledExecutorService scheduledPool = Executors.newScheduledThreadPool(5);
// 特点：支持定时和周期性任务执行
```

## 线程池使用示例

### 基础使用
```java
// 创建自定义线程池
ThreadPoolExecutor executor = new ThreadPoolExecutor(
    5,                              // 核心线程数
    10,                             // 最大线程数
    60L,                            // 空闲时间
    TimeUnit.SECONDS,               // 时间单位
    new ArrayBlockingQueue<>(100),  // 任务队列
    Executors.defaultThreadFactory(), // 线程工厂
    new ThreadPoolExecutor.AbortPolicy() // 拒绝策略
);

// 提交任务
for (int i = 0; i < 20; i++) {
    final int taskId = i;
    executor.execute(() -> {
        System.out.println("执行任务: " + taskId + ", 线程: " + Thread.currentThread().getName());
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
    });
}

// 优雅关闭
executor.shutdown();
try {
    if (!executor.awaitTermination(60, TimeUnit.SECONDS)) {
        executor.shutdownNow();
    }
} catch (InterruptedException e) {
    executor.shutdownNow();
    Thread.currentThread().interrupt();
}
```

### 定时任务示例
```java
ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(3);

// 延迟执行
scheduler.schedule(() -> {
    System.out.println("延迟5秒执行");
}, 5, TimeUnit.SECONDS);

// 固定频率执行
scheduler.scheduleAtFixedRate(() -> {
    System.out.println("每3秒执行一次");
}, 0, 3, TimeUnit.SECONDS);

// 固定延迟执行
scheduler.scheduleWithFixedDelay(() -> {
    System.out.println("任务完成后延迟2秒执行下一次");
}, 0, 2, TimeUnit.SECONDS);
```

## 线程池实现原理

### 核心数据结构
```java
// ThreadPoolExecutor 核心字段
private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));
private final BlockingQueue<Runnable> workQueue;
private final HashSet<Worker> workers = new HashSet<>();
private final ReentrantLock mainLock = new ReentrantLock();
```

### Worker 内部类
```java
private final class Worker extends AbstractQueuedSynchronizer implements Runnable {
    final Thread thread;  // 工作线程
    Runnable firstTask;   // 初始任务
    
    Worker(Runnable firstTask) {
        setState(-1); // 抑制中断直到 runWorker
        this.firstTask = firstTask;
        this.thread = getThreadFactory().newThread(this);
    }
    
    public void run() {
        runWorker(this);
    }
}
```

### 任务执行流程
```java
final void runWorker(Worker w) {
    Thread wt = Thread.currentThread();
    Runnable task = w.firstTask;
    w.firstTask = null;
    w.unlock(); // 允许中断
    boolean completedAbruptly = true;
    
    try {
        while (task != null || (task = getTask()) != null) {
            w.lock();
            // 如果线程池正在停止，确保线程被中断
            if ((runStateAtLeast(ctl.get(), STOP) ||
                 (Thread.interrupted() && runStateAtLeast(ctl.get(), STOP))) &&
                !wt.isInterrupted())
                wt.interrupt();
            
            try {
                beforeExecute(wt, task);
                Throwable thrown = null;
                try {
                    task.run();
                } catch (RuntimeException x) {
                    thrown = x; throw x;
                } catch (Error x) {
                    thrown = x; throw x;
                } catch (Throwable x) {
                    thrown = x; throw new Error(x);
                } finally {
                    afterExecute(task, thrown);
                }
            } finally {
                task = null;
                w.completedTasks++;
                w.unlock();
            }
        }
        completedAbruptly = false;
    } finally {
        processWorkerExit(w, completedAbruptly);
    }
}
```

## 线程池优缺点分析

### 优点
1. **性能提升**：线程复用减少创建销毁开销
2. **资源管理**：控制并发数量，防止资源耗尽
3. **稳定性**：提供任务队列和拒绝策略，增强系统稳定性
4. **监控能力**：支持线程池状态监控和性能统计
5. **灵活性**：支持多种配置和扩展机制

### 缺点
1. **配置复杂**：参数调优需要经验积累
2. **资源泄漏**：不当使用可能导致线程泄漏
3. **死锁风险**：任务间依赖可能导致死锁
4. **调试困难**：多线程问题定位相对复杂

## 最佳实践

### 1. 合理配置参数
```java
// CPU 密集型任务
int corePoolSize = Runtime.getRuntime().availableProcessors();
// IO 密集型任务  
int corePoolSize = Runtime.getRuntime().availableProcessors() * 2;

// 使用有界队列防止内存溢出
BlockingQueue<Runnable> queue = new ArrayBlockingQueue<>(1000);
```

### 2. 避免使用无界队列
```java
// 不推荐：可能导致内存溢出
ExecutorService badPool = Executors.newFixedThreadPool(10);

// 推荐：使用有界队列
ThreadPoolExecutor goodPool = new ThreadPoolExecutor(
    10, 10, 60L, TimeUnit.SECONDS,
    new ArrayBlockingQueue<>(1000),
    new ThreadPoolExecutor.AbortPolicy()
);
```

### 3. 正确处理异常
```java
executor.execute(() -> {
    try {
        // 业务逻辑
    } catch (Exception e) {
        // 记录日志
        logger.error("任务执行异常", e);
    }
});
```

### 4. 优雅关闭
```java
// 先尝试平缓关闭
executor.shutdown();

// 等待一段时间
if (!executor.awaitTermination(60, TimeUnit.SECONDS)) {
    // 强制关闭
    executor.shutdownNow();
    // 再次等待
    if (!executor.awaitTermination(60, TimeUnit.SECONDS)) {
        System.err.println("线程池未正常关闭");
    }
}
```

### 5. 监控和统计
```java
ThreadPoolExecutor executor = ...;

// 监控指标
int activeCount = executor.getActiveCount();
long completedTaskCount = executor.getCompletedTaskCount();
int queueSize = executor.getQueue().size();
int poolSize = executor.getPoolSize();

// 定期输出监控信息
ScheduledExecutorService monitor = Executors.newSingleThreadScheduledExecutor();
monitor.scheduleAtFixedRate(() -> {
    System.out.println("活跃线程: " + activeCount + ", 队列大小: " + queueSize);
}, 0, 30, TimeUnit.SECONDS);
```

## 常见问题与解决方案

### 1. 线程池饥饿
**问题**：大量任务等待，但线程不足
**解决方案**：调整核心线程数，使用合适的队列策略

### 2. 内存溢出
**问题**：无界队列导致任务堆积
**解决方案**：使用有界队列，设置合理的拒绝策略

### 3. 线程泄漏
**问题**：线程未正确回收
**解决方案**：确保任务正常结束，合理设置存活时间

### 4. 死锁
**问题**：任务间相互等待
**解决方案**：避免任务间循环依赖，使用超时机制

## 总结

Java 线程池是并发编程的核心组件，通过合理的配置和使用，可以显著提升系统性能和稳定性。掌握线程池的工作原理、参数调优和最佳实践，对于开发高质量的并发应用至关重要。

在实际应用中，应根据具体业务场景选择合适的线程池类型和配置参数，并建立完善的监控和异常处理机制。

最后更新时间：2024-01-15