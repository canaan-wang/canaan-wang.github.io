# Java 锁机制详解：ReentrantLock、ReadWriteLock、StampedLock

## 定义与作用

### 什么是 Java 锁机制
Java 锁机制是 Java 并发包（java.util.concurrent.locks）提供的高级同步工具，相比内置的 synchronized 关键字，提供了更丰富的功能和更灵活的锁控制能力。

### 锁机制的主要作用
1. **灵活锁控制**：支持可中断、超时、尝试加锁等高级特性
2. **读写分离**：支持读多写少场景的读写锁
3. **性能优化**：提供乐观读、锁升级等性能优化机制
4. **条件等待**：支持更细粒度的线程等待/通知机制

## ReentrantLock（可重入锁）

### 1. 基本使用
```java
import java.util.concurrent.locks.ReentrantLock;

public class ReentrantLockExample {
    private final ReentrantLock lock = new ReentrantLock();
    private int count = 0;
    
    public void increment() {
        lock.lock();  // 获取锁
        try {
            count++;
            System.out.println("Count: " + count + " by " + Thread.currentThread().getName());
        } finally {
            lock.unlock();  // 确保锁被释放
        }
    }
    
    public static void main(String[] args) {
        ReentrantLockExample example = new ReentrantLockExample();
        
        Thread thread1 = new Thread(() -> {
            for (int i = 0; i < 3; i++) {
                example.increment();
            }
        }, "Thread-1");
        
        Thread thread2 = new Thread(() -> {
            for (int i = 0; i < 3; i++) {
                example.increment();
            }
        }, "Thread-2");
        
        thread1.start();
        thread2.start();
    }
}
```

### 2. 高级特性

#### 可中断锁
```java
public class InterruptibleLockExample {
    private final ReentrantLock lock = new ReentrantLock();
    
    public void interruptibleMethod() throws InterruptedException {
        lock.lockInterruptibly();  // 可中断的锁获取
        try {
            // 模拟耗时操作
            Thread.sleep(5000);
        } finally {
            lock.unlock();
        }
    }
    
    public static void main(String[] args) throws InterruptedException {
        InterruptibleLockExample example = new InterruptibleLockExample();
        
        Thread worker = new Thread(() -> {
            try {
                example.interruptibleMethod();
            } catch (InterruptedException e) {
                System.out.println("线程被中断");
            }
        });
        
        worker.start();
        Thread.sleep(1000);  // 等待1秒
        worker.interrupt();  // 中断线程
    }
}
```

#### 尝试加锁与超时
```java
public class TryLockExample {
    private final ReentrantLock lock = new ReentrantLock();
    
    public boolean tryIncrement() {
        if (lock.tryLock()) {  // 尝试获取锁
            try {
                // 业务逻辑
                return true;
            } finally {
                lock.unlock();
            }
        } else {
            System.out.println("获取锁失败，执行其他逻辑");
            return false;
        }
    }
    
    public boolean timeoutLock() throws InterruptedException {
        if (lock.tryLock(2, TimeUnit.SECONDS)) {  // 超时获取锁
            try {
                // 业务逻辑
                return true;
            } finally {
                lock.unlock();
            }
        } else {
            System.out.println("获取锁超时");
            return false;
        }
    }
}
```

#### 公平锁与非公平锁
```java
public class FairLockExample {
    // 公平锁：按照线程请求顺序获取锁
    private final ReentrantLock fairLock = new ReentrantLock(true);
    
    // 非公平锁：性能更好，但可能导致线程饥饿
    private final ReentrantLock unfairLock = new ReentrantLock(false);
    
    public void fairMethod() {
        fairLock.lock();
        try {
            // 业务逻辑
        } finally {
            fairLock.unlock();
        }
    }
    
    public void unfairMethod() {
        unfairLock.lock();
        try {
            // 业务逻辑
        } finally {
            unfairLock.unlock();
        }
    }
}
```

### 3. Condition 条件变量
```java
import java.util.concurrent.locks.Condition;

public class ConditionExample {
    private final ReentrantLock lock = new ReentrantLock();
    private final Condition notEmpty = lock.newCondition();
    private final Condition notFull = lock.newCondition();
    private final Object[] items = new Object[10];
    private int putIndex, takeIndex, count;
    
    public void put(Object x) throws InterruptedException {
        lock.lock();
        try {
            while (count == items.length) {
                notFull.await();  // 等待不满条件
            }
            items[putIndex] = x;
            if (++putIndex == items.length) putIndex = 0;
            count++;
            notEmpty.signal();  // 通知不空条件
        } finally {
            lock.unlock();
        }
    }
    
    public Object take() throws InterruptedException {
        lock.lock();
        try {
            while (count == 0) {
                notEmpty.await();  // 等待不空条件
            }
            Object x = items[takeIndex];
            if (++takeIndex == items.length) takeIndex = 0;
            count--;
            notFull.signal();  // 通知不满条件
            return x;
        } finally {
            lock.unlock();
        }
    }
}
```

## ReadWriteLock（读写锁）

### 1. 基本使用
```java
import java.util.concurrent.locks.ReadWriteLock;
import java.util.concurrent.locks.ReentrantReadWriteLock;

public class ReadWriteLockExample {
    private final ReadWriteLock rwLock = new ReentrantReadWriteLock();
    private Map<String, String> cache = new HashMap<>();
    
    public String read(String key) {
        rwLock.readLock().lock();  // 获取读锁
        try {
            return cache.get(key);
        } finally {
            rwLock.readLock().unlock();
        }
    }
    
    public void write(String key, String value) {
        rwLock.writeLock().lock();  // 获取写锁
        try {
            cache.put(key, value);
        } finally {
            rwLock.writeLock().unlock();
        }
    }
    
    // 锁降级示例
    public void lockDowngrade(String key, String newValue) {
        rwLock.writeLock().lock();  // 获取写锁
        try {
            // 修改数据
            cache.put(key, newValue);
            
            // 降级为读锁
            rwLock.readLock().lock();
        } finally {
            rwLock.writeLock().unlock();  // 释放写锁，保持读锁
        }
        
        try {
            // 在持有读锁的情况下读取数据
            String value = cache.get(key);
            System.out.println("读取数据: " + value);
        } finally {
            rwLock.readLock().unlock();
        }
    }
}
```

### 2. 读写锁策略

#### 公平策略
```java
// 公平读写锁：按照请求顺序分配锁
ReadWriteLock fairRwLock = new ReentrantReadWriteLock(true);
```

#### 非公平策略
```java
// 非公平读写锁：写锁优先，防止写饥饿
ReadWriteLock unfairRwLock = new ReentrantReadWriteLock(false);
```

### 3. 性能考虑
```java
public class CacheWithReadWriteLock {
    private final ReadWriteLock rwLock = new ReentrantReadWriteLock();
    private Map<String, Object> cache = new ConcurrentHashMap<>();
    
    public Object get(String key) {
        Object value;
        rwLock.readLock().lock();
        try {
            value = cache.get(key);
            if (value != null) {
                return value;  // 缓存命中
            }
        } finally {
            rwLock.readLock().unlock();
        }
        
        // 缓存未命中，需要加载数据
        rwLock.writeLock().lock();
        try {
            // 双重检查，防止重复加载
            value = cache.get(key);
            if (value == null) {
                value = loadFromDatabase(key);  // 从数据库加载
                cache.put(key, value);
            }
            return value;
        } finally {
            rwLock.writeLock().unlock();
        }
    }
    
    private Object loadFromDatabase(String key) {
        // 模拟数据库加载
        return "Data for " + key;
    }
}
```

## StampedLock

### 1. 基本使用
```java
import java.util.concurrent.locks.StampedLock;

public class StampedLockExample {
    private final StampedLock sl = new StampedLock();
    private double x, y;
    
    // 写锁
    public void move(double deltaX, double deltaY) {
        long stamp = sl.writeLock();  // 获取写锁
        try {
            x += deltaX;
            y += deltaY;
        } finally {
            sl.unlockWrite(stamp);  // 释放写锁
        }
    }
    
    // 读锁
    public double distanceFromOrigin() {
        long stamp = sl.readLock();  // 获取读锁
        try {
            return Math.sqrt(x * x + y * y);
        } finally {
            sl.unlockRead(stamp);  // 释放读锁
        }
    }
    
    // 乐观读
    public double optimisticDistanceFromOrigin() {
        long stamp = sl.tryOptimisticRead();  // 尝试乐观读
        double currentX = x, currentY = y;
        
        if (!sl.validate(stamp)) {  // 检查是否被修改
            stamp = sl.readLock();  // 获取读锁
            try {
                currentX = x;
                currentY = y;
            } finally {
                sl.unlockRead(stamp);
            }
        }
        
        return Math.sqrt(currentX * currentX + currentY * currentY);
    }
    
    // 锁升级
    public void moveIfAtOrigin(double newX, double newY) {
        long stamp = sl.readLock();  // 获取读锁
        try {
            while (x == 0.0 && y == 0.0) {
                long ws = sl.tryConvertToWriteLock(stamp);  // 尝试升级为写锁
                if (ws != 0L) {
                    stamp = ws;  // 升级成功
                    x = newX;
                    y = newY;
                    break;
                } else {
                    sl.unlockRead(stamp);  // 升级失败，释放读锁
                    stamp = sl.writeLock();  // 获取写锁
                }
            }
        } finally {
            sl.unlock(stamp);  // 释放锁
        }
    }
}
```

### 2. 乐观读模式
```java
public class OptimisticReadCache {
    private final StampedLock sl = new StampedLock();
    private Map<String, String> cache = new HashMap<>();
    
    public String getWithOptimisticRead(String key) {
        long stamp = sl.tryOptimisticRead();
        String value = cache.get(key);
        
        if (!sl.validate(stamp)) {
            // 数据被修改，使用悲观读
            stamp = sl.readLock();
            try {
                value = cache.get(key);
            } finally {
                sl.unlockRead(stamp);
            }
        }
        
        return value;
    }
    
    public void put(String key, String value) {
        long stamp = sl.writeLock();
        try {
            cache.put(key, value);
        } finally {
            sl.unlockWrite(stamp);
        }
    }
}
```

## 实现原理

### 1. ReentrantLock 实现原理
```java
// 简化的 AQS（AbstractQueuedSynchronizer）实现
public class ReentrantLock implements Lock {
    private final Sync sync;
    
    abstract static class Sync extends AbstractQueuedSynchronizer {
        // 尝试获取锁
        abstract void lock();
        
        // 非公平锁实现
        final boolean nonfairTryAcquire(int acquires) {
            final Thread current = Thread.currentThread();
            int c = getState();
            if (c == 0) {
                if (compareAndSetState(0, acquires)) {
                    setExclusiveOwnerThread(current);
                    return true;
                }
            } else if (current == getExclusiveOwnerThread()) {
                int nextc = c + acquires;
                if (nextc < 0) throw new Error("Maximum lock count exceeded");
                setState(nextc);
                return true;
            }
            return false;
        }
    }
}
```

### 2. ReadWriteLock 实现原理
```java
// 简化的读写锁状态管理
public class ReentrantReadWriteLock implements ReadWriteLock {
    static final class Sync extends AbstractQueuedSynchronizer {
        // 读写锁状态分离：高16位表示读锁数量，低16位表示写锁数量
        static final int SHARED_SHIFT   = 16;
        static final int SHARED_UNIT    = (1 << SHARED_SHIFT);
        static final int MAX_COUNT      = (1 << SHARED_SHIFT) - 1;
        static final int EXCLUSIVE_MASK = (1 << SHARED_SHIFT) - 1;
        
        // 获取读锁数量
        static int sharedCount(int c) { return c >>> SHARED_SHIFT; }
        
        // 获取写锁数量
        static int exclusiveCount(int c) { return c & EXCLUSIVE_MASK; }
    }
}
```

### 3. StampedLock 实现原理
```java
// 简化的乐观读实现
public class StampedLock implements java.io.Serializable {
    // 锁状态：使用long类型，包含版本号和锁状态信息
    private transient volatile long state;
    
    // 乐观读：不阻塞，直接返回版本号
    public long tryOptimisticRead() {
        long s;
        return (((s = state) & WBIT) == 0L) ? (s & SBITS) : 0L;
    }
    
    // 验证乐观读是否有效
    public boolean validate(long stamp) {
        // 检查版本号是否发生变化
        return (stamp & SBITS) == (state & SBITS);
    }
}
```

## 优缺点分析

### ReentrantLock 优缺点
**优点**：
- 功能丰富：支持中断、超时、尝试加锁等
- 性能优秀：在竞争激烈时性能优于 synchronized
- 公平性可配置：支持公平和非公平模式

**缺点**：
- 使用复杂：需要手动获取和释放锁
- 容易出错：忘记释放锁会导致死锁

### ReadWriteLock 优缺点
**优点**：
- 读写分离：提高读多写少场景的性能
- 锁降级支持：写锁可以降级为读锁

**缺点**：
- 写饥饿：读锁过多时写操作可能被阻塞
- 复杂性：需要合理设计读写策略

### StampedLock 优缺点
**优点**：
- 性能极高：乐观读模式避免锁竞争
- 锁升级：支持读锁升级为写锁

**缺点**：
- 非可重入：同一个线程不能重复获取锁
- 使用复杂：需要处理乐观读失败的情况

## 选择建议

### 场景选择指南

| 场景 | 推荐锁类型 | 理由 |
|------|-----------|------|
| 简单同步 | synchronized | 语法简单，自动管理 |
| 需要高级特性 | ReentrantLock | 支持中断、超时等 |
| 读多写少 | ReadWriteLock | 读写分离，性能好 |
| 读非常多，写很少 | StampedLock | 乐观读性能最佳 |
| 需要锁升级 | StampedLock | 支持读锁升级为写锁 |

### 性能考虑
```java
public class LockBenchmark {
    // 不同锁类型的性能测试
    public void benchmark() {
        // 测试 synchronized
        long start = System.nanoTime();
        synchronized (this) {
            // 业务逻辑
        }
        long syncTime = System.nanoTime() - start;
        
        // 测试 ReentrantLock
        ReentrantLock lock = new ReentrantLock();
        start = System.nanoTime();
        lock.lock();
        try {
            // 业务逻辑
        } finally {
            lock.unlock();
        }
        long lockTime = System.nanoTime() - start;
        
        System.out.println("synchronized: " + syncTime + " ns");
        System.out.println("ReentrantLock: " + lockTime + " ns");
    }
}
```

## 最佳实践

### 1. 锁的正确使用
```java
// 正确示例：在finally块中释放锁
public class CorrectLockUsage {
    private final ReentrantLock lock = new ReentrantLock();
    
    public void safeMethod() {
        lock.lock();
        try {
            // 业务逻辑
            if (someCondition) {
                return;  // 提前返回也能确保锁被释放
            }
            // 更多业务逻辑
        } finally {
            lock.unlock();
        }
    }
}
```

### 2. 避免死锁
```java
public class DeadlockPrevention {
    private final ReentrantLock lock1 = new ReentrantLock();
    private final ReentrantLock lock2 = new ReentrantLock();
    
    // 错误的实现：可能导致死锁
    public void wrongMethod() {
        lock1.lock();
        try {
            lock2.lock();  // 可能在这里阻塞
            try {
                // 业务逻辑
            } finally {
                lock2.unlock();
            }
        } finally {
            lock1.unlock();
        }
    }
    
    // 正确的实现：使用tryLock避免死锁
    public void correctMethod() throws InterruptedException {
        while (true) {
            if (lock1.tryLock()) {
                try {
                    if (lock2.tryLock(1, TimeUnit.SECONDS)) {
                        try {
                            // 业务逻辑
                            return;
                        } finally {
                            lock2.unlock();
                        }
                    }
                } finally {
                    lock1.unlock();
                }
            }
            // 获取锁失败，稍后重试
            Thread.sleep(100);
        }
    }
}
```

### 3. 锁粒度控制
```java
public class FineGrainedLocking {
    // 细粒度锁：每个数据项使用独立的锁
    private final Map<String, ReentrantLock> keyLocks = new ConcurrentHashMap<>();
    private final Map<String, String> data = new ConcurrentHashMap<>();
    
    public void updateData(String key, String value) {
        ReentrantLock lock = keyLocks.computeIfAbsent(key, k -> new ReentrantLock());
        lock.lock();
        try {
            data.put(key, value);
        } finally {
            lock.unlock();
        }
    }
    
    public String getData(String key) {
        // 读操作不需要加锁（ConcurrentHashMap是线程安全的）
        return data.get(key);
    }
}
```

## 常见问题与解决方案

### 1. 锁竞争问题
**问题**：多个线程竞争同一个锁导致性能下降。

**解决方案**：
- 减小锁粒度
- 使用读写锁分离读写操作
- 考虑使用无锁数据结构

### 2. 死锁检测
```java
public class DeadlockDetector {
    public static void detectDeadlocks() {
        ThreadMXBean threadMXBean = ManagementFactory.getThreadMXBean();
        long[] threadIds = threadMXBean.findDeadlockedThreads();
        
        if (threadIds != null) {
            ThreadInfo[] threadInfos = threadMXBean.getThreadInfo(threadIds);
            for (ThreadInfo threadInfo : threadInfos) {
                System.out.println("死锁线程: " + threadInfo.getThreadName());
                System.out.println("阻塞对象: " + threadInfo.getLockName());
                System.out.println("阻塞线程: " + threadInfo.getLockOwnerName());
            }
        }
    }
}
```

### 3. 性能监控
```java
public class LockMonitor {
    private final ReentrantLock lock = new ReentrantLock();
    private long lockWaitTime = 0;
    private long lockHoldTime = 0;
    private int lockCount = 0;
    
    public void monitoredMethod() {
        long startWait = System.nanoTime();
        lock.lock();
        long endWait = System.nanoTime();
        lockWaitTime += (endWait - startWait);
        
        long startHold = System.nanoTime();
        try {
            // 业务逻辑
        } finally {
            lock.unlock();
            long endHold = System.nanoTime();
            lockHoldTime += (endHold - startHold);
            lockCount++;
        }
    }
    
    public void printStats() {
        System.out.println("平均等待时间: " + (lockWaitTime / lockCount) + " ns");
        System.out.println("平均持有时间: " + (lockHoldTime / lockCount) + " ns");
    }
}
```

## 总结

Java 锁机制提供了丰富的同步工具，每种锁都有其适用的场景和特点。在实际开发中，应该根据具体需求选择合适的锁类型，遵循最佳实践，注意性能优化和避免常见陷阱。

**关键要点**：
- 简单场景优先使用 synchronized
- 需要高级特性时选择 ReentrantLock
- 读多写少场景考虑 ReadWriteLock
- 极高读性能需求使用 StampedLock
- 始终在 finally 块中释放锁
- 合理控制锁粒度避免过度竞争

最后更新时间：2024-01-15