# synchronized 同步与内置锁

- synchronized 是 Java 的内置锁（监视器锁，Monitor），具备互斥与可重入特性。
- 作用范围：
  - 实例方法：锁的是当前实例（this）。
  - 静态方法：锁的是当前类的 Class 对象。
  - 同步代码块：锁的是指定的对象引用。
- 可重入：同一线程已持有某对象锁时，可再次进入同一对象的其他同步代码块/方法。
- 可见性：退出临界区时，线程对共享变量的修改会对后续获取同一锁的线程可见。
- 使用建议：
  - 尽量缩小同步范围，避免长时间持锁。
  - 优先使用 final 的私有锁对象，而不是 this，减少被外部代码锁定的风险。
  - 谨慎在高并发场景使用 synchronized 进行广域锁定，可能导致吞吐下降。
- 与 Lock 的比较：
  - synchronized 简单、语法级支持；Lock 提供更丰富的功能（可中断、尝试加锁、条件队列等）。
  - 在 JIT 优化与偏向锁/轻量级锁等优化下，synchronized 的性能在大部分场景已可接受。

示例（对象锁代码块）：
```
Object lock = new Object();
void inc() {
  synchronized (lock) {
    // 临界区
  }
}
```

常见问题：
- 死锁：两个线程相互持有对方需要的锁，避免策略见并发目录中的“死锁与避免”。
- 过度同步：不必要的锁导致可伸缩性差，应降低临界区粒度。
- 锁对象逃逸：锁对象被外部持有，可能破坏封装与安全性。