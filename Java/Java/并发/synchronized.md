# synchronized

## 一、核心作用：解决并发安全问题

在多线程环境下，当多个线程同时操作**共享资源**（如成员变量、静态变量）时，易出现“线程安全问题”（如数据脏读、重复修改、数据不一致等）。

`synchronized` 作为 Java 内置的“重量级锁”，核心作用是**保证同一时间只有一个线程能执行特定代码块**，从而实现共享资源的“原子操作”和线程间的“可见性”，避免并发安全问题。

核心目标：给共享资源的操作“加锁”，实现线程互斥访问。

## 二、三种使用方式及场景

`synchronized` 可作用于方法或代码块，不同使用方式对应不同的“锁对象”，需根据共享资源的类型选择。

### 1. 作用于实例方法（非静态方法）

```java

public class SyncDemo {
    // 共享资源：实例变量
    private int count = 0;
    
    // synchronized 修饰实例方法，锁对象是当前类的实例（this）
    public synchronized void increment() {
        count++; // 原子操作：读取-修改-写入
    }
}
```

**关键说明**：

- 锁对象：调用该方法的**当前对象实例（this）**；

- 效果：同一时间，多个线程访问**同一个实例**的该方法时互斥；但访问不同实例的该方法时不互斥（因为锁对象不同）；

- 适用场景：共享资源是“实例变量”（每个实例独有的资源）。

### 2. 作用于静态方法

```java

public class SyncDemo {
    // 共享资源：静态变量（属于类，所有实例共享）
    private static int staticCount = 0;
    
    // synchronized 修饰静态方法，锁对象是当前类的 Class 对象
    public static synchronized void staticIncrement() {
        staticCount++;
    }
}
```

**关键说明**：

- 锁对象：当前类的**字节码对象（SyncDemo.class）**（类级别的锁，全局唯一）；

- 效果：无论创建多少个类的实例，多个线程访问该静态方法时都互斥；

- 适用场景：共享资源是“静态变量”（类级别的共享资源）。

### 3. 作用于同步代码块（最灵活）

手动指定“锁对象”，仅对代码块内的逻辑加锁，粒度更细，性能更优（减少锁的范围）。

```java

public class SyncDemo {
    private int count = 0;
    // 手动定义锁对象（建议用 final 修饰，避免锁对象被修改）
    private final Object lock = new Object();
    
    public void increment() {
        // synchronized 代码块，锁对象是 lock
        synchronized (lock) {
            count++; // 仅对共享资源的操作加锁
        }
        // 非加锁逻辑（如日志打印）可放在外面，提高效率
        System.out.println("计数完成");
    }
}
```

**关键说明**：

- 锁对象：可自定义（如 Object 实例、this、类对象），需保证多个线程访问时使用**同一个锁对象**；

- 优势：仅锁定“操作共享资源的核心代码”，减少锁的持有时间，提升并发效率；

- 常见锁对象选择：
            锁实例变量：用 this 或自定义 Object 实例；

- 锁静态变量：用 类名.class 作为锁对象。

## 三、核心实现原理（JVM 层面）

### 1. 基础支撑：CAS 操作（Compare and Swap）

**定义**：CAS 即比较并交换，是 JVM 底层依赖 CPU 硬件指令实现的**无锁原子操作**，是 synchronized 锁升级（偏向锁→轻量级锁）及并发工具类（如 AtomicInteger）的核心底层支撑。

**核心原理**：CAS 操作包含三个核心参数——**目标变量内存地址（V）、预期值（A）、新值（B）**。执行时先读取地址 V 对应的当前值，与预期值 A 比较：

- 若一致：说明变量未被其他线程修改，原子性将 V 处的值更新为 B，返回成功；

- 若不一致：说明变量已被其他线程修改，不执行更新，返回失败（线程可选择重试或放弃）。

**核心用途**：实现无锁状态下的原子更新，避免线程阻塞/唤醒的高昂成本。在 synchronized 中，CAS 主要用于偏向锁的线程ID标记、轻量级锁的锁记录替换等场景，是实现“轻量级”锁的关键。

### 2. 锁的核心载体：对象监视器（Monitor）

`synchronized` 升级到重量级锁时依赖“对象监视器（Monitor）”实现，而 Monitor 的锁竞争原子性（如 Owner 权限获取）也间接依赖 CAS 操作。其核心依赖 JVM 底层的 **ObjectMonitor 结构体**。

Java 中“一切对象皆可锁”，因为每个对象在 JVM 内存中都关联一个 `ObjectMonitor`（监视器），其核心结构包含：

Java 中“一切对象皆可锁”，因为每个对象在 JVM 内存中都关联一个 `ObjectMonitor`（监视器），其核心结构包含：

- **Owner**：当前持有锁的线程（初始为 null）；

- **EntryList**：等待获取锁的线程队列（阻塞状态）；

- **WaitSet**：调用 `wait()` 后等待被唤醒的线程队列。

**加锁/解锁流程（核心：独占** **锁** **的原子性保障）**：

Monitor实现独占的关键是“线程获取Owner权限”的操作是**原子性的**，由JVM底层依赖CPU指令（如CAS）保证，不会出现多个线程同时将自己设为Owner的情况，具体流程如下：

1. 线程进入同步代码时，触发“尝试获取Owner权限”的原子操作（底层通过CAS实现）；

2. 该原子操作会判断Owner是否为null：若为null，则**原子性地**将Owner设为当前线程（加锁成功），此过程不会被其他线程打断；

3. 若Owner已被其他线程占用，原子操作直接返回失败，当前线程进入EntryList阻塞，无法修改Owner；

4. 线程退出同步代码时，同样通过原子操作释放Owner（设为null），并唤醒EntryList中等待的线程，唤醒的线程需重新竞争锁（重复步骤1-3）。

关键保障：“判断Owner是否为null + 设为当前线程”是原子操作，由CPU硬件指令支撑，绝对不会出现两个线程同时将Owner设为自己的情况，这是独占性的核心前提。

### 2. 锁优化：从重量级到轻量级（JDK 1.6+）

早期 `synchronized` 是“重量级锁”（依赖操作系统内核态互斥，切换成本高），JDK 1.6 后引入“锁升级”机制，根据并发强度动态优化，不同锁的实现方式及与Monitor的关联如下：

1. **无锁**：无线程竞争时，不加锁；
实现：对象头Mark Word仅存储哈希码、分代年龄等基础信息，无锁标识，线程可直接操作共享资源。

2. **偏向锁**：单线程重复加锁时，仅记录线程 ID，避免 CAS 操作；
实现：首次加锁时，通过一次CAS将当前线程ID写入对象头Mark Word，设置偏向锁标识；后续同一线程加锁时，仅需对比线程ID，无需CAS和Monitor。
与Monitor：不使用Monitor，仅依赖对象头标记。

3. **轻量级锁**：少量线程竞争时，用 CAS 尝试获取锁，避免阻塞；
实现：线程加锁前先在栈帧中创建“锁记录”（存储对象头Mark Word副本），然后通过CAS将对象头Mark Word替换为锁记录地址，设置轻量级锁标识；竞争时线程自旋重试（不阻塞）。
与Monitor：不使用Monitor，依赖对象头和CAS自旋，减少内核态切换成本。

4. **重量级锁**：大量线程竞争时，升级为 Monitor 锁，线程阻塞；
实现：当轻量级锁自旋失败（说明竞争激烈，自旋浪费CPU），则膨胀为重量级锁，将对象头Mark Word指向Monitor地址，设置重量级锁标识；此时线程竞争需通过Monitor的EntryList队列阻塞等待。
与Monitor：核心依赖Monitor实现独占，这是轻量级锁升级为重量级锁的核心原因——竞争激烈时，自旋效率低，需Monitor的阻塞机制协调。

关键答疑：轻量级锁确实不用Monitor，靠CAS和对象头实现；只有升级到重量级锁时才会关联Monitor。无论自定义锁对象还是默认锁对象（this/类对象），锁升级逻辑一致，仅在重量级锁阶段才使用对应对象关联的Monitor。

优化后，synchronized 性能已接近 Lock 类，日常开发无需过度规避。

## 四、关键特性

1. **原子性**：同步代码块内的操作视为一个整体，要么全部执行，要么全部不执行（避免中间状态被其他线程访问）；

2. **可见性**：解锁时，线程会将工作内存中的修改同步到主内存；加锁时，线程会从主内存重新读取最新数据（避免脏读）；

3. **可重入性**：同一线程可多次获取同一把锁（如递归调用同步方法），不会出现死锁；

4. **非公平性**：解锁时，JVM 随机唤醒 EntryList 中的一个线程，不保证等待时间最长的线程先获取锁。

## 五、使用注意事项（避坑指南）

- **锁对象不能为 null**：若锁对象是 null，JVM 会抛出 `NullPointerException`（建议用 final 修饰锁对象，避免被赋值为 null）；

- **避免锁粒度过粗**：不要给整个方法加锁（尤其是包含大量非共享操作的方法），应仅对“操作共享资源的核心代码块”加锁，减少锁持有时间；

- **避免锁对象频繁变动**：若锁对象是普通变量（非 final），被修改后会导致不同线程持有的锁对象不同，失去互斥效果；

- **静态方法与实例方法锁不互斥**：静态方法锁是“类对象”，实例方法锁是“this”，两者锁对象不同，同时调用不会互斥；

- **避免死锁**：多个线程交叉获取多把锁时易死锁（如线程1持有锁A等锁B，线程2持有锁B等锁A），需保证所有线程按“相同顺序”获取锁。

## 六、总结

`synchronized` 是 Java 最基础的并发安全保障机制，核心是通过“对象监视器”实现线程互斥，具备原子性、可见性、可重入性。

|使用方式|锁对象|适用场景|
|---|---|---|
|实例方法|this（当前实例）|共享资源为实例变量|
|静态方法|类对象（XXX.class）|共享资源为静态变量|
|同步代码块|自定义对象（this/类对象/Object）|需细粒度锁，提升性能|
日常开发中，优先根据共享资源类型选择使用方式，配合 JDK 自带的锁优化，可满足大部分并发场景需求。


> （注：文档部分内容可能由 AI 生成）