# Java 线程基础详解

## 定义与作用

### 什么是线程
线程（Thread）是程序执行流的最小单元，是进程中的一个实体。一个进程可以包含多个线程，这些线程共享进程的资源，但拥有各自的执行栈和程序计数器。

### 线程的主要作用
1. **提高程序响应性**：避免界面冻结，提升用户体验
2. **充分利用多核CPU**：并行处理任务，提高系统吞吐量
3. **简化编程模型**：将复杂任务分解为多个并发执行的子任务
4. **异步处理**：后台执行耗时操作，不阻塞主线程

## 线程创建方式

### 1. 继承 Thread 类
```java
// 继承 Thread 类创建线程
class MyThread extends Thread {
    @Override
    public void run() {
        System.out.println("线程执行: " + Thread.currentThread().getName());
    }
}

// 使用示例
MyThread thread = new MyThread();
thread.start(); // 启动线程
```

**优点**：
- 代码简单直观
- 可以直接调用 Thread 类的方法

**缺点**：
- 由于 Java 是单继承，继承 Thread 类后不能再继承其他类
- 不符合面向对象的设计原则

### 2. 实现 Runnable 接口
```java
// 实现 Runnable 接口创建线程
class MyRunnable implements Runnable {
    @Override
    public void run() {
        System.out.println("线程执行: " + Thread.currentThread().getName());
    }
}

// 使用示例
MyRunnable runnable = new MyRunnable();
Thread thread = new Thread(runnable);
thread.start();
```

**优点**：
- 可以继承其他类，更符合面向对象设计
- 多个线程可以共享同一个 Runnable 实例
- 线程池等工具类通常接受 Runnable 接口

**缺点**：
- 不能直接获取线程执行结果

### 3. 实现 Callable 接口（带返回值）
```java
import java.util.concurrent.Callable;
import java.util.concurrent.FutureTask;

// 实现 Callable 接口创建线程
class MyCallable implements Callable<String> {
    @Override
    public String call() throws Exception {
        Thread.sleep(1000); // 模拟耗时操作
        return "线程执行结果: " + Thread.currentThread().getName();
    }
}

// 使用示例
MyCallable callable = new MyCallable();
FutureTask<String> futureTask = new FutureTask<>(callable);
Thread thread = new Thread(futureTask);
thread.start();

// 获取执行结果
String result = futureTask.get(); // 阻塞等待结果
System.out.println(result);
```

**优点**：
- 可以获取线程执行结果
- 支持异常抛出
- 适合需要返回值的异步任务

**缺点**：
- 使用相对复杂
- 需要处理 Future 和异常

## 线程状态与生命周期

### 线程状态详解

#### 1. NEW（新建状态）
线程被创建但尚未启动。
```java
Thread thread = new Thread(() -> {});
System.out.println(thread.getState()); // NEW
```

#### 2. RUNNABLE（可运行状态）
线程正在运行或等待 CPU 时间片。
```java
Thread thread = new Thread(() -> {
    while (true) {
        // 运行中或等待CPU调度
    }
});
thread.start();
System.out.println(thread.getState()); // RUNNABLE
```

#### 3. BLOCKED（阻塞状态）
线程等待获取监视器锁（synchronized）。
```java
Object lock = new Object();

Thread thread1 = new Thread(() -> {
    synchronized (lock) {
        try {
            Thread.sleep(5000); // 持有锁5秒
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
});

Thread thread2 = new Thread(() -> {
    synchronized (lock) {
        // 等待thread1释放锁
    }
});

thread1.start();
Thread.sleep(100); // 确保thread1先获取锁
thread2.start();
Thread.sleep(100); // 确保thread2开始执行
System.out.println(thread2.getState()); // BLOCKED
```

#### 4. WAITING（等待状态）
线程无限期等待其他线程的通知。
```java
Thread thread = new Thread(() -> {
    synchronized (this) {
        try {
            this.wait(); // 无限期等待
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
});

thread.start();
Thread.sleep(100);
System.out.println(thread.getState()); // WAITING
```

#### 5. TIMED_WAITING（计时等待状态）
线程在指定时间内等待。
```java
Thread thread = new Thread(() -> {
    try {
        Thread.sleep(5000); // 睡眠5秒
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
});

thread.start();
Thread.sleep(100);
System.out.println(thread.getState()); // TIMED_WAITING
```

#### 6. TERMINATED（终止状态）
线程执行完毕。
```java
Thread thread = new Thread(() -> {
    // 简单任务
});

thread.start();
thread.join(); // 等待线程结束
System.out.println(thread.getState()); // TERMINATED
```

### 线程状态转换图
```
NEW → start() → RUNNABLE
RUNNABLE → run()结束 → TERMINATED
RUNNABLE → synchronized阻塞 → BLOCKED
RUNNABLE → wait() → WAITING
RUNNABLE → sleep()/join() → TIMED_WAITING
WAITING → notify()/notifyAll() → RUNNABLE
TIMED_WAITING → 超时/中断 → RUNNABLE
BLOCKED → 获取锁 → RUNNABLE
```

## 线程调度与优先级

### 线程优先级
Java 线程有10个优先级（1-10），默认优先级为5。

```java
Thread thread1 = new Thread(() -> {});
Thread thread2 = new Thread(() -> {});

// 设置优先级
thread1.setPriority(Thread.MAX_PRIORITY); // 10
thread2.setPriority(Thread.MIN_PRIORITY); // 1

// 获取优先级
System.out.println("thread1优先级: " + thread1.getPriority());
System.out.println("thread2优先级: " + thread2.getPriority());
```

**注意**：线程优先级只是给调度器的建议，具体调度由操作系统决定。

### 线程调度策略
1. **时间片轮转**：每个线程分配固定时间片
2. **优先级调度**：高优先级线程优先执行
3. **抢占式调度**：高优先级线程可以抢占低优先级线程的CPU时间

## 线程常用方法

### 基本控制方法
```java
Thread thread = new Thread(() -> {
    System.out.println("线程执行中...");
});

// 启动线程
thread.start();

// 等待线程结束
thread.join();

// 中断线程
thread.interrupt();

// 检查中断状态
if (Thread.interrupted()) {
    // 处理中断
}

// 睡眠当前线程
Thread.sleep(1000);

// 让出CPU时间片
Thread.yield();
```

### 线程信息获取
```java
Thread thread = Thread.currentThread();

System.out.println("线程ID: " + thread.getId());
System.out.println("线程名称: " + thread.getName());
System.out.println("线程状态: " + thread.getState());
System.out.println("线程优先级: " + thread.getPriority());
System.out.println("是否存活: " + thread.isAlive());
System.out.println("是否守护线程: " + thread.isDaemon());
System.out.println("是否中断: " + thread.isInterrupted());
```

## 守护线程

守护线程（Daemon Thread）是为其他线程提供服务的线程，当所有非守护线程结束时，守护线程会自动终止。

```java
Thread daemonThread = new Thread(() -> {
    while (true) {
        System.out.println("守护线程运行中...");
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            break;
        }
    }
});

daemonThread.setDaemon(true); // 设置为守护线程
daemonThread.start();

// 主线程结束后，守护线程会自动终止
Thread.sleep(3000);
System.out.println("主线程结束");
```

## 线程组

线程组（ThreadGroup）用于管理一组线程，可以统一进行中断、设置优先级等操作。

```java
// 创建线程组
ThreadGroup group = new ThreadGroup("MyThreadGroup");

// 在线程组中创建线程
Thread thread1 = new Thread(group, () -> {
    System.out.println("线程1在组中执行");
});

Thread thread2 = new Thread(group, () -> {
    System.out.println("线程2在组中执行");
});

thread1.start();
thread2.start();

// 获取线程组信息
System.out.println("活动线程数: " + group.activeCount());
System.out.println("线程组名称: " + group.getName());

// 中断线程组中所有线程
group.interrupt();
```

## 最佳实践

### 线程命名规范
```java
// 为线程设置有意义的名称
Thread workerThread = new Thread(() -> {}, "Worker-Thread-1");
Thread ioThread = new Thread(() -> {}, "IO-Thread-1");
```

### 异常处理
```java
Thread thread = new Thread(() -> {
    try {
        // 业务逻辑
    } catch (Exception e) {
        System.err.println("线程执行异常: " + e.getMessage());
        // 记录日志或进行其他处理
    }
});

// 设置未捕获异常处理器
thread.setUncaughtExceptionHandler((t, e) -> {
    System.err.println("线程 " + t.getName() + " 发生未捕获异常: " + e.getMessage());
});
```

### 资源清理
```java
Thread thread = new Thread(() -> {
    try {
        // 使用资源
    } finally {
        // 确保资源被释放
        // 关闭文件、数据库连接等
    }
});
```

## 常见问题与解决方案

### 1. 线程安全问题
**问题**：多个线程同时访问共享数据可能导致数据不一致。

**解决方案**：
- 使用 synchronized 关键字
- 使用 Lock 接口的实现类
- 使用线程安全的数据结构
- 使用 volatile 关键字保证可见性

### 2. 死锁问题
**问题**：多个线程相互等待对方释放锁。

**解决方案**：
- 避免嵌套锁
- 使用定时锁尝试
- 按固定顺序获取锁
- 使用死锁检测工具

### 3. 性能问题
**问题**：线程创建和销毁开销大，上下文切换频繁。

**解决方案**：
- 使用线程池管理线程
- 合理设置线程数量
- 避免不必要的同步
- 使用无锁数据结构

## 总结

Java 线程是并发编程的基础，理解线程的创建方式、生命周期、状态转换对于编写高质量的并发程序至关重要。在实际开发中，应该根据具体需求选择合适的线程创建方式，遵循最佳实践，注意线程安全和性能优化。

最后更新时间：2024-01-15

