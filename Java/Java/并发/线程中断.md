# 线程中断与取消

## 定义与作用

线程中断（Thread Interruption）是Java中一种协作式的线程停止机制，它允许一个线程向另一个线程发送中断信号，但被中断的线程可以选择是否响应以及如何响应这个中断。

### 中断机制的特点
- **协作式**：中断不会强制停止线程，需要线程主动检查并响应
- **安全**：相比强制停止（Thread.stop()），中断机制更加安全
- **灵活**：线程可以根据业务需求决定如何响应中断

## 中断机制的核心API

### 1. 中断相关方法

```java
public class Thread {
    // 中断目标线程
    public void interrupt();
    
    // 检查当前线程是否被中断（不清除中断状态）
    public boolean isInterrupted();
    
    // 检查当前线程是否被中断（清除中断状态）
    public static boolean interrupted();
}
```

### 2. 中断状态与异常

```java
public class InterruptedException extends Exception {
    // 当线程在阻塞状态（如sleep、wait、join）中被中断时抛出
}
```

## 中断的使用方式

### 1. 基本中断检查

```java
public class BasicInterruption {
    public static void main(String[] args) throws InterruptedException {
        Thread worker = new Thread(() -> {
            while (!Thread.currentThread().isInterrupted()) {
                // 执行任务
                System.out.println("Working...");
                
                // 模拟工作
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    // 捕获中断异常，退出循环
                    System.out.println("线程被中断，准备退出");
                    Thread.currentThread().interrupt(); // 恢复中断状态
                    break;
                }
            }
            System.out.println("线程已停止");
        });
        
        worker.start();
        
        // 让工作线程运行3秒后中断
        Thread.sleep(3000);
        worker.interrupt();
        
        worker.join();
        System.out.println("主线程结束");
    }
}
```

### 2. 复杂任务的中断处理

```java
public class ComplexTaskInterruption {
    private volatile boolean shutdownRequested = false;
    
    public void startTask() {
        Thread worker = new Thread(() -> {
            try {
                while (!shutdownRequested && !Thread.currentThread().isInterrupted()) {
                    // 阶段1：数据准备
                    if (!prepareData()) {
                        break;
                    }
                    
                    // 阶段2：数据处理
                    if (!processData()) {
                        break;
                    }
                    
                    // 阶段3：结果保存
                    if (!saveResults()) {
                        break;
                    }
                    
                    // 短暂休息
                    Thread.sleep(500);
                }
            } catch (InterruptedException e) {
                System.out.println("任务被中断，进行清理工作");
                Thread.currentThread().interrupt();
            } finally {
                cleanup(); // 确保资源清理
            }
        });
        
        worker.start();
    }
    
    private boolean prepareData() {
        // 检查中断状态
        if (Thread.currentThread().isInterrupted()) {
            System.out.println("数据准备阶段被中断");
            return false;
        }
        
        // 模拟数据准备
        System.out.println("准备数据...");
        return true;
    }
    
    private boolean processData() {
        // 长时间运行的任务需要频繁检查中断
        for (int i = 0; i < 100; i++) {
            if (Thread.currentThread().isInterrupted()) {
                System.out.println("数据处理阶段被中断");
                return false;
            }
            
            // 模拟数据处理
            try {
                Thread.sleep(10);
            } catch (InterruptedException e) {
                System.out.println("数据处理被中断");
                Thread.currentThread().interrupt();
                return false;
            }
        }
        
        System.out.println("数据处理完成");
        return true;
    }
    
    private boolean saveResults() {
        // 检查中断状态
        if (Thread.currentThread().isInterrupted()) {
            System.out.println("结果保存阶段被中断");
            return false;
        }
        
        // 模拟结果保存（可能涉及I/O操作）
        System.out.println("保存结果...");
        return true;
    }
    
    private void cleanup() {
        System.out.println("执行清理工作...");
        // 释放资源、关闭连接等
    }
    
    public void shutdown() {
        shutdownRequested = true;
    }
}
```

## 阻塞操作的中断处理

### 1. 可中断的阻塞操作

```java
public class InterruptibleBlockingOperations {
    
    // sleep方法的中断处理
    public void sleepWithInterruption() {
        try {
            Thread.sleep(5000); // 可被中断的阻塞
        } catch (InterruptedException e) {
            System.out.println("sleep被中断");
            Thread.currentThread().interrupt(); // 恢复中断状态
        }
    }
    
    // wait方法的中断处理
    public void waitWithInterruption(Object lock) {
        synchronized (lock) {
            try {
                lock.wait(); // 可被中断的阻塞
            } catch (InterruptedException e) {
                System.out.println("wait被中断");
                Thread.currentThread().interrupt();
            }
        }
    }
    
    // join方法的中断处理
    public void joinWithInterruption(Thread otherThread) {
        try {
            otherThread.join(); // 可被中断的阻塞
        } catch (InterruptedException e) {
            System.out.println("join被中断");
            Thread.currentThread().interrupt();
        }
    }
    
    // I/O操作的中断处理（通过关闭底层资源）
    public void interruptibleIO() {
        ServerSocket serverSocket = null;
        try {
            serverSocket = new ServerSocket(8080);
            
            // 传统方式：accept()不可中断
            // Socket socket = serverSocket.accept();
            
            // 改进方式：使用超时和中断检查
            serverSocket.setSoTimeout(1000); // 设置超时
            
            while (!Thread.currentThread().isInterrupted()) {
                try {
                    Socket socket = serverSocket.accept();
                    // 处理连接
                    handleConnection(socket);
                } catch (SocketTimeoutException e) {
                    // 超时，继续检查中断状态
                    continue;
                }
            }
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            if (serverSocket != null) {
                try {
                    serverSocket.close(); // 关闭资源来中断阻塞
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
    }
    
    private void handleConnection(Socket socket) {
        // 处理连接逻辑
    }
}
```

### 2. 不可中断阻塞的处理策略

```java
public class NonInterruptibleBlockingHandling {
    
    // 方案1：使用超时机制
    public void withTimeout() {
        ExecutorService executor = Executors.newSingleThreadExecutor();
        
        Future<?> future = executor.submit(() -> {
            // 执行可能阻塞的操作
            performBlockingOperation();
        });
        
        try {
            // 设置超时时间
            future.get(5, TimeUnit.SECONDS);
        } catch (TimeoutException e) {
            // 超时处理
            future.cancel(true); // 尝试中断
            System.out.println("操作超时，已取消");
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            executor.shutdown();
        }
    }
    
    // 方案2：使用专门的线程处理阻塞操作
    public void withDedicatedThread() {
        final AtomicReference<Thread> blockingThread = new AtomicReference<>();
        final CountDownLatch latch = new CountDownLatch(1);
        
        Thread worker = new Thread(() -> {
            blockingThread.set(Thread.currentThread());
            latch.countDown();
            
            // 执行阻塞操作
            performBlockingOperation();
        });
        
        worker.start();
        
        try {
            latch.await(); // 等待线程启动
            
            // 在另一个线程中监控和中断
            Thread monitor = new Thread(() -> {
                try {
                    Thread.sleep(5000); // 监控5秒
                    
                    // 如果阻塞线程还在运行，尝试中断
                    Thread thread = blockingThread.get();
                    if (thread != null && thread.isAlive()) {
                        System.out.println("检测到长时间阻塞，尝试中断");
                        thread.interrupt();
                    }
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
            });
            
            monitor.start();
            worker.join();
            monitor.join();
            
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
    }
    
    private void performBlockingOperation() {
        // 模拟不可中断的阻塞操作
        synchronized (this) {
            try {
                this.wait(); // 传统的wait()，需要notify()来唤醒
            } catch (InterruptedException e) {
                System.out.println("阻塞操作被中断");
                Thread.currentThread().interrupt();
            }
        }
    }
}
```

## 中断的最佳实践

### 1. 正确的异常处理

```java
public class ProperExceptionHandling {
    
    // 错误做法：吞掉中断异常
    public void wrongWay() {
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            // 错误：没有恢复中断状态
            System.out.println("被中断，但继续执行");
        }
    }
    
    // 正确做法1：恢复中断状态并退出
    public void correctWay1() {
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            // 正确：恢复中断状态
            Thread.currentThread().interrupt();
            return; // 退出方法
        }
    }
    
    // 正确做法2：抛出运行时异常
    public void correctWay2() {
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            // 正确：抛出运行时异常
            Thread.currentThread().interrupt();
            throw new RuntimeException("任务被中断", e);
        }
    }
    
    // 正确做法3：对于可检查异常，重新抛出
    public void correctWay3() throws InterruptedException {
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            // 正确：清理后重新抛出
            cleanup();
            throw e;
        }
    }
    
    private void cleanup() {
        // 清理资源
    }
}
```

### 2. 中断策略设计

```java
public class InterruptionPolicy {
    
    // 策略接口
    public interface InterruptibleTask {
        void run() throws InterruptedException;
    }
    
    // 任务执行器
    public class TaskExecutor {
        private final ExecutorService executor;
        
        public TaskExecutor(int poolSize) {
            this.executor = Executors.newFixedThreadPool(poolSize);
        }
        
        public <T> Future<T> submit(Callable<T> task) {
            return executor.submit(task);
        }
        
        public void execute(InterruptibleTask task) {
            executor.execute(() -> {
                try {
                    task.run();
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
            });
        }
        
        public void shutdown() {
            executor.shutdown();
            try {
                if (!executor.awaitTermination(5, TimeUnit.SECONDS)) {
                    executor.shutdownNow(); // 强制中断所有任务
                }
            } catch (InterruptedException e) {
                executor.shutdownNow();
                Thread.currentThread().interrupt();
            }
        }
    }
    
    // 使用示例
    public void usageExample() {
        TaskExecutor executor = new TaskExecutor(2);
        
        // 提交可中断任务
        executor.execute(() -> {
            while (!Thread.currentThread().isInterrupted()) {
                // 执行任务
                processData();
                
                // 检查中断状态
                if (Thread.currentThread().isInterrupted()) {
                    break;
                }
            }
        });
        
        // 5秒后关闭执行器
        new Thread(() -> {
            try {
                Thread.sleep(5000);
                executor.shutdown();
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }).start();
    }
    
    private void processData() {
        // 模拟数据处理
        try {
            Thread.sleep(100);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
    }
}
```

## 与Future取消的集成

### 1. Future取消机制

```java
public class FutureCancellation {
    
    public void futureCancelExample() {
        ExecutorService executor = Executors.newSingleThreadExecutor();
        
        Future<String> future = executor.submit(() -> {
            // 长时间运行的任务
            for (int i = 0; i < 100; i++) {
                // 检查中断状态
                if (Thread.currentThread().isInterrupted()) {
                    System.out.println("任务被取消，当前进度：" + i);
                    return "任务被取消";
                }
                
                // 模拟工作
                try {
                    Thread.sleep(100);
                } catch (InterruptedException e) {
                    System.out.println("任务被中断");
                    Thread.currentThread().interrupt();
                    return "任务被中断";
                }
            }
            
            return "任务完成";
        });
        
        // 3秒后取消任务
        new Thread(() -> {
            try {
                Thread.sleep(3000);
                boolean cancelled = future.cancel(true); // true表示尝试中断
                System.out.println("取消请求结果：" + cancelled);
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }).start();
        
        try {
            String result = future.get();
            System.out.println("任务结果：" + result);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        } catch (ExecutionException e) {
            System.out.println("任务执行异常：" + e.getCause());
        } catch (CancellationException e) {
            System.out.println("任务被取消");
        } finally {
            executor.shutdown();
        }
    }
    
    // 批量任务取消
    public void batchCancellation() {
        ExecutorService executor = Executors.newFixedThreadPool(3);
        List<Future<?>> futures = new ArrayList<>();
        
        // 提交多个任务
        for (int i = 0; i < 5; i++) {
            final int taskId = i;
            Future<?> future = executor.submit(() -> {
                try {
                    System.out.println("任务" + taskId + "开始执行");
                    Thread.sleep(5000); // 模拟长时间任务
                    System.out.println("任务" + taskId + "完成");
                } catch (InterruptedException e) {
                    System.out.println("任务" + taskId + "被中断");
                    Thread.currentThread().interrupt();
                }
            });
            futures.add(future);
        }
        
        // 2秒后取消所有任务
        new Thread(() -> {
            try {
                Thread.sleep(2000);
                System.out.println("开始取消所有任务");
                
                for (Future<?> future : futures) {
                    future.cancel(true); // 尝试中断
                }
                
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }).start();
        
        // 等待所有任务完成或取消
        for (Future<?> future : futures) {
            try {
                future.get();
            } catch (CancellationException e) {
                System.out.println("任务被取消");
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        
        executor.shutdown();
    }
}
```

## 避免使用已废弃的方法

### 1. Thread.stop() 的问题

```java
public class AvoidDeprecatedMethods {
    
    // Thread.stop() 的问题示例
    public void whyStopIsBad() {
        // 错误示例：使用stop()
        Thread badThread = new Thread(() -> {
            synchronized (this) {
                // 临界区操作
                updateSharedResource();
            }
        });
        
        badThread.start();
        
        // 错误：使用stop()可能导致资源不一致
        // badThread.stop(); // 已废弃，不要使用
        
        // 正确：使用中断机制
        badThread.interrupt();
    }
    
    // Thread.suspend() 和 Thread.resume() 的问题
    public void whySuspendResumeAreBad() {
        Thread problematicThread = new Thread(() -> {
            synchronized (this) {
                // 持有锁
                System.out.println("持有锁");
                
                // 如果在这里被suspend()，锁不会被释放
                // 其他线程将无法获取这个锁
            }
        });
        
        problematicThread.start();
        
        // 错误：使用suspend()可能导致死锁
        // problematicThread.suspend(); // 已废弃，不要使用
        
        // 正确：使用wait/notify或条件变量
    }
    
    private void updateSharedResource() {
        // 更新共享资源
    }
}
```

## 总结

### 中断机制的核心要点

1. **协作性质**：中断是请求而非命令，线程自愿响应
2. **状态检查**：通过 `isInterrupted()` 或捕获 `InterruptedException` 来检测中断
3. **资源清理**：响应中断时确保资源正确释放
4. **状态恢复**：捕获 `InterruptedException` 后通常需要恢复中断状态

### 最佳实践清单

- ✅ 在循环和长时间操作中频繁检查中断状态
- ✅ 正确处理 `InterruptedException`，不要吞掉异常
- ✅ 使用 `Future.cancel(true)` 来中断执行中的任务
- ✅ 避免使用已废弃的 `stop()`、`suspend()` 等方法
- ✅ 设计可中断的任务，提供清晰的取消策略
- ✅ 对于不可中断的阻塞操作，使用超时或专用线程

### 常见陷阱

- ❌ 忽略 `InterruptedException` 或不恢复中断状态
- ❌ 在不可中断的阻塞操作中无法及时响应中断
- ❌ 过度使用中断导致代码复杂化
- ❌ 混合使用中断和自定义停止标志

通过合理使用中断机制，可以构建出既安全又响应灵敏的多线程应用程序。

---

最后更新时间：2024-12-19