## CountDownLatch：一次性门闩
- 定义与作用
  - 内部维护一个计数（初始 N）。当计数归零时，所有在 await() 上等待的线程被唤醒继续执行。
  - 典型场景：主线程等待 N 个子任务完成；或等待多个外部事件到达。
- 使用方法
  - 构造：new CountDownLatch(n)
  - 计数减一：countDown()（常放 finally 里，确保异常也能减数）
  - 等待：await() / await(timeout, unit)
```java
CountDownLatch latch = new CountDownLatch(N);
ExecutorService pool = Executors.newFixedThreadPool(N);
for (int i = 0; i < N; i++) {
  pool.submit(() -> {
    try {
      // doWork();
    } finally {
      latch.countDown();
    }
  });
}
boolean ok = latch.await(30, TimeUnit.SECONDS);
if (!ok) {
  // 超时处理：记录报警或补偿
}
pool.shutdown();
```
- 实现原理（简要）
  - 基于 AQS（AbstractQueuedSynchronizer）的“共享模式”实现。
  - await() 通过 AQS 的 acquireSharedInterruptibly 进行阻塞队列排队；countDown() 通过 releaseShared 更新状态，当计数为 0 时唤醒等待队列。
  - 不可重置（one-shot）：内部计数只减不增，完成后即失效。
- 优缺点
  - 优点：API 简单、语义清晰；非常适合“一次性等待一组任务”。
  - 缺点：不可复用；计数设置错误或异常路径未 countDown 会导致永久等待；无法表达“阶段”与动态参与者。
- 适用示例
  - 启动阶段：等待多个模块初始化完成后统一对外服务。
  - 聚合任务：并行执行 N 个子任务并等待结果收集。

## CyclicBarrier：可循环栅栏
- 定义与作用
  - 允许固定数量的线程在栅栏处互相等待，直到全部到齐后一起进入下一阶段，且栅栏可复用（循环）。
  - 典型场景：分阶段计算/批处理，所有参与线程在每一阶段都要步调一致。
- 使用方法
  - 构造：new CyclicBarrier(parties) 或 new CyclicBarrier(parties, barrierAction)
  - 等待：await() / await(timeout, unit)；支持中断与超时
  - 其他：reset()（慎用，会打断当前等待并标记栅栏损坏）
```java
CyclicBarrier barrier = new CyclicBarrier(N, () -> {
  // 到齐后统一执行的阶段动作，保持轻量
});
for (int i = 0; i < N; i++) {
  new Thread(() -> {
    try {
      // phase 1
      barrier.await();
      // phase 2
      barrier.await();
    } catch (InterruptedException | BrokenBarrierException e) {
      Thread.currentThread().interrupt();
    }
  }).start();
}
```
- 实现原理（简要）
  - 基于 ReentrantLock + Condition 管理“下一代”（Generation）与“未到达计数”。
  - 每次 await() 都会减少未到达计数；当计数为 0：执行 barrierAction（若配置），然后翻转到下一代并唤醒所有等待线程。
  - 若发生中断/超时，会将当前栅栏标记为“损坏”（Broken），后续 await 抛 BrokenBarrierException。
- 优缺点
  - 优点：可复用；语义明确地表达“每阶段所有线程到齐再前进”。
  - 缺点：参与者数量固定；出现超时/中断易导致栅栏损坏，处理复杂；barrierAction 若阻塞会拖累所有线程。
- 适用示例
  - 多轮迭代的并行算法（如分布式迭代的本地并行步调）。
  - 分批处理流水线中每批次需要同步的阶段边界。

## Semaphore：并发许可控制
- 定义与作用
  - 控制同时访问某资源或执行某段代码的并发数量（permits）。常用于限流、连接池、对象池等。
- 使用方法
  - 构造：new Semaphore(permits) 或 new Semaphore(permits, fair)
  - 获取许可：acquire() / acquire(n)；tryAcquire() / tryAcquire(timeout, unit)
  - 释放许可：release() / release(n)
```java
Semaphore sem = new Semaphore(10, true); // 公平模式：更公平但吞吐略低
ExecutorService pool = Executors.newCachedThreadPool();
pool.submit(() -> {
  boolean ok = false;
  try {
    ok = sem.tryAcquire(500, TimeUnit.MILLISECONDS);
    if (!ok) {
      // 限流拒绝或降级
      return;
    }
    // doLimitedWork();
  } catch (InterruptedException e) {
    Thread.currentThread().interrupt();
  } finally {
    if (ok) sem.release(); // 避免许可泄漏
  }
});
```
- 实现原理（简要）
  - 基于 AQS 的共享计数实现；permits 作为共享资源计数。
  - acquire() 尝试 CAS 减少许可；不足则入队阻塞；release() 增加许可并唤醒等待线程。
  - 支持公平/非公平模式：公平模式基于队列顺序唤醒，非公平模式可能“插队”提升吞吐。
- 优缺点
  - 优点：限流语义清晰；支持公平性；支持超时与非阻塞尝试；适合资源池。
  - 缺点：需要严格保证 release 对称，异常路径容易泄漏许可；许可数选择与降级策略需要经验。
- 适用示例
  - 外部服务调用限流；数据库连接池并发上限；热点代码段并发控制。

## Phaser：分阶段栅栏（支持动态参与者）
- 定义与作用
  - 用于多阶段的并发任务同步；与 CyclicBarrier 类似但更灵活：可动态注册/注销参与者，支持多个阶段推进与自定义结束条件。
- 使用方法
  - 构造：new Phaser() 或 new Phaser(initialParties)
  - 注册/注销：register() / bulkRegister(n) / arriveAndDeregister()
  - 阶段推进：arrive() / arriveAndAwaitAdvance() / awaitAdvance(phase)
  - 自定义结束：重写 onAdvance(int phase, int registeredParties)
```java
Phaser phaser = new Phaser();
phaser.bulkRegister(N);
for (int i = 0; i < N; i++) {
  new Thread(() -> {
    // 阶段 0：准备
    phaser.arriveAndAwaitAdvance();
    // 阶段 1：执行
    phaser.arriveAndAwaitAdvance();
    // 阶段 2：收尾并退出
    phaser.arriveAndDeregister();
  }).start();
}
// 主线程可监控阶段：
int current = phaser.getPhase();
```
- 实现原理（简要）
  - 内部以一个 64 位状态记录 phase（高位）、registered parties 与 unarrived（低位）。
  - 每次 arrive 将 unarrived 递减，减至 0 时“推进到下一阶段”（phase++），并唤醒等待线程。
  - register / arriveAndDeregister 动态调整参与者数量；可通过重写 onAdvance 控制任务在某阶段结束。
  - 大量参与者时可采用分层结构（树形 Phaser）降低唤醒与竞争开销。
- 优缺点
  - 优点：比 CyclicBarrier 更灵活，支持动态参与者与多阶段推进；易于表达复杂流水线。
  - 缺点：API 更复杂；错误使用（未 arrive 或未 deregister）可能导致推进阻塞；调试难度较高。
- 适用示例
  - 多阶段流水线（准备/执行/校验/收尾等）；参与者数量在执行过程中动态变化的任务。

## 四者对比与选型建议
- 语义维度
  - CountDownLatch：一次性单向等待。主线程“等别人”。不支持复用与阶段。
  - CyclicBarrier：阶段内双向等待。参与线程“互相等”。固定参与者，阶段可循环。
  - Semaphore：数量控制。谁拿到许可谁执行，与“等齐”无关。
  - Phaser：多阶段 + 动态参与者的“互等”，比栅栏更灵活。
- 能力维度
  - 可复用：CyclicBarrier、Phaser；CountDownLatch 不可；Semaphore 天然复用（许可模型）。
  - 动态参与者：只有 Phaser 支持；CyclicBarrier/CountDownLatch 固定。
  - 超时/中断：四者都支持；但 CyclicBarrier 超时/中断会 Broken。
  - 公平性：Semaphore 可选公平；其他不涉及公平队列语义。
- 性能与复杂度
  - 简单与稳健：CountDownLatch（一次性）
  - 阶段步调一致：CyclicBarrier（注意损坏处理）
  - 吞吐与限流：Semaphore（非公平更高吞吐）
  - 灵活度与表达力：Phaser（复杂度最高）
- 选型建议
  - 一次性等待一组任务：优先 CountDownLatch。
  - 每阶段到齐再前进，参与者固定：CyclicBarrier。
  - 并发数量/资源访问上限控制：Semaphore。
  - 多阶段且参与者动态变化：Phaser。

## 与其他并发组件的关系与组合
- 与线程池/Executor：
  - CountDownLatch 非常适合搭配线程池提交批量任务，并在主线程 await。
  - Semaphore 可作为任务提交前的限流开关，或围绕共享资源的访问包裹。
  - CyclicBarrier/Phaser 适合固定线程集合的分阶段计算（通常创建固定数量线程参与）。
- 与 Future/CompletableFuture：
  - CountDownLatch 可替代“等待多个 Future 完成”的场景；CompletableFuture.allOf 是更高层封装。
- 与锁/synchronized：
  - Semaphore 控制并发数量，不负责互斥的数据一致性；必要时仍需使用锁保护共享状态。
- 与 Exchanger/SynchronousQueue：
  - Exchanger 用于两个线程交换数据；SynchronousQueue 用于“移交式”任务传递；它们不承担“到齐”或“限流”的职责。

## 常见坑与最佳实践清单
- 通用
  - 优先使用带超时的 await/tryAcquire，避免永久阻塞。
  - 将 countDown()/release()/arrive 置于 finally，确保异常路径也能推进或释放。
  - 处理中断：捕获 InterruptedException 后及时设置中断标志 Thread.currentThread().interrupt()。
- CountDownLatch
  - 计数必须与任务数量一致；不要在任务开始前 await，避免误判。
- CyclicBarrier
  - barrierAction 保持轻量且可中断；注意 BrokenBarrierException 的恢复与重试策略。
  - reset() 慎用，会打断正在等待的线程并导致异常传播。
- Semaphore
  - 许可泄漏是常见问题：任何返回路径都要 release；结合 try-with-resources 封装更稳健。
  - 公平模式更公平但吞吐降低，热点场景建议评估非公平模式。
- Phaser
  - 动态注册/注销要成对出现；缺失 arrive 或 deregister 会导致推进阻塞。
  - 如需任务在某阶段自动结束，重写 onAdvance 并返回 true。

更多并发内容请参考并发目录中的其他文档（线程池、锁、原子类、Concurrent 集合、CompletableFuture 等）。