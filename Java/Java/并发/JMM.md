# Java 内存模型（JMM）与 happens-before 规则

- 关注点：线程之间如何通过主内存与工作内存交互，保证可见性、有序性与原子性。
- happens-before 核心规则：
  - 程序次序：同一线程内，代码前发生先于代码后。
  - 监视器锁：对同一锁的解锁先于后续的加锁。
  - volatile：对同一 volatile 变量的写先于后续的读。
  - 线程启动：线程 A 调用 Thread.start() 先于被启动线程的执行。
  - 线程终止：线程内所有操作先于其他线程检测到其终止（如 join() 返回）。
  - 传递性：A 先于 B，B 先于 C，则 A 先于 C。
- 可见性与重排序：编译器与 CPU 可能重排指令，JMM 通过规则约束关键位置的重排。
- 设计目标：在保证正确性的同时尽可能提升性能，可配合 volatile、synchronized、Lock、原子类使用。
- 常见场景：
  - 发布与初始化安全（安全发布：final 字段、volatile、锁保护）。
  - 双重检查锁定（DCL）单例需要 volatile 防止重排。
- 问题排查：
  - 使用线程分析器或增加内存屏障（如在关键变量使用 volatile/锁）来定位可见性问题。