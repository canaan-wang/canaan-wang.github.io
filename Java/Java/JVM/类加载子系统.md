# 类加载子系统

## 一、双亲委派机制

双亲委派机制是指：当一个类加载器需要加载某个.class文件时，它不会首先自己去尝试加载这个类，而是先把加载请求委派给它的“父类加载器”去完成。只有当父类加载器在自己的搜索范围内找不到这个类，并且明确无法加载时，子类加载器才会尝试自己去加载这个类。

这里的“双亲”并非指继承关系中的“父类”，而是一种*层级委派关系*，类加载器之间通过这种关系形成一个树形结构（根加载器为顶层）。

## 二、JVM的类加载器层级结构

双亲委派机制的运行依赖于JVM预设的类加载器层级，不同层级的加载器负责加载不同范围的类。从Java 9开始引入模块化系统后，类加载器体系有所调整，这里分别介绍经典体系（Java 8及之前）和模块化体系（Java 9及之后）。

### 2.1 经典类加载器体系（Java 8及之前）

1. **启动类加载器（Bootstrap ClassLoader）**最顶层的加载器，由C/C++语言实现，不属于Java类（无法通过Java代码获取其实例）。负责加载JVM核心类库，如`JAVA_HOME/jre/lib`目录下的rt.jar、resources.jar等，以及被`-Xbootclasspath`参数指定的路径下的类。

2. **扩展类加载器（Extension ClassLoader）**由Java代码实现（sun.misc.Launcher$ExtClassLoader），是启动类加载器的“子加载器”。负责加载JVM扩展类库，如`JAVA_HOME/jre/lib/ext`目录下的jar包，以及被`java.ext.dirs`系统变量指定的路径下的类。

3. **应用程序类加载器（Application ClassLoader）**也叫系统类加载器，由Java代码实现（sun.misc.Launcher$AppClassLoader），是扩展类加载器的“子加载器”。负责加载应用程序的类路径（classpath）下的类，包括我们自己编写的类、第三方依赖的jar包等，是日常开发中默认使用的类加载器。

4. **自定义类加载器（Custom ClassLoader）**由开发者继承java.lang.ClassLoader类实现，根据业务需求自定义类的加载规则（如加载加密的类、从网络加载类等）。默认以应用程序类加载器为父加载器。

### 2.2 模块化类加载器体系（Java 9及之后）

Java 9引入模块化（Module）后，移除了扩展类加载器，新增了以下核心加载器，层级关系更贴合模块化设计：

1. **启动类加载器**：职责不变，加载核心模块（如java.base模块）。

2. **平台类加载器（Platform ClassLoader）**：替代扩展类加载器，加载平台相关的模块（如java.sql、java.xml等）。

3. **应用程序类加载器**：加载应用模块和类路径下的类。

### 2.3 扩展类加载器与平台类加载器的加载范围区别

扩展类加载器（Java 8及之前）和平台类加载器（Java 9及之后）虽为不同版本的“中间层加载器”，但加载范围存在显著差异，核心区别如下表所示：

|对比维度|扩展类加载器（Extension ClassLoader）|平台类加载器（Platform ClassLoader）|
|---|---|---|
|**对应Java版本**|Java 8及之前的经典类加载体系|Java 9及之后的模块化体系（替代扩展类加载器）|
|**加载范围定义**|以“路径”为核心，加载指定目录下的扩展类库JAR包|以“模块”为核心，加载官方定义的平台相关模块|
|**具体加载路径/模块**|1. 固定路径：`JAVA_HOME/jre/lib/ext`目录下的所有JAR包；2. 动态路径：被系统变量`java.ext.dirs`指定的路径下的类和JAR包|1. 核心平台模块：如`java.sql`（数据库连接）、`java.xml`（XML解析）、`java.security.jgss`（安全相关）等；2. 不依赖具体目录，而是通过模块描述符（module-info.java）识别的平台模块|
|**加载内容特征**|1. 内容为补充核心类库的扩展功能，如加密解密、图形界面扩展等；2. 以JAR包为单位，无严格的模块边界；3. 开发者可通过复制JAR包到ext目录或修改`java.ext.dirs`添加扩展类|1. 内容为平台级基础功能，与核心模块（如java.base）协同提供完整的Java基础能力；2. 以模块化形式组织，有明确的模块依赖和访问控制；3. 加载范围由JDK官方定义的平台模块决定，开发者无法通过简单添加JAR包扩展加载范围，需遵循模块化规范|
|**灵活性与可控性**|灵活性高，开发者可通过操作目录或系统变量灵活扩展加载内容，但缺乏模块边界控制|可控性强，基于模块化的加载范围更清晰，避免了类冲突，但扩展方式更规范、严谨|
## 三、双亲委派的加载流程

双亲委派机制的加载流程可概括为“**先委派父加载器，父加载器失败再自身加载**”，具体步骤如下（以经典体系为例）：

1. **发起请求**：当应用程序类加载器需要加载一个类（如com.example.Demo）时，首先不自己加载，而是将加载请求委派给其父加载器——扩展类加载器。

2. **父加载器递归委派**：扩展类加载器收到请求后，也不自己加载，继续将请求委派给其父加载器——启动类加载器。

3. **顶层加载器尝试加载**：启动类加载器收到请求后，在自己的搜索范围（核心类库路径）中查找该类。如果找到，则直接加载；如果找不到，返回“加载失败”的结果给扩展类加载器。

4. **子加载器尝试加载**：扩展类加载器收到父加载器失败的结果后，在自己的搜索范围（扩展类库路径）中查找该类。如果找到，则加载；如果找不到，返回“加载失败”给应用程序类加载器。

5. **最底层加载器尝试加载**：应用程序类加载器收到失败结果后，在自己的搜索范围（类路径）中查找该类。如果找到，则加载；如果仍找不到，抛出`ClassNotFoundException`或`NoClassDefFoundError`异常。


      核心特点：**自上而下委派，自下而上加载**。只有当所有父加载器都加载失败时，子加载器才会尝试加载。
    

## 四、源码解析：ClassLoader的loadClass方法

双亲委派机制的逻辑核心封装在java.lang.ClassLoader类的loadClass方法中，以下是JDK 8中该方法的关键源码（简化后）：

```java

protected Class<?> loadClass(String name, boolean resolve) throws ClassNotFoundException {
    synchronized (getClassLoadingLock(name)) {
        // 1. 检查该类是否已经被加载过（缓存机制）
        Class<?> c = findLoadedClass(name);
        if (c == null) {
            long t0 = System.nanoTime();
            try {
                // 2. 有父加载器则委派给父加载器加载
                if (parent != null) {
                    c = parent.loadClass(name, false);
                } else {
                    // 3. 无父加载器（启动类加载器），尝试通过启动类加载器加载
                    c = findBootstrapClassOrNull(name);
                }
            } catch (ClassNotFoundException e) {
                // 父加载器加载失败，捕获异常不处理
            }

            if (c == null) {
                // 4. 所有父加载器都失败，自身尝试加载
                long t1 = System.nanoTime();
                c = findClass(name); // 子类加载器的核心加载方法
            }
        }
        // 5. 可选：解析类（将符号引用转为直接引用）
        if (resolve) {
            resolveClass(c);
        }
        return c;
    }
}
```

关键逻辑说明：

- **缓存优先**：先检查类是否已被加载（JVM会缓存已加载的类），避免重复加载。

- **父加载器委派**：通过parent属性获取父加载器，递归调用loadClass方法。若parent为null，说明是应用程序类加载器，直接委派给启动类加载器。

- **自身加载**：父加载器失败后，调用findClass方法加载类（子类加载器需重写该方法实现自定义加载逻辑）。

## 五、核心优势：为什么需要双亲委派机制？

双亲委派机制的设计主要为了解决**类的唯一性**和**安全性**问题，具体优势如下：

### 5.1 保证类的唯一性，避免类重复加载

同一类名（全限定名）的类，由顶层的父加载器加载后，子加载器就不会再重复加载。例如，java.lang.String类由启动类加载器加载后，无论哪个子加载器再请求加载该类，都会直接返回启动类加载器已加载的实例，避免了“同一个类在JVM中存在多个副本”的问题，保证了类的一致性。

### 5.2 保护核心类库，防止恶意篡改

这是双亲委派机制最关键的安全作用。JVM核心类库（如java.lang.String、java.lang.Object）由启动类加载器加载，子类加载器无法覆盖这些类。例如，若开发者自定义一个“java.lang.String”类，当尝试加载时，根据双亲委派机制，请求会先委派给启动类加载器，而启动类加载器会加载核心类库中的String类，自定义的类永远不会被加载，从而防止了恶意类篡改核心类库的行为。


      面试高频点：**为什么自定义java.lang.String类无法生效？** 答案就是双亲委派机制——核心类由启动类加载器优先加载，自定义类无法被加载。
    

### 5.3 实现类加载的层级分工

不同层级的类加载器负责不同范围的类，职责清晰。启动类加载器负责核心类，扩展类加载器负责扩展类，应用程序类加载器负责应用类，避免了加载逻辑的混乱，提高了类加载系统的可维护性。

## 六、打破双亲委派机制的场景

虽然双亲委派机制是默认规则，但在某些特殊场景下需要打破它，常见场景如下：

### 6.1 自定义类加载器重写loadClass方法

若开发者自定义类加载器时，重写了loadClass方法且不遵循双亲委派的逻辑（如先自身加载再委派父加载器），即可打破该机制。例如，Tomcat的类加载器就重写了loadClass方法。

### 6.2 Tomcat等Web容器的类加载需求

Web容器需要实现“同一个Web应用的类相互隔离，不同Web应用的类可重复加载”。例如，两个Web应用都依赖不同版本的Spring框架，若遵循双亲委派机制，会导致只有一个版本的Spring被加载。因此，Tomcat自定义了类加载器（如WebAppClassLoader），其逻辑是：**先加载自身Web应用的类，再委派父加载器**，打破了默认的双亲委派顺序。

### 6.3 Java SPI机制的加载需求

Java的SPI（Service Provider Interface）机制（如JDBC加载驱动）中，SPI接口由启动类加载器加载（如java.sql.Driver），但SPI的实现类（如MySQL的Driver）在类路径下，需要由应用程序类加载器加载。此时启动类加载器无法加载实现类，需要通过`Thread.currentThread().getContextClassLoader()`获取应用程序类加载器来加载实现类，这相当于间接打破了双亲委派机制。

### 6.4 OSGi模块化框架

OSGi框架支持模块化的动态安装、卸载和更新，每个模块有自己的类加载器，类加载逻辑复杂，需要灵活的加载规则，因此会打破双亲委派机制。

## 七、核心知识点总结

- **定义**：子加载器先委派父加载器加载类，父加载器失败后子加载器再尝试加载。

- **层级**：经典体系（启动→扩展→应用→自定义）；Java 9+（启动→平台→应用→自定义）。

- **流程**：自上而下委派，自下而上加载，缓存优先。

- **核心方法**：ClassLoader.loadClass（委派逻辑）、findClass（自身加载逻辑）。

- **优势**：保证类唯一性、保护核心类库、实现层级分工。

- **打破场景**：Tomcat类加载、SPI机制、自定义类加载器重写loadClass。
> （注：文档部分内容可能由 AI 生成）