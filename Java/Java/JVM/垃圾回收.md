# 垃圾回收

## 一、GC概述：什么是垃圾回收？

垃圾回收是JVM提供的自动内存管理机制，核心职责是**识别内存中的“垃圾”（即不再被使用的对象）并释放其占用的内存空间**，从而避免内存泄漏、减少手动管理内存的复杂度。

手动内存管理（如C/C++）需开发者手动分配和释放内存，易出现“忘记释放导致内存泄漏”“重复释放导致崩溃”等问题；JVM的GC机制通过自动化管理解决了这些痛点，但也要求开发者理解其原理以避免内存溢出（OOM）。

GC的作用范围是JVM内存模型中的**堆内存**和**方法区**（JDK 8后为元空间），因为这两个区域是程序运行时动态分配内存的核心区域，也是“垃圾”产生的主要场所；而程序计数器、虚拟机栈、本地方法栈属于线程私有内存，随线程生命周期自动回收，无需GC参与。

## 二、GC核心目标：What to Do？

GC需实现三大核心目标，三者相互制约，不同收集器会根据场景侧重不同目标：

1. **可达性分析：准确识别垃圾**——确保只回收“真正无用”的对象，不误删仍在使用的对象；

2. **内存释放：高效回收空间**——将垃圾对象占用的内存释放，供新对象分配使用；

3. **内存整理：减少内存碎片**——回收后整理内存空间，避免大量零散空闲空间导致“内存足够但无法分配大对象”的问题。

## 三、核心流程一：如何识别“垃圾”？

GC识别垃圾的核心标准是“对象是否再被使用”，主流实现方式是**可达性分析算法**，替代了早期的“引用计数法”（存在循环引用无法识别的缺陷）。

### 3.1 可达性分析算法

以“**GC Roots**”为起点，通过引用链遍历内存中的对象：若对象能通过引用链与GC Roots直接或间接相连，则为“可达对象”（仍在使用）；若无法相连，则为“不可达对象”（候选垃圾）。

### 3.2 关键概念：GC Roots

GC Roots是JVM确定的“绝对存活”的引用源，主要包括以下四类：

- 虚拟机栈（栈帧中的本地变量表）中引用的对象，如方法参数、局部变量；

- 本地方法栈中JNI（Java Native Interface）引用的对象；

- 方法区中类静态属性引用的对象，如`static`修饰的变量；

- 方法区中常量引用的对象，如`final`修饰的常量；

- JVM内部引用，如类加载器、异常对象（`Throwable`）、系统类等。

### 3.3 补充：引用的四种类型

Java中的引用强度不同，直接影响对象的回收时机，JDK 1.2后将引用分为四级（从强到弱）：

|引用类型|定义|回收时机|典型场景|
|---|---|---|---|
|强引用|默认引用方式，如`Object obj = new Object()`|仅当引用链断裂时才可能被回收|普通对象的引用|
|软引用|通过`SoftReference`类实现|内存不足时会被回收|缓存（如图片缓存）|
|弱引用|通过`WeakReference`类实现|下一次GC时必被回收（无论内存是否充足）|临时数据存储（如`WeakHashMap`）|
|虚引用|通过`PhantomReference`类实现，又称“幽灵引用”|无法通过引用获取对象，仅用于监听对象回收事件|跟踪对象回收（如释放直接内存）|
### 3.4 不可达对象的“自救”机会

不可达对象并非立即被回收，需经历两次标记过程：

1. **第一次标记**：可达性分析后标记为不可达对象，筛选“是否有必要执行`finalize()`方法”（若对象未重写该方法或已执行过，则无需执行）；

2. **第二次标记**：需执行`finalize()`的对象被放入“F-Queue”队列，由JVM的Finalizer线程执行该方法；若对象在`finalize()`中重新建立与GC Roots的引用（如赋值给强引用变量），则第二次标记时会被移除出“待回收列表”，实现“自救”。

注意：`finalize()`方法执行优先级低，且JVM不保证一定执行（如线程被终止），因此不建议通过该方法实现资源释放，推荐使用`try-with-resources`或手动关闭资源。

## 四、核心流程二：垃圾回收算法

垃圾回收算法是GC的核心逻辑，不同算法针对“识别-回收-整理”的实现方式不同，主流算法包括以下四类：

### 4.1 标记-清除算法（Mark-Sweep）

最基础的算法，分为“标记”和“清除”两个阶段：

1. **标记**：通过可达性分析标记所有可达对象；

2. **清除**：遍历内存，回收所有未被标记的对象，释放内存空间。

**优点**：实现简单，无需移动对象；**缺点**：① 效率低（标记和清除需遍历全量对象）；② 产生大量内存碎片。

适用场景：内存碎片影响小的场景，如JDK 1.7前的永久代（方法区）回收。

### 4.2 复制算法（Copying）

为解决标记-清除的碎片问题，将内存分为“大小相等的两块”（如From区和To区），仅使用其中一块：

1. **标记-复制**：可达性分析后，将From区的可达对象复制到To区，按顺序排列（无碎片）；

2. **交换角色**：回收From区所有内存，将From区和To区角色互换，下次GC使用新的From区。

**优点**：效率高（仅复制可达对象），无内存碎片；**缺点**：内存利用率低（仅50%），不适合可达对象多的场景（复制成本高）。

适用场景：可达对象少的区域，如JVM的“新生代”（大多数对象朝生夕死，可达对象少）。

### 4.3 标记-整理算法（Mark-Compact）

针对老年代“对象存活时间长、可达对象多”的特点，在标记-清除基础上增加“整理”阶段：

1. **标记**：同标记-清除算法，标记可达对象；

2. **整理**：将所有可达对象向内存一端移动，按顺序排列；

3. **清除**：回收内存另一端的所有未标记对象。

**优点**：无内存碎片，内存利用率高；**缺点**：增加了“整理”阶段的开销（移动对象+更新引用地址）。

适用场景：对象存活时间长的区域，如JVM的“老年代”。

### 4.4 分代收集算法（Generational Collection）

当前所有商用JVM的默认算法，核心依据“**对象存活周期不同，采用不同回收算法**”，将堆内存分为“新生代”和“老年代”（部分JVM还包含“永久代/元空间”）：

- **新生代（Young Generation）**：对象创建的区域，特点是“朝生夕死”（90%以上对象创建后很快被回收）。采用“复制算法”，进一步分为Eden区（80%）、From Survivor区（10%）、To Survivor区（10%）：
        新对象优先分配到Eden区，当Eden区满时触发“Minor GC”（新生代GC）；

- Minor GC时，将Eden区和From区的可达对象复制到To区，年龄计数器+1；

- 交换From和To区角色，若对象年龄达到阈值（默认15，可通过`-XX:MaxTenuringThreshold`调整），则晋升到老年代。

- **老年代（Old Generation）**：存放存活时间长的对象（如新生代晋升的对象、大对象）。特点是“对象存活率高”，采用“标记-整理算法”，当老年代空间不足时触发“Major GC”（老年代GC），Major GC通常伴随Minor GC，开销远大于Minor GC。

- **元空间（Metaspace，JDK 8后）**：替代永久代，存放类元信息、常量、静态变量等，当空间不足时触发“元空间GC”。元空间GC核心采用**标记-清除算法**。由于元空间中类元信息的引用关系相对简单（主要关联类加载器和实例对象），且无用类元信息占比通常较低，标记-清除算法的“内存碎片”问题对元空间影响较小，无需额外整理步骤，可兼顾效率与需求。

大对象处理：超过Eden区一半大小的对象被视为“大对象”，直接分配到老年代（避免在新生代频繁复制），可通过`-XX:PretenureSizeThreshold`调整阈值。

## 五、主流垃圾收集器

垃圾收集器是算法的“具体实现”，不同收集器针对不同场景优化，**JDK 8（LTS版本）的默认垃圾收集器为Parallel收集器（并行收集器）**，同时支持Serial、CMS等收集器，需根据“吞吐量”“响应时间”等需求选择：

### 5.1  Serial收集器（串行收集器）

最基础的收集器，采用“串行执行”方式：GC时暂停所有用户线程（“Stop The World，STW”），单线程执行垃圾回收。

**优点**：实现简单、内存占用小、单线程效率高；**缺点**：STW时间长，不适合多核CPU和大型应用。

适用场景：客户端应用（如桌面程序）、单核CPU环境。

参数配置：`-XX:+UseSerialGC`（新生代Serial + 老年代Serial Old）。

### 5.2  Parallel收集器（并行收集器）

以“吞吐量优先”为目标，采用“多线程并行回收”，GC时仍会STW，但回收速度更快。

**吞吐量** = 用户线程运行时间 /（用户线程运行时间 + GC时间），Parallel收集器可通过参数调整吞吐量目标。

**优点**：吞吐量高，适合计算密集型应用；**缺点**：STW时间仍较长，不适合响应时间敏感的应用。

适用场景：服务器端计算密集型应用（如数据分析）。

参数配置：`-XX:+UseParallelGC`（**JDK 8** **默认新生代收集器**，搭配老年代Parallel Old收集器）、`-XX:MaxGCPauseMillis`（最大STW时间，默认无限制）、`-XX:GCTimeRatio`（吞吐量目标，默认99，即吞吐量≥99%）。

### 5.3  CMS收集器（Concurrent Mark Sweep）

以“响应时间优先”为目标，采用“并发回收”方式，尽可能减少STW时间，核心流程分为四个阶段：

1. **初始标记（STW）**：快速标记GC Roots直接引用的对象，STW时间短；

2. **并发标记**：与用户线程并行，遍历引用链标记可达对象；

3. **重新标记（STW）**：修正并发标记期间因用户线程操作导致的标记偏差，STW时间比初始标记略长；

4. **并发清除**：与用户线程并行，回收未标记对象。

**优点**：并发回收，STW时间短，响应性好；

**缺点**：① 内存碎片多（采用标记-清除算法）；② 并发回收占用CPU资源，吞吐量下降；③ 可能出现“Concurrent Mode Failure”（并发回收时老年代满，触发Serial Old收集器，STW时间长）。

适用场景：响应时间敏感的应用（如Web服务）。

参数配置：`-XX:+UseConcMarkSweepGC`（**JDK ** **8支持，JDK ** **9后已标记为废弃**）。

### 5.4  G1收集器（Garbage-First）

JDK 9及以后的默认收集器，兼顾“吞吐量”和“响应时间”，核心特点是“区域化分代式回收”。

- **区域化管理**：将堆内存划分为多个大小相等的“Region”（默认2MB~32MB），每个Region可动态标记为Eden、Survivor、Old、Humongous（大对象区域）；

- **优先回收价值高的Region**：通过统计每个Region的“垃圾占比”和“回收收益”，优先回收收益最高的Region，实现“Garbage-First”；

- **混合回收（Mixed GC）**：不仅回收新生代，还会选择性回收部分老年代Region，减少Major GC的频率。

**优点**：兼顾吞吐量和响应时间，支持大堆内存（如几十GB），无内存碎片（Region内采用复制算法，整体采用标记-整理思想）；**缺点**：区域化管理增加了复杂度，小堆内存场景下效率不如Parallel。

适用场景：大堆内存、响应时间和吞吐量均有要求的应用（如大型Web服务、微服务）。

参数配置：`-XX:+UseG1GC`（**JDK 8需手动指定启用** **，JDK 9+** **默认**）、`-XX:MaxGCPauseMillis`（目标STW时间，默认200ms）。

### 5.5  ZGC/Shenandoah收集器（低延迟收集器）

为超大规模堆内存（如百GB、TB级）设计的低延迟收集器，核心特点是“几乎无STW”（STW时间控制在毫秒级甚至微秒级），通过“着色指针”“读屏障”等技术实现并发标记、并发整理。

**ZGC**：Oracle JDK 11后引入，支持最大16TB堆内存，STW时间≤10ms；**Shenandoah**：OpenJDK专属，JDK 12后引入，设计理念与ZGC类似。

适用场景：超大规模堆内存、低延迟要求极高的应用（如金融交易、实时计算）。

参数配置：**JDK 8不支持ZGC和Shenandoah**；ZGC需Oracle JDK 11及以上，用`-XX:+UseZGC`；Shenandoah需OpenJDK 12及以上，用`-XX:+UseShenandoahGC`。

## 六、GC监控与调优基础

理解GC原理后，需通过监控工具识别问题，再进行调优，核心步骤如下：

### 6.1 核心监控工具

- **命令行工具**：jps（查看Java进程）、jstat（实时监控GC状态，如`jstat -gcutil 进程ID 1000`每秒输出GC统计信息）、jmap（生成堆转储快照，如`jmap -dump:format=b,file=heap.hprof 进程ID`）、jhat（分析堆快照）；

- **可视化工具**：JConsole（JDK自带，简单监控）、VisualVM（功能强大，支持堆分析、GC日志分析）、MAT（Memory Analyzer Tool，专业堆快照分析工具，定位内存泄漏）。

### 6.2 调优核心思路

1. **明确目标**：确定是“吞吐量优先”还是“响应时间优先”；

2. **监控指标**：关注Minor GC/Major GC频率、STW时间、堆内存使用趋势、吞吐量等；

3. **调整参数**：优先调整堆内存大小（`-Xms`初始堆、`-Xmx`最大堆，建议设为相同值避免动态调整）、新生代/老年代比例（`-XX:NewRatio`）、收集器类型等；

4. **代码优化**：减少大对象创建、避免内存泄漏（如静态集合持有对象引用、未关闭资源）、合理使用软/弱引用。

## 七、核心知识点总结

- GC作用：自动回收堆和元空间的垃圾对象，避免内存泄漏；

- 垃圾识别：基于可达性分析，GC Roots为起点，不可达对象需两次标记；

- 核心算法：分代收集是主流，新生代用复制算法，老年代用标记-整理算法；

- 收集器选择（JDK 8适配）：客户端用Serial，计算密集用默认Parallel，响应敏感用G1（需手动启用）；ZGC/Shenandoah不支持；

- 调优关键：先监控后调优，明确目标，优先调整堆大小和收集器。
> （注：文档部分内容可能由 AI 生成）