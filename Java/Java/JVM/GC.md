## finalize
- 在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。这个方法是由垃圾收集器在销毁对象时调用的

## 垃圾回收
### 垃圾回收算法
- 基于“分代收集” 理论设计
#### 标记复制算法（新生代使用该算法）
- 内存划分为同等大小的两块，每次只使用其中一块，标记不可达对象，将可达对象复制到另一块上，把原内存一次清理
- 缺点：
    空间浪费高（可用内存缩小了一半）
    在存活对象多时，会产生大量的复制开销
#### 标记整理算法（老年代）
- 标记所有需要回收的对象，所有存活对象向内存空间的一端移动，清理掉边界以外的区域
- 缺点：
    老年代存活对象较多，移动存活对象并更新所有引用操作较重，此操作还需要暂停用户程序
### 垃圾回收器
#### G1
- Mixed GC 模式：面向堆内存中的任何部分，选择垃圾数量最多，回收收益最大的内存进行回收
- 遵循分代收集理论设计
- Java 堆被划分为多个大小相等的独立区域（Region），
    Region 根据需要确定其为新生代（Eden）、老年代（Survivor）、存储大对象的区域（Humongous Region）
    G1 认为超过 Region 一半的对象即为大对象。
    超过了整个 Region 的超大对象，会被存放在连续 N 个 Humongous Region 中
    G1 将 Humongous Region 作为老年代的一部分看待。
- G1 根据各 Region 里的垃圾堆积价值（回收获得的空间以及时间），维护一个优先级列表，优先处理价值高的 Region。
- 垃圾回收过程：
    初始标记：有 STW
    并发标记：
    重新标记：有 STW
    并发清除：
#### CMS
- 以最短回收停顿时间为目标
- 基于标记清除算法实现
- 垃圾回收过程：
    初始标记：有 STW，仅标记一下 GC Roots 能直接关联的对象，速度很快
    并发标记：从GC Roots的直接关联对象开始遍历整个对象图，耗时较长，不需要停顿用户线程。
    重新标记：有 STW，为了修正并发标记期间,用户程序导致标记产生变动的对象的标记记录,停顿时间比初始标记时间长，比并发标记时间短。
    并发清除：清除被标记为死亡的对象
#### GC Roots
- 虚拟机栈中引用的对象
- 方法区中的静态变量
- 方法区中常量
- 本地方法栈中引用的对象；
- JVM内部的引用，如基本数据类型对应的Class对象，常驻的异常对象，以及系统类加载器；
- 所有被同步锁持有的对象；
- 反映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。
#### finalize
- 对象的类对其重写后，可在对象被回收前执行一次（下次回收不执行），执行时如果将其变为可达对象则不会被回收，如果没有还是会被回收。