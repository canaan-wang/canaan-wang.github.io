## Hashtable
- KV 不可以是 null
- 线程安全

## HashMap
- 模型：数组 + 链表 + 红黑树
- 允许使用 null KV
- KV 可以是 null
###  27.1. putput 操作过程
- 判断数组，数组为空，进行首次扩容。
- 判断头节点，头节点为空，新建链表节点存入数组
- 判断头节点，头节点不为空，向链表中加入元素
- 判断链表长度是否达到转为红黑树的条件
- 链表长度达到 8，数组长度小于 64 则扩容。
- 链表长度达到 8 ，数组长度达到 64 则转为红黑树
- 判断元素个数是否达到扩容因子，达到则扩容
###  27.2. 扩容机制
- 扩容每次翻倍扩容（默认为 16）
- 数组为空首次扩容
- 链表长度达到 8，数组小于 64 则扩容
- 数组元素超过负载因子（0.75）进行扩容
###  27.3. 并发场景下使用
- 非线程安全
- 可以使用 Collections 将 HashMap 转为安全的 HashMap
- 直接使用 ConcurrentHashMap

## TreeMap
- 红黑树实现

## LinkedHashMap

## WeakHashMap

## ConcurrentHashMap
- 模型：数组 + 链表 + 红黑树
- 采用锁定头节点的方式降低了锁粒度
- 初始化数据 or 头节点时，没有加锁，通过 CAS 的方式进行原子替换（为什么不使用锁呢？）
- 插入数据时会进行加锁，锁定的是链表的头节点
- 支持多个线程在扩容中进行链表搬移
- 数据读取是没有进行加锁
- 扩容过程中，依然支持查找操作，如果对应链表未搬迁，则直接找，如果已搬迁，则搬迁时会留下一个转发节点，根据转发节点找对应的目标数据
- 线程在插入输入时，如果发现数组正在扩容，则它会参与到扩容操作中，完成扩容在写入先的数组中。