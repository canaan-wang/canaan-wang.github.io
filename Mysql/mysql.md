## ACID
- 原子性：事务是 DB 最小的工作单位
- 一致性：数据库从一种一致性状态转变为另一种一致性状态（数据库的完整性约束没有被破坏）
- 隔离性：事务为提交前对其它事务不可见
- 持久型：数据库用于数据恢复能力


## 索引
- 普通索引、唯一索引、主键索引、外键索引、全文索引、复合索引
- 优点：合理使用索引时可以大幅提高 sql 的查询效率
- 缺点：增加存储资源消耗、增加增删改的维护成本（需要维护索引）
### 聚簇索引（索引实现方式）
- 数据与索引存储在一起
- InnoDB 中一个表仅有一个聚簇索引，索引建立在主键上（没有主键也会特殊处理生成一个聚簇索引）
### 非聚簇索引（索引实现方式）
- 数据与索引分开存储
- 在 MyISAM 中所有索引都是非聚簇索引，叶子节点存储数据的地址
### 为什么采用 B+ 树而非红黑树
- 红黑树近似平衡二叉树，树高不超过 2*log(n),时间复杂度为 log(n),增删改查的性能都很稳定。但是在数据量大的情况下，需要访问的节点还是比较多。但是数据存储在磁盘，需要进行 IO，这样在二叉树的数据模型下效率就会很低。
- B+ 树是多叉，可以降低树高进而降低 IO 次数，同时 B+ 树叶子间有连接，在范围查询是可以快速的取出需要的数据。
### 为什么不使用哈希表
- 哈希表需要将所有数据加载仅内存，B+ 树可以通过分段加载的方式。
### 索引实现（B+ 树实现）
- MySQL 中 B+ 树的高度一般在 2 - 4 层

## 事务
### 四大特性
- 原子性：对数据库的一系列操作，要么全部成功，要么全部失败，不可能出现部分成功的情况。
- 一致性：一致性是指数据库的完整性约束没有被破坏，在事务执行前后都是合法的数据状态。
- 隔离性：隔离性指的是多个事务彼此之间是完全隔离、互不干扰的。
- 持久性：持久性是指只要事务提交成功，那么对数据库做的修改就被永久保存下来了，不可能因为任何原因再回到原来的状态。
### 事务状态
- 活动（active）：当事务对应的数据库操作正在执行过程中，则该事务处于活动状态。
- 部分提交的（partially committed）：当事务中的最后一个操作执行完成，但还未将变更刷新到磁盘时，则该事务处于部分提交状态。
- 失败的（failed）：当事务处于活动或者部分提交状态时，由于某些错误导致事务无法继续执行，则事务处于失败状态。
- 中止的（aborted）：当事务处于失败状态，且回滚操作执行完毕，数据恢复到事务执行之前的状态时，则该事务处于中止状态。
- 提交的（committed）：当事务处于部分提交状态，并且将修改过的数据都同步到磁盘之后，此时该事务处于提交状态。
### 事务并发时会发生的问题
- 脏读（Dirty Read） 脏读是指一个事务读到了其它事务未提交的数据。
- 脏写（Dirty Write） 脏写是指一个事务修改了其它事务未提交的数据。
- 不可重复读（Non-Repeatable Read） 不可重复读指的是在一个事务执行过程中，读取到其它事务已提交的数据，导致两次读取的结果不一致。
- 幻读（Phantom） 幻读是指的是在一个事务执行过程中，读取到了其他事务新插入数据，导致两次读取的结果不一致。
### 事务隔离级别
| 隔离级别 | 脏读 | 不可重复读 | 幻读 | 
| ------------------------------- | -------- | --------------- | ------ | 
| READ UNCOMMITTED | 可能 | 可能 | 可能 | （读未提交）
| READ COMMITTED | 不可能 | 可能 | 可能 | （读提交）
| REPEATABLE READ | 不可能 | 不可能 | 可能 |（可重复读，InnoDB 在该级别通过 MVCC 解决了幻读的问题）
| SERIALIZABLE | 不可能 | 不可能 | 不可能 | （串行化）

## MVVC（多版本并发控制）：
- 通过维护数据历史版本，从而解决并发访问情况下的读一致性问题。
### 版本链
- InnoDB 中，每行记录都包含了两个隐藏字段：事务id(trx_id)和回滚指针(roll_pointer)。
    事务id：每次修改某行记录时，都会把该事务的事务id赋值给trx_id隐藏列。
    回滚指针：每次修改某行记录时，都会把undo日志地址赋值给roll_pointer隐藏列。
- 对该条记录的修改日志串联起来就形成了一个版本链，版本链的头节点就是当前记录最新的值。
### ReadView（事务开始时创建）
- 已提交读或者可重复读，需要遍历版本链中的每一条记录，判断该条记录是否对当前事务可见，直到找到为。InnoDB通过 ReadView 实现了这个功能。
    m_ids：表示在生成 ReadView 时当前系统中活跃的读写事务的事务id列表。
    min_trx_id：表示在生成 ReadView 时当前系统中活跃的读写事务中最小的事务id，也就是m_ids中的最小值。
    max_trx_id：表示生成 ReadView 时系统中应该分配给下一个事务的id值。   
    creator_trx_id：表示生成该 ReadView 事务的事务id。
- 判断版本对当前事务是否可见
    如果被访问版本的trx_id属性值与ReadView中的creator_trx_id值相同，意味着当前事务在访问它自己修改过的记录，所以该版本可以被当前事务访问。
    如果被访问版本的trx_id属性值小于ReadView中的min_trx_id值，表明生成该版本的事务在当前事务生成ReadView前已经提交，所以该版本可以被当前事务访问。
    如果被访问版本的trx_id属性值大于或等于ReadView中的max_trx_id值，表明生成该版本的事务在当前事务生成ReadView后才开启，所以该版本不可以被当前事务访问。
    如果被访问版本的trx_id属性值在ReadView的min_trx_id和max_trx_id之间，那就需要判断一下trx_id属性值是不是在m_ids列表中，如果在，说明创建ReadView时生成该版本的事务还是活跃的，该版本不可以被访问；如果不在，说明创建ReadView时生成该版本的事务已经被提交，该版本可以被访问。

## 锁
### 乐观锁：
- 读写均不加锁，写时通过版本进行控制，选择最新的版本
### 悲观锁：
- 读写都加锁
### 锁的粒度
- 行锁：作用在数据行上，锁的粒度比较小。
- 表锁：作用在整张数据表上，锁的粒度比较大。

当我们给一行数据加上共享锁之前，数据库会自动在这张表上面加一个意向共享锁(IS锁)；当我们给一行数据加上排他锁之前，数据库会自动在这张表上面加一个意向排他锁(IX锁)。意向锁可以认为是S锁和X锁在数据表上的标识，通过意向锁可以快速判断表中是否有记录被上锁，从而避免通过遍历的方式来查看表中有没有记录被上锁，提升加锁效率。例如，我们要加表级别的X锁，这时候数据表里面如果存在行级别的X锁或者S锁的，加锁就会失败，此时直接根据意向锁就能知道这张表是否有行级别的X锁或者S锁。
### 锁的分类
- 共享锁：在事务要读取一条记录时，需要先获取该记录的共享锁。可以在同一时刻被多个事务同时持有。我们可以用 select ...... lock in share mode 的方式手工加上。
- 排他锁：在事务要改动一条记录时，需要先获取该记录的排他锁。在同一时刻最多只能被一个事务持有。
        X锁的加锁方式有两种，第一种是自动加锁，在对数据进行增删改的时候，都会默认加上。
        还有一种是手工加锁，我们用一个FOR UPDATE给一行数据加上。
- 如果一个事务已经持有了某行记录的共享锁，另一个事务是无法为这行记录加上排他锁的，反之亦然。
- 意向锁：
    由数据库维护，在加锁的时候会在表上加对应的意向锁（共享锁 -> 意向共享锁，排他锁 -> 意向排他锁）
    通过意向锁可以快速判断表中是否有记录被上锁，从而避免通过遍历的方式来查看表中有没有记录被上锁，提升加锁效率。
### InnoDB 行锁
- 记录锁：直接锁定某行记录。当我们使用唯一性的索引(包括唯一索引和聚簇索引)进行等值查询且精准匹配到一条记录时，此时就会直接将这条记录锁定。
- 间隙锁：锁定某些间隙区间的。当我们使用用等值查询或者范围查询，并且没有命中任何一个record，此时就会将对应的间隙区间锁定。
- 临键锁：记录锁(Record Locks)和间隙锁(Gap Locks)的结合，即除了锁住记录本身，还要再锁住索引之间的间隙。当我们使用范围查询，并且命中了部分record记录，此时锁住的就是临键区间。


## InnoDB
- 支持事务
- 支持行级锁，提供优秀的并发能力
- 增删改 性能优
- 不支持全文索引（但是可以通过插件实现）
- 支持外键
- 在磁盘中存储为一个文件
- InnoDB 需要比 MyISAM 更多的内存和存储
- 默认事务隔离级别：可重复读
- 幻读避免方式：Next-Key Lock 锁算法
- 行级锁实现：在索引的索引项上加锁实现

## MyISAM
- 不支持事务
- 仅支持表级锁
- 查询 性能优
- 默认支持全文索引
- 不支持外键
- 在磁盘中存储为三个文件（表定义、数据、索引）

## 中从同步
1. 主数据库服务器的数据更改会写入 binlog 日志
2. 从从数据库服务器将主数据库的 binlog 复制到自己的中继日志 relay log 中
3. 从 relay log 中获取数据更改信息，更新自己。

## 日志
### binlog
- 记录数据库执行的写入性操作,由 Server 层进行记录,通过追加的方式进行写入。
- 通过 max_binlog_size 参数设置每个 binlog 文件的大小，当文件大小达到给定值之后，会生成新的文件来保存日志。
- 使用场景：
    主从复制：在 Master 端开启 binlog，然后将 binlog 发送到各个 Slave 端，Slave 端重放 binlog 从而达到主从数据一致。
    数据恢复：通过使用 mysqlbinlog 工具来恢复数据
- 刷盘时机
    mysql 通过 sync_binlog 参数控制 biglog 的刷盘时机，取值范围是 0-N
    0：不去强制要求，由系统自行判断何时写入磁盘；
    1：每次 commit 的时候都要将 binlog 写入磁盘；
    N：每 N 个事务，才会将 binlog 写入磁盘。
- 日志格式
    STATMENT：
        基于SQL语句复制，每一条会修改数据的sql语句会记录到 binlog 中。
        优点：不需要记录每一行的变化，减少了binlog日志量，节约了IO, 从而提高了性能；
        缺点：在某些情况下会导致主从数据不一致，比如执行sysdate()、slepp()等。
    ROW：
        基于行的复制，不记录每条sql语句的上下文信息，仅需记录哪条数据被修改了。
        优点：不会出现某些特定情况下的存储过程、或function、或trigger的调用和触发无法被正确复制的问题；
        缺点：会产生大量的日志，尤其是alter table的时候会让日志暴涨
    MIXED
        基于STATMENT和ROW两种模式的混合复制
        一般的复制使用 STATEMENT 模式保存 binlog，对于 STATEMENT 模式无法复制的操作使用 ROW 模式保存 binlog
### redolog（InnoDB 独有）
- 为了降低对数据页刷盘的要求
- 包括两部分：
    内存中的日志缓冲(redo log buffer)
    磁盘上的日志文件(redo log file)
- WAL（先写日志，再写磁盘）：某个时间点一次性将 redo log buffer 写到 redo log file 中
- WAL 缓存到日志文件的 flush 流程
    redo log buffer -> OS Buffer：用户空间下的缓存数据无法直接刷入磁盘，需要通过内核的 OS Buffer
    OS Buffer -> redo log file：通过系统调用 fsync 将其刷到 redo log file
- WAL 缓存到日志的 flush 时机配置（innodb_flush_log_at_trx_commit）
    0: 延迟写，每秒写入 OS Buffer 并调用 fsync 写入到 redo log file 中(会丢失一秒的数据)
    1: 实时写，实时刷，
    2: 实时写，延迟刷，每次提交都写到 OS Buffer 中，每秒调用 fsync 将 OS Buffer 中的日志写入到 redo log file。
### undo log
- 实现数据库事务的原子性
- undo log主要记录了数据的逻辑变化，在发生错误时，就能回滚到事务之前的数据状态。
## 数据页刷盘
