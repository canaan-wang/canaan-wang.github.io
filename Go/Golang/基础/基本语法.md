# Golang 基本语法

## 提示：包相关内容已移至 [package.md](../package.md) 文件中，请前往查看。

## 一、变量与常量

### 变量声明

变量是程序中用于存储和操作数据的基本单元。Go语言提供了多种变量声明方式，每种方式都有其适用场景。

#### 1. var关键字

`var`关键字是Go语言声明变量的标准方式，适用于所有变量声明场景：

```go
// 声明单个变量 - 未初始化的变量会被赋予该类型的零值
var name string  // 空字符串
var age int      // 0
var isActive bool // false

// 声明并初始化
var counter int = 100
var greeting string = "Hello, Go!"

// 多个变量声明 - 可同时声明多个不同类型的变量
var (
    firstName string = "John"
    lastName  string = "Doe"
    height    float64 = 1.75
    weight    float64 = 75.5
    isStudent bool = true
)

// 类型推断 - 不指定类型时，Go编译器会根据初始化值自动推断类型
var count = 10      // 自动推断为int
var pi = 3.14159    // 自动推断为float64
var message = "Go语言"  // 自动推断为string
```

**零值机制**：Go语言中，未初始化的变量会被自动赋予该类型的零值，这是Go语言的一个重要特性，可以避免使用未初始化的变量导致的错误。
- 数值类型：0
- 布尔类型：false
- 字符串类型：""（空字符串）
- 指针、切片、映射、通道、函数和接口：nil

#### 2. 短变量声明

在函数内部，可以使用`:=`运算符进行短变量声明，这是Go语言中最常用的变量声明方式，代码更加简洁：

```go
func main() {
    // 基本的短变量声明
    score := 95  // 等价于 var score int = 95
    
    // 多变量同时声明
    name, age := "Alice", 30
    
    // 重新赋值 - 在同一作用域内，可以使用短变量声明来重新赋值，但至少有一个变量必须是新声明的
    name, newVar := "Bob", true
    
    // 函数返回值赋值
    result, err := calculate(10, 20)
    if err != nil {
        // 错误处理
    }
}
```

**注意事项**：
- 短变量声明只能在函数内部使用，不能在包级作用域使用
- 短变量声明必须至少声明一个新变量
- 短变量声明会自动进行类型推断

### 常量定义

常量是程序中在编译时就确定的值，运行时不可修改。Go语言使用`const`关键字定义常量。

```go
// 基本常量声明
const PI float64 = 3.1415926535
const MAX_RETRY int = 3
const APP_NAME string = "GoApplication"

// 常量组 - 可以同时声明多个常量
const (
    STATUS_ACTIVE   = 1
    STATUS_INACTIVE = 0
    STATUS_PENDING  = 2
    MAX_SIZE        = 1024
)

// 无类型常量 - 不指定类型的常量，在使用时可以根据上下文自动转换为适当的类型
const ANSWER = 42
const RATE = 0.75

// 类型推断的常量
const COUNT = 100    // 无类型整数常量
const PI_APPROX = 3.14 // 无类型浮点常量
```

**常量的特点**：
- 常量必须在声明时初始化
- 常量的值必须是编译时常量表达式
- 常量可以是数值、字符串或布尔值
- 无类型常量可以根据上下文自动转换类型

### iota枚举

`iota`是Go语言的一个预定义标识符，用于创建枚举常量。它在常量声明中会从0开始递增，每个新行递增1。

```go
// 基本的iota使用
const (
    MONDAY = iota  // 0
    TUESDAY        // 1
    WEDNESDAY      // 2
    THURSDAY       // 3
    FRIDAY         // 4
    SATURDAY       // 5
    SUNDAY         // 6
)

// 带表达式的iota
const (
    _ = iota  // 跳过第一个值，从1开始计数
    KB = 1 << (10 * iota)  // 1 << 10 = 1024
    MB                     // 1 << 20 = 1,048,576
    GB                     // 1 << 30 = 1,073,741,824
    TB                     // 1 << 40 = 1,099,511,627,776
)

// 复杂表达式示例
const (
    BIT_0 = 1 << iota  // 1 << 0 = 1
    BIT_1              // 1 << 1 = 2
    BIT_2              // 1 << 2 = 4
    _                  // 跳过一个值
    BIT_4              // 1 << 4 = 16
)

// 多个iota重置
const (
    A = iota  // 0
    B         // 1
)

const (
    C = iota  // 0，新的常量组重新从0开始计数
    D         // 1
)

**iota的应用场景**：
- 创建连续的整数值常量
- 定义位掩码和标志位
- 创建与位移、乘法等操作结合的常量序列
- 表示状态码、错误码等需要连续值的场景

**iota使用技巧**：
- 使用下划线`_`跳过不需要的值
- 可以在一个常量组中使用多个iota表达式
- 可以结合各种运算符创建复杂的常量序列
- 每个新的常量组都会重置iota的值为0

## 二、数据类型

### 基本类型

#### 1. 数值类型

```go
// 整数类型
int8, int16, int32, int64     // 有符号整数
uint8, uint16, uint32, uint64 // 无符号整数
int, uint                     // 与操作系统架构相关的整数类型
uintptr                       // 用于指针运算的无符号整数

// 浮点类型
float32, float64

// 复数类型
complex64, complex128
```

#### 2. 布尔类型

```go
bool  // true或false
```

#### 3. 字符串类型

```go
string  // UTF-8编码的字符串

// 字符串字面量
str1 := "Hello, World!"  // 双引号
str2 := `多行
字符串`  // 反引号（原始字符串字面量）
```

### 复合类型

#### 1. 数组
固定长度的同类型元素集合：

```go
// 声明数组
var arr1 [5]int

// 初始化数组
arr2 := [3]int{1, 2, 3}
arr3 := [...]int{1, 2, 3, 4}  // 长度由初始化值决定
arr4 := [5]int{1: 10, 3: 30}  // 索引1和3的值，其余为0
```

#### 2. 切片
动态长度的数组视图：

```go
// 创建切片
slice1 := []int{1, 2, 3}  // 直接初始化
slice2 := make([]int, 5)  // 长度为5，容量为5
slice3 := make([]int, 5, 10)  // 长度为5，容量为10

// 从数组或切片创建切片
src := [5]int{1, 2, 3, 4, 5}
slice4 := src[1:4]  // 包含索引1,2,3的元素 [2,3,4]

// 切片操作
slice4 = append(slice4, 6, 7)  // 追加元素
slice5 := append(slice4[:2], slice4[3:]...)  // 删除索引2的元素
```

#### 3. 映射（Map）
键值对的无序集合：

```go
// 创建map
m1 := make(map[string]int)

// 初始化map
m2 := map[string]int{
    "apple":  5,
    "orange": 3,
}

// 操作map
m1["banana"] = 10  // 添加或更新
value, exists := m1["apple"]  // 检查键是否存在
delete(m1, "banana")  // 删除键值对
```

#### 4. 结构体
自定义的数据类型，包含多个字段：

```go
// 定义结构体
type Person struct {
    Name  string
    Age   int
    Email string
}

// 创建结构体实例
p1 := Person{Name: "Alice", Age: 30}
var p2 Person
p2.Name = "Bob"
```

#### 5. 指针
存储变量内存地址的变量：

```go
// 声明指针
var ptr *int

// 获取地址
num := 10
ptr = &num

// 解引用
fmt.Println(*ptr)  // 输出10

// 指针作为函数参数
func increment(x *int) {
    *x++
}
```

## 三、函数

### 基本函数定义

```go
func functionName(parameter1 type1, parameter2 type2) returnType {
    // 函数体
    return value
}

// 示例
func add(a int, b int) int {
    return a + b
}

// 参数列表中相同类型可以简写
func multiply(a, b int) int {
    return a * b
}
```

### 多返回值
Go支持函数返回多个值：

```go
func divide(a, b float64) (float64, error) {
    if b == 0 {
        return 0, fmt.Errorf("division by zero")
    }
    return a / b, nil
}

// 使用命名返回值
func calculateStats(numbers []int) (min, max, sum int) {
    if len(numbers) == 0 {
        return
    }
    min, max = numbers[0], numbers[0]
    for _, n := range numbers {
        if n < min { min = n }
        if n > max { max = n }
        sum += n
    }
    return  // 自动返回已命名的返回值
}
```

### 可变参数函数

```go
func sum(numbers ...int) int {
    total := 0
    for _, n := range numbers {
        total += n
    }
    return total
}

// 调用方式
sum(1, 2, 3)
sum(4, 5, 6, 7)

// 将切片作为可变参数传递
nums := []int{8, 9, 10}
sum(nums...)
```

### 函数作为值

```go
// 函数类型定义
type Operator func(int, int) int

// 定义函数
func add(a, b int) int { return a + b }
func subtract(a, b int) int { return a - b }

// 函数作为参数
func calculate(a, b int, op Operator) int {
    return op(a, b)
}

// 函数作为返回值
func getOperator(operation string) Operator {
    switch operation {
    case "add":
        return add
    case "subtract":
        return subtract
    default:
        return nil
    }
}
```

### 闭包

```go
func counter() func() int {
    count := 0
    return func() int {
        count++
        return count
    }
}

// 使用闭包
c := counter()
c()  // 返回1
c()  // 返回2
```

## 四、方法

### 结构体方法
为结构体定义方法（接收器）：

```go
type Rectangle struct {
    Width, Height float64
}

// 值接收器
func (r Rectangle) Area() float64 {
    return r.Width * r.Height
}

// 指针接收器（可以修改结构体字段）
func (r *Rectangle) Scale(factor float64) {
    r.Width *= factor
    r.Height *= factor
}

// 使用方法
rect := Rectangle{Width: 10, Height: 5}
area := rect.Area()  // 使用值接收器
rect.Scale(2)  // 使用指针接收器，修改rect
```

## 五、控制流

### 条件语句

#### 1. if语句

```go
if x > 10 {
    fmt.Println("x is greater than 10")
} else if x < 10 {
    fmt.Println("x is less than 10")
} else {
    fmt.Println("x is 10")
}

// if语句中的初始化语句
if y := calculateValue(); y > 0 {
    fmt.Println("Positive value")
}
```

#### 2. switch语句

```go
switch day {
case "Monday":
    fmt.Println("Start of the week")
case "Friday":
    fmt.Println("End of the work week")
case "Saturday", "Sunday":
    fmt.Println("Weekend")
default:
    fmt.Println("Midweek")
}

// 无表达式switch（相当于多个if-else）
switch {
case x < 0:
    fmt.Println("Negative")
case x == 0:
    fmt.Println("Zero")
case x > 0:
    fmt.Println("Positive")
}
```

### 循环语句

#### 1. for循环

```go
// 基本for循环
for i := 0; i < 10; i++ {
    fmt.Println(i)
}

// while风格
for i < 10 {
    i++
}

// 无限循环
for {
    // 需要在循环内使用break跳出
}

// for-range循环（用于数组、切片、map等）
for index, value := range collection {
    fmt.Printf("Index: %d, Value: %v\n", index, value)
}

// 忽略索引或值
for _, value := range collection {}
for index := range collection {}
```

### 跳转语句

```go
// break语句
for i := 0; i < 10; i++ {
    if i == 5 {
        break  // 跳出循环
    }
}

// continue语句
for i := 0; i < 10; i++ {
    if i%2 == 0 {
        continue  // 跳过当前迭代
    }
}

// goto语句（不推荐频繁使用）
flag:
    fmt.Println("Jumped to label")
    goto flag
```

## 六、错误处理

### 错误返回
Go使用返回值处理错误，通常是最后一个返回值：

```go
func processFile(filename string) ([]byte, error) {
    data, err := ioutil.ReadFile(filename)
    if err != nil {
        return nil, fmt.Errorf("error reading file %s: %w", filename, err)
    }
    return data, nil
}

// 调用时检查错误
content, err := processFile("example.txt")
if err != nil {
    log.Fatal(err)
}
```

### defer语句
`defer`语句用于延迟函数的执行，直到包含它的函数返回：

```go
func readFile(filename string) error {
    file, err := os.Open(filename)
    if err != nil {
        return err
    }
    defer file.Close()  // 确保文件关闭
    
    // 读取文件内容
    // ...
    
    return nil
}
```

### panic和recover

```go
// 触发panic
func panicFunction() {
    panic("something went wrong")
}

// 使用recover捕获panic
func safeFunction() {
    defer func() {
        if r := recover(); r != nil {
            fmt.Println("Recovered from:", r)
        }
    }()
    panicFunction()
}
```

## 七、接口

### 接口定义

```go
type Reader interface {
    Read(p []byte) (n int, err error)
}

// 空接口可以存储任何类型的值
type emptyInterface interface{}
```

### 接口实现
Go的接口是隐式实现的，不需要显式声明：

```go
// 定义一个结构体
type File struct {
    // 字段
}

// 实现Reader接口的Read方法
func (f *File) Read(p []byte) (n int, err error) {
    // 实现读取逻辑
    return 0, nil
}

// 现在*File类型实现了Reader接口
func processData(r Reader) {
    // 处理实现了Reader接口的数据
}
```

## 八、包管理

### 导入包

```go
// 标准导入
import (
    "fmt"
    "time"
)

// 别名导入
import (
    f "fmt"
    t "time"
)

// 匿名导入（仅执行包的init函数）
import _ "net/http/pprof"
```

### 导出标识符
在Go中，以大写字母开头的标识符是可导出的（公共的）：

```go
// 可导出的变量
var PublicVar = 100

// 不可导出的变量
var privateVar = 50

// 可导出的函数
func PublicFunction() {}

// 可导出的结构体和字段
type PublicStruct struct {
    ExportedField int
    privateField  int
}
```

## 九、类型转换和断言

### 类型转换

```go
var i int = 42
var f float64 = float64(i)
var u uint = uint(f)
```

### 类型断言

```go
// 基础类型断言
var i interface{} = "hello"
s, ok := i.(string)
if ok {
    fmt.Println(s)
}

// 接口断言
var r Reader = getReader()
if fr, ok := r.(*FileReader); ok {
    fr.SpecificMethod()
}
```

## 总结
本文档涵盖了Go语言的基本语法要素，包括变量常量、数据类型、函数方法、控制流、错误处理等核心概念。Go语言简洁明了的语法设计使其易于学习和使用，同时也保证了代码的可读性和可维护性。对于更深入的内容，建议参考官方文档或进阶教程。

最后更新时间：2023-08-15