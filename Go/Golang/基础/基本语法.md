# Golang 基本语法
## 一、包与入口点

### 包声明

#### 1. 包的语法与作用

**Go语言中的包是代码组织的基本单位**，具有以下特点：

- **语法规则**：每个Go源文件必须以`package 包名`语句开头，这是Go程序的强制要求
- **包名规范**：包名应简短、清晰、有意义，通常使用小写字母，不使用下划线或驼峰命名
- **代码组织**：包将相关的功能代码组织在一起，实现代码的模块化和复用
- **命名空间隔离**：不同包中的标识符不会产生命名冲突，提供了命名空间的隔离机制
- **访问控制**：通过标识符首字母大小写控制跨包访问权限
- **目录与包的关系**：**同一个目录下的所有Go源文件必须属于同一个包**，这是Go语言的强制规定
- **内部访问**：同一包内的所有函数、变量、类型等可以直接相互访问，无论标识符首字母大小写

**多文件包的工作方式**：

当一个包由多个源文件组成时：
1. 所有文件共享同一个包的命名空间
2. 所有文件中的全局变量、函数和类型对彼此可见
3. 编译时，Go编译器会将所有文件的内容合并处理
4. 包级别的变量和init函数会按照特定规则进行初始化

**init函数在多文件场景下的执行顺序**：

- **同一源文件内**：init函数按照它们在源文件中声明的先后顺序执行
- **不同源文件间**：init函数的执行顺序是不确定的，取决于编译器读取文件的顺序（通常按文件名排序，但不保证）
- **包级变量与init函数**：包级变量的初始化总是先于init函数的执行
- **跨包依赖**：如果包A导入了包B，那么包B的所有init函数会先于包A的init函数执行

**实际应用注意事项**：
- 编写代码时应避免依赖不同文件间init函数的执行顺序
- 对于有明确初始化依赖关系的代码，应将它们放在同一个源文件中
- 复杂的初始化逻辑可以封装在init函数中，确保资源正确初始化


#### 2. 包的类型

- **main包**：特殊的包，用于构建可执行程序，必须包含一个无参数无返回值的`main()`函数作为程序入口
- **普通包**：用于提供库功能，可以被其他包导入使用

```go
// main包示例
package main

func main() {
    // 程序入口点
}

// 普通包示例
package mathutils

func Add(a, b int) int {
    return a + b
}
```

#### 3. 包初始化

包在被导入时会执行初始化过程：

- 初始化包级变量（按照声明顺序和依赖关系）
- 按声明顺序执行`init()`函数（如果有）
- 一个包可以有多个`init()`函数，按它们在源文件中出现的顺序执行
- 同一个包的多个源文件中，不同文件间init函数的执行顺序不确定
- `init()`函数没有参数和返回值，不能被显式调用

```go
package example

var count = initCount()

func initCount() int {
    return 100
}

func init() {
    // 第一个初始化函数
    count *= 2
}

func init() {
    // 第二个初始化函数
    count += 10
}
```

### 主函数
程序执行的入口点是`main`包中的`main`函数，它没有参数和返回值：

```go
package main

func main() {
    // 程序执行代码
    fmt.Println("Hello, World!")
}
```

### 导入包

#### 1. 导入语法

使用`import`关键字导入其他包，支持以下几种形式：

```go
// 标准导入 - 导入多个包
import (
    "fmt"       // 标准输出包
    "math"      // 数学函数包
    "os"
)

// 单行导入 - 导入单个包
import "fmt"
```

#### 2. 包导入的作用

- **代码复用**：可以使用其他包提供的公共函数、类型和变量
- **功能扩展**：通过导入不同的包来扩展程序功能
- **避免重复造轮子**：利用Go标准库和第三方库的功能

#### 3. 特殊导入形式

- **别名导入**：为导入的包指定别名，避免命名冲突或简化引用
- **匿名导入**：使用下划线`_`导入包但不直接使用，仅执行包的初始化过程

```go
// 别名导入
import (
    f "fmt"       // 将fmt包重命名为f
    m "math"      // 将math包重命名为m
)

// 使用别名
func main() {
    f.Println("Hello with alias")
    result := m.Sqrt(16)
}

// 匿名导入
import (
    _ "database/sql"  // 仅执行初始化，注册数据库驱动
)
```

#### 4. 导入路径

- **标准库包**：直接使用包名，如`fmt`、`math`
- **自定义包**：使用相对路径或模块路径，如`./utils`或`github.com/user/project/utils`
- **第三方包**：使用模块路径，通常是它们的仓库地址

#### 5. 包导入的解析过程

1. Go编译器首先在GOPATH和GOROOT中查找导入的包
2. 对于模块项目，会在go.mod文件中定义的模块路径下查找
3. 如果找不到包，会产生编译错误
4. 如果包被导入但未使用，也会产生编译错误（可以通过匿名导入解决）

## 二、变量与常量

### 变量声明

变量是程序中用于存储和操作数据的基本单元。Go语言提供了多种变量声明方式，每种方式都有其适用场景。

#### 1. var关键字

`var`关键字是Go语言声明变量的标准方式，适用于所有变量声明场景：

```go
// 声明单个变量 - 未初始化的变量会被赋予该类型的零值
var name string  // 空字符串
var age int      // 0
var isActive bool // false

// 声明并初始化
var counter int = 100
var greeting string = "Hello, Go!"

// 多个变量声明 - 可同时声明多个不同类型的变量
var (
    firstName string = "John"
    lastName  string = "Doe"
    height    float64 = 1.75
    weight    float64 = 75.5
    isStudent bool = true
)

// 类型推断 - 不指定类型时，Go编译器会根据初始化值自动推断类型
var count = 10      // 自动推断为int
var pi = 3.14159    // 自动推断为float64
var message = "Go语言"  // 自动推断为string
```

**零值机制**：Go语言中，未初始化的变量会被自动赋予该类型的零值，这是Go语言的一个重要特性，可以避免使用未初始化的变量导致的错误。
- 数值类型：0
- 布尔类型：false
- 字符串类型：""（空字符串）
- 指针、切片、映射、通道、函数和接口：nil

#### 2. 短变量声明

在函数内部，可以使用`:=`运算符进行短变量声明，这是Go语言中最常用的变量声明方式，代码更加简洁：

```go
func main() {
    // 基本的短变量声明
    score := 95  // 等价于 var score int = 95
    
    // 多变量同时声明
    name, age := "Alice", 30
    
    // 重新赋值 - 在同一作用域内，可以使用短变量声明来重新赋值，但至少有一个变量必须是新声明的
    name, newVar := "Bob", true
    
    // 函数返回值赋值
    result, err := calculate(10, 20)
    if err != nil {
        // 错误处理
    }
}
```

**注意事项**：
- 短变量声明只能在函数内部使用，不能在包级作用域使用
- 短变量声明必须至少声明一个新变量
- 短变量声明会自动进行类型推断

### 常量定义

常量是程序中在编译时就确定的值，运行时不可修改。Go语言使用`const`关键字定义常量。

```go
// 基本常量声明
const PI float64 = 3.1415926535
const MAX_RETRY int = 3
const APP_NAME string = "GoApplication"

// 常量组 - 可以同时声明多个常量
const (
    STATUS_ACTIVE   = 1
    STATUS_INACTIVE = 0
    STATUS_PENDING  = 2
    MAX_SIZE        = 1024
)

// 无类型常量 - 不指定类型的常量，在使用时可以根据上下文自动转换为适当的类型
const ANSWER = 42
const RATE = 0.75

// 类型推断的常量
const COUNT = 100    // 无类型整数常量
const PI_APPROX = 3.14 // 无类型浮点常量
```

**常量的特点**：
- 常量必须在声明时初始化
- 常量的值必须是编译时常量表达式
- 常量可以是数值、字符串或布尔值
- 无类型常量可以根据上下文自动转换类型

### iota枚举

`iota`是Go语言的一个预定义标识符，用于创建枚举常量。它在常量声明中会从0开始递增，每个新行递增1。

```go
// 基本的iota使用
const (
    MONDAY = iota  // 0
    TUESDAY        // 1
    WEDNESDAY      // 2
    THURSDAY       // 3
    FRIDAY         // 4
    SATURDAY       // 5
    SUNDAY         // 6
)

// 带表达式的iota
const (
    _ = iota  // 跳过第一个值，从1开始计数
    KB = 1 << (10 * iota)  // 1 << 10 = 1024
    MB                     // 1 << 20 = 1,048,576
    GB                     // 1 << 30 = 1,073,741,824
    TB                     // 1 << 40 = 1,099,511,627,776
)

// 复杂表达式示例
const (
    BIT_0 = 1 << iota  // 1 << 0 = 1
    BIT_1              // 1 << 1 = 2
    BIT_2              // 1 << 2 = 4
    _                  // 跳过一个值
    BIT_4              // 1 << 4 = 16
)

// 多个iota重置
const (
    A = iota  // 0
    B         // 1
)

const (
    C = iota  // 0，新的常量组重新从0开始计数
    D         // 1
)

**iota的应用场景**：
- 创建连续的整数值常量
- 定义位掩码和标志位
- 创建与位移、乘法等操作结合的常量序列
- 表示状态码、错误码等需要连续值的场景

**iota使用技巧**：
- 使用下划线`_`跳过不需要的值
- 可以在一个常量组中使用多个iota表达式
- 可以结合各种运算符创建复杂的常量序列
- 每个新的常量组都会重置iota的值为0

## 三、数据类型

### 基本类型

#### 1. 数值类型

```go
// 整数类型
int8, int16, int32, int64     // 有符号整数
uint8, uint16, uint32, uint64 // 无符号整数
int, uint                     // 与操作系统架构相关的整数类型
uintptr                       // 用于指针运算的无符号整数

// 浮点类型
float32, float64

// 复数类型
complex64, complex128
```

#### 2. 布尔类型

```go
bool  // true或false
```

#### 3. 字符串类型

```go
string  // UTF-8编码的字符串

// 字符串字面量
str1 := "Hello, World!"  // 双引号
str2 := `多行
字符串`  // 反引号（原始字符串字面量）
```

### 复合类型

#### 1. 数组
固定长度的同类型元素集合：

```go
// 声明数组
var arr1 [5]int

// 初始化数组
arr2 := [3]int{1, 2, 3}
arr3 := [...]int{1, 2, 3, 4}  // 长度由初始化值决定
arr4 := [5]int{1: 10, 3: 30}  // 索引1和3的值，其余为0
```

#### 2. 切片
动态长度的数组视图：

```go
// 创建切片
slice1 := []int{1, 2, 3}  // 直接初始化
slice2 := make([]int, 5)  // 长度为5，容量为5
slice3 := make([]int, 5, 10)  // 长度为5，容量为10

// 从数组或切片创建切片
src := [5]int{1, 2, 3, 4, 5}
slice4 := src[1:4]  // 包含索引1,2,3的元素 [2,3,4]

// 切片操作
slice4 = append(slice4, 6, 7)  // 追加元素
slice5 := append(slice4[:2], slice4[3:]...)  // 删除索引2的元素
```

#### 3. 映射（Map）
键值对的无序集合：

```go
// 创建map
m1 := make(map[string]int)

// 初始化map
m2 := map[string]int{
    "apple":  5,
    "orange": 3,
}

// 操作map
m1["banana"] = 10  // 添加或更新
value, exists := m1["apple"]  // 检查键是否存在
delete(m1, "banana")  // 删除键值对
```

#### 4. 结构体
自定义的数据类型，包含多个字段：

```go
// 定义结构体
type Person struct {
    Name  string
    Age   int
    Email string
}

// 创建结构体实例
p1 := Person{Name: "Alice", Age: 30}
var p2 Person
p2.Name = "Bob"
```

#### 5. 指针
存储变量内存地址的变量：

```go
// 声明指针
var ptr *int

// 获取地址
num := 10
ptr = &num

// 解引用
fmt.Println(*ptr)  // 输出10

// 指针作为函数参数
func increment(x *int) {
    *x++
}
```

## 四、函数

### 基本函数定义

```go
func functionName(parameter1 type1, parameter2 type2) returnType {
    // 函数体
    return value
}

// 示例
func add(a int, b int) int {
    return a + b
}

// 参数列表中相同类型可以简写
func multiply(a, b int) int {
    return a * b
}
```

### 多返回值
Go支持函数返回多个值：

```go
func divide(a, b float64) (float64, error) {
    if b == 0 {
        return 0, fmt.Errorf("division by zero")
    }
    return a / b, nil
}

// 使用命名返回值
func calculateStats(numbers []int) (min, max, sum int) {
    if len(numbers) == 0 {
        return
    }
    min, max = numbers[0], numbers[0]
    for _, n := range numbers {
        if n < min { min = n }
        if n > max { max = n }
        sum += n
    }
    return  // 自动返回已命名的返回值
}
```

### 可变参数函数

```go
func sum(numbers ...int) int {
    total := 0
    for _, n := range numbers {
        total += n
    }
    return total
}

// 调用方式
sum(1, 2, 3)
sum(4, 5, 6, 7)

// 将切片作为可变参数传递
nums := []int{8, 9, 10}
sum(nums...)
```

### 函数作为值

```go
// 函数类型定义
type Operator func(int, int) int

// 定义函数
func add(a, b int) int { return a + b }
func subtract(a, b int) int { return a - b }

// 函数作为参数
func calculate(a, b int, op Operator) int {
    return op(a, b)
}

// 函数作为返回值
func getOperator(operation string) Operator {
    switch operation {
    case "add":
        return add
    case "subtract":
        return subtract
    default:
        return nil
    }
}
```

### 闭包

```go
func counter() func() int {
    count := 0
    return func() int {
        count++
        return count
    }
}

// 使用闭包
c := counter()
c()  // 返回1
c()  // 返回2
```

## 五、方法

### 结构体方法
为结构体定义方法（接收器）：

```go
type Rectangle struct {
    Width, Height float64
}

// 值接收器
func (r Rectangle) Area() float64 {
    return r.Width * r.Height
}

// 指针接收器（可以修改结构体字段）
func (r *Rectangle) Scale(factor float64) {
    r.Width *= factor
    r.Height *= factor
}

// 使用方法
rect := Rectangle{Width: 10, Height: 5}
area := rect.Area()  // 使用值接收器
rect.Scale(2)  // 使用指针接收器，修改rect
```

## 六、控制流

### 条件语句

#### 1. if语句

```go
if x > 10 {
    fmt.Println("x is greater than 10")
} else if x < 10 {
    fmt.Println("x is less than 10")
} else {
    fmt.Println("x is 10")
}

// if语句中的初始化语句
if y := calculateValue(); y > 0 {
    fmt.Println("Positive value")
}
```

#### 2. switch语句

```go
switch day {
case "Monday":
    fmt.Println("Start of the week")
case "Friday":
    fmt.Println("End of the work week")
case "Saturday", "Sunday":
    fmt.Println("Weekend")
default:
    fmt.Println("Midweek")
}

// 无表达式switch（相当于多个if-else）
switch {
case x < 0:
    fmt.Println("Negative")
case x == 0:
    fmt.Println("Zero")
case x > 0:
    fmt.Println("Positive")
}
```

### 循环语句

#### 1. for循环

```go
// 基本for循环
for i := 0; i < 10; i++ {
    fmt.Println(i)
}

// while风格
for i < 10 {
    i++
}

// 无限循环
for {
    // 需要在循环内使用break跳出
}

// for-range循环（用于数组、切片、map等）
for index, value := range collection {
    fmt.Printf("Index: %d, Value: %v\n", index, value)
}

// 忽略索引或值
for _, value := range collection {}
for index := range collection {}
```

### 跳转语句

```go
// break语句
for i := 0; i < 10; i++ {
    if i == 5 {
        break  // 跳出循环
    }
}

// continue语句
for i := 0; i < 10; i++ {
    if i%2 == 0 {
        continue  // 跳过当前迭代
    }
}

// goto语句（不推荐频繁使用）
flag:
    fmt.Println("Jumped to label")
    goto flag
```

## 七、错误处理

### 错误返回
Go使用返回值处理错误，通常是最后一个返回值：

```go
func processFile(filename string) ([]byte, error) {
    data, err := ioutil.ReadFile(filename)
    if err != nil {
        return nil, fmt.Errorf("error reading file %s: %w", filename, err)
    }
    return data, nil
}

// 调用时检查错误
content, err := processFile("example.txt")
if err != nil {
    log.Fatal(err)
}
```

### defer语句
`defer`语句用于延迟函数的执行，直到包含它的函数返回：

```go
func readFile(filename string) error {
    file, err := os.Open(filename)
    if err != nil {
        return err
    }
    defer file.Close()  // 确保文件关闭
    
    // 读取文件内容
    // ...
    
    return nil
}
```

### panic和recover

```go
// 触发panic
func panicFunction() {
    panic("something went wrong")
}

// 使用recover捕获panic
func safeFunction() {
    defer func() {
        if r := recover(); r != nil {
            fmt.Println("Recovered from:", r)
        }
    }()
    panicFunction()
}
```

## 八、接口

### 接口定义

```go
type Reader interface {
    Read(p []byte) (n int, err error)
}

// 空接口可以存储任何类型的值
type emptyInterface interface{}
```

### 接口实现
Go的接口是隐式实现的，不需要显式声明：

```go
// 定义一个结构体
type File struct {
    // 字段
}

// 实现Reader接口的Read方法
func (f *File) Read(p []byte) (n int, err error) {
    // 实现读取逻辑
    return 0, nil
}

// 现在*File类型实现了Reader接口
func processData(r Reader) {
    // 处理实现了Reader接口的数据
}
```

## 九、包管理

### 导入包

```go
// 标准导入
import (
    "fmt"
    "time"
)

// 别名导入
import (
    f "fmt"
    t "time"
)

// 匿名导入（仅执行包的init函数）
import _ "net/http/pprof"
```

### 导出标识符
在Go中，以大写字母开头的标识符是可导出的（公共的）：

```go
// 可导出的变量
var PublicVar = 100

// 不可导出的变量
var privateVar = 50

// 可导出的函数
func PublicFunction() {}

// 可导出的结构体和字段
type PublicStruct struct {
    ExportedField int
    privateField  int
}
```

## 十、类型转换和断言

### 类型转换

```go
var i int = 42
var f float64 = float64(i)
var u uint = uint(f)
```

### 类型断言

```go
// 基础类型断言
var i interface{} = "hello"
s, ok := i.(string)
if ok {
    fmt.Println(s)
}

// 接口断言
var r Reader = getReader()
if fr, ok := r.(*FileReader); ok {
    fr.SpecificMethod()
}
```

## 总结
本文档涵盖了Go语言的基本语法要素，包括变量常量、数据类型、函数方法、控制流、错误处理等核心概念。Go语言简洁明了的语法设计使其易于学习和使用，同时也保证了代码的可读性和可维护性。对于更深入的内容，建议参考官方文档或进阶教程。

最后更新时间：2023-08-15