# 错误处理

## 一、错误处理基础认知

### 1.1 什么是Golang错误？

Golang中错误是实现了内置`error`接口的类型实例，核心通过返回值传递错误信息，而非抛出异常。其设计理念强调“错误是状态，需显式处理”，区别于传统异常机制。

```go

// 内置error接口定义（builtin包）
type error interface {
    Error() string // 返回错误描述信息
}
```

### 1.2 核心设计原则

- **显式返回**：错误作为函数返回值明确声明，调用者必须主动处理或显式忽略

- **无异常捕获**：不提供`try/catch`，避免逻辑跳转混乱

- **轻量可扩展**：基础错误简洁，支持自定义错误携带更多上下文

## 二、核心用法：基础错误处理

### 2.1 错误创建

Golang提供两种基础错误创建方式，分别适用于简单场景和格式化场景。

```go

import (
    "errors"
    "fmt"
)

func main() {
    // 1. errors.New：创建简单错误（仅含描述）
    err1 := errors.New("参数错误")
    fmt.Println(err1.Error()) // 输出：参数错误

    // 2. fmt.Errorf：创建格式化错误（支持变量插入）
    userId := 123
    err2 := fmt.Errorf("用户ID=%d不存在", userId)
    fmt.Println(err2) // 输出：用户ID=123不存在
}
```

### 2.2 错误返回与判断

函数返回错误时需将其置于最后一位（Golang惯例），调用者通过判断错误是否为`nil`处理。

```go

// 模拟查询用户的函数，返回结果和错误
func getUserById(id int) (string, error) {
    if id <= 0 {
        return "", fmt.Errorf("无效ID：%d（必须大于0）", id)
    }
    if id == 100 {
        return "张三", nil // 无错误返回nil
    }
    return "", errors.New("用户未找到")
}

func main() {
    // 调用函数后优先判断错误
    user, err := getUserById(-5)
    if err != nil {
        fmt.Println("处理失败：", err) // 输出：处理失败：无效ID：-5（必须大于0）
        return
    }
    fmt.Println("查询成功：", user)
}
```

黄金法则：调用函数后，**必须先判断错误，再使用其他返回值**，避免错误状态下使用无效数据。

## 三、进阶技巧：错误链与自定义错误

### 3.1 错误包装与解包（Go 1.13+）

多层函数调用时，用`%w`包装错误保留上下文，通过`errors`包工具解包。

```go

import "errors"

// 底层函数：返回原始错误
func readData() error {
    return errors.New("文件读取失败")
}

// 上层函数：包装错误并添加上下文
func processData() error {
    err := readData()
    if err != nil {
        return fmt.Errorf("数据处理异常：%w", err) // %w包装原始错误
    }
    return nil
}

func main() {
    err := processData()
    if err != nil {
        fmt.Println("总错误：", err) // 输出：总错误：数据处理异常：文件读取失败

        // 1. 解包获取原始错误
        rawErr := errors.Unwrap(err)
        fmt.Println("原始错误：", rawErr) // 输出：原始错误：文件读取失败

        // 2. 判断错误链是否包含目标错误
        target := errors.New("文件读取失败")
        if errors.Is(err, target) {
            fmt.Println("错误链中存在文件读取失败") // 输出：存在目标错误
        }
    }
}
```

### 3.2 自定义错误类型

通过实现`error`接口，创建携带错误码、时间等信息的自定义错误。

```go

import "time"

// 自定义错误结构体
type BusinessError struct {
    Code    int       // 业务错误码
    Message string    // 错误描述
    Time    time.Time // 错误发生时间
}

// 实现error接口的Error()方法（必须）
func (e *BusinessError) Error() string {
    return fmt.Sprintf("[%s] 错误码%d：%s", e.Time.Format("2006-01-02 15:04:05"), e.Code, e.Message)
}

// 工厂函数：创建自定义错误
func NewBusinessError(code int, msg string) *BusinessError {
    return &BusinessError{
        Code:    code,
        Message: msg,
        Time:    time.Now(),
    }
}

// 使用自定义错误
func checkBalance(amount float64) error {
    if amount < 0 {
        return NewBusinessError(400, fmt.Sprintf("余额非法：%.2f", amount))
    }
    return nil
}

func main() {
    err := checkBalance(-100.5)
    if err != nil {
        fmt.Println("业务错误：", err) // 输出：[2024-06-01 10:00:00] 错误码400：余额非法：-100.50

        // 类型断言获取详细信息
        if bErr, ok := err.(*BusinessError); ok {
            fmt.Println("错误码：", bErr.Code) // 输出：错误码：400
        }
    }
}
```

## 四、特殊场景：panic 与 recover

Golang中`panic`触发致命异常，`recover`捕获异常避免程序崩溃，**仅用于不可恢复场景**。

```go

func riskyFunc() {
    // 模拟致命错误，触发panic
    panic("内存分配失败：无法继续")
}

func safeFunc() {
    // defer+recover捕获panic
    defer func() {
        if r := recover(); r != nil { // 捕获panic的值
            fmt.Println("捕获异常：", r) // 输出：捕获异常：内存分配失败：无法继续
        }
    }()
    riskyFunc()
    fmt.Println("此句不会执行")
}

func main() {
    safeFunc()
    fmt.Println("程序正常退出") // 输出：程序正常退出
}
```

关键注意：

① **子goroutine panic默认导致程序崩溃**（Go 1.21前）：子goroutine无独立异常隔离，未捕获panic会终止整个程序；Go 1.21起可通过`runtime/debug`包配置隔离，但非默认行为；

② **禁止用panic处理常规业务错误**：无论主/子goroutine，panic都可能引发程序崩溃，仅用于不可恢复场景；

③ **子goroutine必须防护panic**：启动子goroutine时，必须在内部添加`defer+recover`防护，避免单个goroutine错误导致整体崩溃；

④ **主goroutine防护优先级**：主goroutine更需顶层recover防护，但其panic未捕获必然导致程序崩溃。

## 五、实践规范

### 5.1 错误返回规范

- **错误后置**：函数返回错误时，始终作为最后一个返回值

- **信息完整**：错误描述需包含“场景+原因”，避免模糊表述（如不用“失败”，用“查询用户失败：数据库超时”）

- **nil保证**：错误非nil时，其他返回值应为零值或无效值

### 5.2 错误处理规范

- **不随意忽略**：仅明确无影响时用`_`忽略，需加注释说明原因

- **错误链清晰**：多层调用必须用`%w`包装，保留原始错误上下文

- **集中处理**：复杂业务可封装统一错误处理函数，减少重复代码

### 5.3 自定义错误规范

- **必实现Error()**：自定义类型必须正确实现`error`接口

- **携带关键信息**：根据需求添加错误码、请求ID等定位信息

## 六、常见问题自查

1. Q：错误为nil时，为何调用Error()会panic？
A：调用方法会触发空指针panic，需先判断`err == nil`。

2. Q：如何判断错误链中是否有特定类型错误？
A：用`errors.As(err, &targetErr)`，支持类型断言错误链中的自定义错误。

3. Q：panic和error的区别？
A：error是可处理的状态，不终止程序；panic是致命异常，会终止goroutine（除非被recover捕获）。

4. Q：为何不推荐用recover捕获所有panic？
A：过度捕获会掩盖真正的致命错误，增加排查难度，仅在顶层函数（如HTTP handler）中用于防止程序崩溃。

5. Q：goroutine中发生panic未捕获会怎么样？
A：① 核心规则（Go 1.21前默认）：无论主/子goroutine，未捕获panic都会导致**整个程序崩溃**，因goroutine无独立异常隔离；

    ② Go 1.21+特性：可通过`runtime/debug.SetPanicOnFault(true)`等配置实现子goroutine panic隔离，但非默认；

    ③ 最佳实践：所有goroutine（尤其是子goroutine）必须添加`defer+recover`防护，避免单个错误崩溃整体程序。
> （注：文档部分内容可能由 AI 生成）