# 结构体与方法

## 一、结构体基础认知

### 1.1 什么是结构体？

结构体（struct）是Go语言中用于封装多个不同类型数据的聚合类型，可将零散的变量组合成一个有意义的整体，是实现面向对象编程中“类”概念的核心载体。

### 1.2 核心作用

- **数据封装**：将相关联的不同类型数据（如用户的姓名、年龄、性别）打包成一个结构体类型，增强数据关联性

- **类型定义**：通过自定义结构体，创建符合业务场景的专属类型（如User、Order、Product）

- **方法载体**：结构体可绑定方法，实现“属性+行为”的面向对象特性（类似类的成员方法）

## 二、结构体核心用法

### 2.1 结构体定义

语法：`type 结构体名 struct { 字段名 字段类型; 字段名 字段类型 ... }`，字段名首字母大小写控制访问权限（大写跨包可访问，小写仅包内访问）。

```go

// 1. 基础结构体定义（用户类型）
type User struct {
    Name string // 首字母大写，跨包可访问
    Age  int    // 首字母大写，跨包可访问
    addr string // 首字母小写，仅包内访问（私有字段）
}

// 2. 嵌套结构体（结构体字段为另一个结构体）
type Address struct {
    Province string
    City     string
}

// 嵌套Address的User结构体
type UserWithAddr struct {
    Name    string
    Age     int
    Address Address // 嵌套结构体作为字段
}

// 3. 匿名结构体（临时使用，无需定义结构体名）
func main() {
    // 直接定义匿名结构体并赋值
    tempUser := struct {
        Name string
        Age  int
    }{
        Name: "临时用户",
        Age:  25,
    }
    fmt.Println(tempUser.Name) // 输出：临时用户
}
```

字段访问权限规则：结构体字段首字母大写为“导出字段”（跨包可访问），首字母小写为“未导出字段”（仅当前包可访问），结构体名访问权限同理。

### 2.2 结构体变量创建与初始化

支持多种初始化方式，推荐使用“键值对初始化”（清晰易维护，不受字段顺序影响）。

```go

func main() {
    // 1. 键值对初始化（推荐）：指定字段名赋值，顺序可任意
    u1 := User{
        Name: "张三",
        Age:  28,
        // addr: "北京" // 可赋值，但仅包内可访问
    }
    fmt.Println(u1.Name, u1.Age) // 输出：张三 28

    // 2. 顺序初始化：按结构体字段声明顺序赋值，不可省略字段（需包含所有字段）
    u2 := User{"李四", 30, "上海"}
    fmt.Println(u2.Name) // 输出：李四

    // 3. 先声明后赋值：默认字段为对应类型零值
    var u3 User
    u3.Name = "王五" // 给字段赋值
    u3.Age = 32
    fmt.Println(u3.Name) // 输出：王五

    // 4. 嵌套结构体初始化
    u4 := UserWithAddr{
        Name: "赵六",
        Age:  26,
        Address: Address{ // 嵌套结构体赋值
            Province: "广东",
            City:     "深圳",
        },
    }
    fmt.Println(u4.Address.City) // 输出：深圳
}
```

### 2.3 结构体字段访问与修改

通过“结构体变量.字段名”访问或修改字段值，未导出字段（首字母小写）仅包内可修改。

```go

func main() {
    var u User
    u.Name = "张三" // 修改导出字段
    u.Age = 28     // 修改导出字段
    // u.addr = "北京" // 包内可修改，跨包编译报错

    // 访问字段
    fmt.Println("姓名：", u.Name) // 输出：姓名：张三
    fmt.Println("年龄：", u.Age)  // 输出：年龄：28
}
```

### 2.4 结构体指针

通过结构体指针可直接操作结构体变量，避免结构体复制（尤其大结构体可减少性能开销），语法：`&结构体变量`获取指针，`指针变量.字段名`访问字段（Go语法糖，无需解引用）。

```go

func main() {
    // 1. 直接创建结构体指针
    uPtr1 := &User{
        Name: "张三",
        Age:  28,
    }
    // 指针访问字段（无需*解引用，Go语法糖）
    fmt.Println(uPtr1.Name) // 输出：张三
    uPtr1.Age = 29          // 指针修改字段
    fmt.Println(uPtr1.Age)  // 输出：29

    // 2. 对已有结构体取指针
    var u User
    uPtr2 := &u
    uPtr2.Name = "李四"
    fmt.Println(u.Name) // 输出：李四（指针修改影响原变量）
}
```

### 2.5 结构体标签（Tag）

结构体字段后可添加标签（字符串），用于JSON序列化、ORM映射等场景，通过反射（reflect包）获取标签内容。

```go

import "encoding/json"

// 字段添加JSON序列化标签
type User struct {
    Name string `json:"user_name"` // JSON序列化后字段名为user_name
    Age  int    `json:"user_age"`  // JSON序列化后字段名为user_age
    addr string `json:"user_addr"` // 未导出字段，JSON序列化会忽略
}

func main() {
    u := User{
        Name: "张三",
        Age:  28,
        addr: "北京",
    }
    // 结构体转JSON
    jsonData, _ := json.Marshal(u)
    fmt.Println(string(jsonData)) // 输出：{"user_name":"张三","user_age":28}（addr被忽略）
}
```

## 三、方法核心用法

### 3.1 什么是方法？

方法是绑定在特定类型（结构体类型、自定义类型）上的函数，通过“类型.方法名”调用，实现“类型关联行为”，区别于普通函数的核心是多了“接收者”参数。

### 3.2 方法定义

语法：`func (接收者参数名 接收者类型) ` `方法名(参数列表) (返回值列表) { 方法体 }`，接收者类型分为“值接收者”和“指针接收者”。

```go

// 基于User结构体定义方法
type User struct {
    Name string
    Age  int
}

// 1. 值接收者方法：接收者为结构体值，修改不影响原结构体
func (u User) SayHello() string {
    return fmt.Sprintf("大家好，我是%s，今年%d岁", u.Name, u.Age)
}

// 2. 指针接收者方法：接收者为结构体指针，修改影响原结构体
func (u *User) GrowUp() {
    u.Age++ // 指针修改原结构体字段
}

// 3. 基于自定义类型定义方法（非结构体类型也可绑定方法）
type MyInt int

func (m MyInt) Add(n MyInt) MyInt {
    return m + n
}
```

### 3.3 方法调用

通过“接收者变量.方法名()”调用，值接收者和指针接收者可相互调用（Go自动转换）。

```go

func main() {
    u := User{Name: "张三", Age: 28}

    // 调用值接收者方法
    fmt.Println(u.SayHello()) // 输出：大家好，我是张三，今年28岁

    // 调用指针接收者方法：值类型变量可直接调用，Go自动转指针
    u.GrowUp()
    fmt.Println(u.Age) // 输出：29

    // 指针变量调用方法
    uPtr := &u
    fmt.Println(uPtr.SayHello()) // 输出：大家好，我是张三，今年29岁（指针自动转值）
    uPtr.GrowUp()
    fmt.Println(uPtr.Age) // 输出：30

    // 自定义类型方法调用
    var m MyInt = 10
    fmt.Println(m.Add(5)) // 输出：15
}
```

### 3.4 接收者类型选择

|接收者类型|特点|适用场景|
|---|---|---|
|值接收者（T）|接收结构体副本，方法内修改不影响原变量|方法仅读取数据，不修改接收者状态；小结构体（复制开销小）|
|指针接收者（*T）|接收结构体指针，方法内修改影响原变量；避免复制开销|方法需修改接收者状态；大结构体（减少复制开销）；实现接口时需统一接收者类型|
### 3.5 方法与函数的区别

- **接收者**：方法有接收者（绑定特定类型），函数无接收者

- **调用方式**：方法通过“接收者.方法名()”调用，函数通过“函数名()”调用

- **关联性**：方法与接收者类型强关联，函数是独立的代码块

## 四、结构体进阶特性

### 4.1 匿名结构体字段

结构体字段可省略字段名（仅写类型），称为匿名字段，可直接通过结构体变量访问匿名字段的内部字段（字段提升）。

```go

type Address struct {
    Province string
    City     string
}

// 匿名字段（仅写类型，字段名默认为类型名）
type User struct {
    Name string
    Age  int
    Address // 匿名字段，字段名默认为Address
}

func main() {
    u := User{
        Name: "张三",
        Age:  28,
        Address: Address{
            Province: "广东",
            City:     "深圳",
        },
    }
    // 直接访问匿名字段的内部字段（字段提升）
    fmt.Println(u.Province) // 输出：广东（等价于u.Address.Province）
    fmt.Println(u.City)     // 输出：深圳
}
```

### 4.2 结构体嵌套与字段冲突

多个匿名字段存在同名内部字段时，会出现字段冲突，需通过匿名字段名显式指定访问。

```go

type A struct {
    X int
    Y int
}

type B struct {
    X string
    Z int
}

// 嵌套A和B两个匿名字段
type C struct {
    A
    B
    Name string
}

func main() {
    c := C{
        A: A{X: 10, Y: 20},
        B: B{X: "abc", Z: 30},
    }
    // c.X // 编译报错：X字段冲突（A和B都有X字段）
    fmt.Println(c.A.X) // 输出：10（通过A匿名字段访问）
    fmt.Println(c.B.X) // 输出：abc（通过B匿名字段访问）
    fmt.Println(c.Y)   // 输出：20（无冲突，直接访问）
}
```

### 4.3 结构体比较

结构体支持“==”和“!=”比较，但需满足条件：结构体所有字段都是可比较类型（如int、string、bool等，切片、映射、函数等不可比较类型会导致结构体不可比较）。

```go

type User struct {
    Name string
    Age  int
}

type UncomparableUser struct {
    Name string
    Hobbies []string // 切片不可比较，导致结构体不可比较
}

func main() {
    u1 := User{Name: "张三", Age: 28}
    u2 := User{Name: "张三", Age: 28}
    u3 := User{Name: "李四", Age: 30}

    fmt.Println(u1 == u2) // 输出：true（所有字段相等）
    fmt.Println(u1 == u3) // 输出：false（字段不相等）

    // var uu1, uu2 UncomparableUser
    // fmt.Println(uu1 == uu2) // 编译报错：结构体包含不可比较字段
}
```

## 五、实践规范

### 5.1 结构体设计规范

- **语义明确**：结构体名使用名词（如User、Order），体现业务实体含义，避免模糊命名（如Data、Info）

- **字段精简**：字段个数控制在5个以内，过多时拆分多个结构体（通过嵌套组合）

- **访问权限合理**：仅需跨包访问的字段/结构体名才大写，非必要设为私有（首字母小写）

- **避免循环嵌套**：禁止结构体A嵌套结构体B，结构体B又嵌套结构体A（编译报错）

### 5.2 方法设计规范

- **接收者命名简洁**：接收者参数名用1-2个小写字母（如结构体User的接收者用u，指针接收者也用u）

- **统一接收者类型**：同一结构体的方法接收者类型保持一致（全用值接收者或全用指针接收者，避免混合）

- **方法名语义匹配**：值接收者方法名体现“读取”语义（如GetName、SayHello），指针接收者方法名体现“修改”语义（如SetAge、GrowUp）

- **避免方法过度耦合**：方法仅操作接收者自身或通过参数传入的数据，不依赖全局变量

### 5.3 其他实践要点

- 大结构体（字段多或字段类型大）优先使用指针传递和指针接收者，减少复制开销

- JSON序列化时，确保需要序列化的字段首字母大写（导出字段），通过标签统一JSON字段命名风格（如蛇形命名）

- 结构体作为函数参数时，若需修改结构体内容，传入指针；仅读取则传入值或指针均可（小结构体传值更简洁）

- 避免使用匿名结构体定义全局变量，仅在函数内临时使用时采用

## 六、常见问题自查

1. Q：结构体字段首字母小写，跨包为何无法访问？

A：首字母小写为未导出字段，Go语言语法限制未导出成员仅当前包可访问，跨包需将字段名首字母大写

2. Q：结构体指针访问字段为何不用解引用（*）？

A：Go语言提供语法糖，允许指针直接通过“.”访问字段，等价于“(*指针变量).字段名”，简化代码

3. Q：值接收者方法为何无法修改原结构体？

A：值接收者接收的是结构体副本，方法内修改的是副本，不会影响原结构体变量，需用指针接收者

4. Q：结构体包含切片字段，为何值传递后修改切片内容会影响原结构体？

A：切片是引用类型，值传递时复制的是切片头（包含指向底层数组的指针），方法内修改切片元素会操作同一底层数组，影响原结构体；但修改切片本身（如append）不会影响原切片

5. Q：结构体为何无法比较？

A：结构体包含不可比较类型字段（如切片、映射、函数）时，整个结构体不可比较，需确保所有字段都是可比较类型（int、string、bool等）

6. Q：匿名结构体字段冲突如何解决？

A：通过匿名字段名显式访问冲突字段，如“结构体变量.匿名字段名.冲突字段名”