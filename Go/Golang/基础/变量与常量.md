# 变量与常量

## 一、变量基础认知

### 1.1 什么是变量？

程序运行过程中可以被修改的存储数据的容器，具有三个核心要素：
1. **变量名**：标识变量的唯一名称，用于访问变量
2. **数据类型**：规定变量可存储的数据种类（如整数、字符串等）
3. **值**：变量存储的具体数据，可动态修改

### 1.2 核心特性

- **强类型**：变量类型一旦确定，不可随意转换（需显式类型转换）

- **声明即初始化**：未显式初始化的变量会被赋予对应类型的“零值”，不存在未初始化的变量

- **作用域**：变量的有效访问范围，分为全局作用域（函数外声明的变量）和局部作用域（函数内、代码块内声明的变量）

## 二、变量核心用法

### 2.1 变量声明方式

#### 2.1.1 标准声明（指定类型）

语法：`var 变量名 数据类型 = 初始值`，初始值可省略（自动赋零值）；也可仅声明变量名（`var 变量名`），此时变量类型为`interface{}`（空接口），零值为`nil`。

```Plain Text

// 单个声明
var name string = "Golang"
var age int // 零值为0
var isActive bool // 零值为false
var obj // 无类型，默认interface{}类型，零值为nil

// 批量声明（推荐，简洁高效）
var (
    id   int       = 1001
    addr string    = "Beijing"
    score float64  // 零值为0.0
    data // 批量声明中无类型，同样为interface{}类型，零值nil
)
```

#### 2.1.2 类型推导（省略类型）

语法：`var 变量名 = 初始值`，Go编译器根据初始值自动推导变量类型

```go

var name = "Golang" // 推导为string类型
var age = 20        // 推导为int类型
var pi = 3.1415     // 推导为float64类型

// 批量推导
var (
    count = 10
    ratio = 0.8
)
```

#### 2.1.3 短变量声明（局部作用域专用）

语法：`变量名 := 初始值`，简洁高效，仅可在函数内、循环内等局部作用域使用。

```go

func main() {
    name := "Golang" // 局部变量，string类型
    age := 20        // 局部变量，int类型
    
    // 多变量同时声明
    a, b := 10, 20   // a=10（int），b=20（int）
    str, num := "test", 30 // str=string，num=int
}
```

短变量声明注意：:=左侧至少有一个新变量时才可重复使用（用于变量重赋值+新增变量），否则编译报错

```go

func main() {
    a, b := 10, 20
    a, c := 30, 40 // 合法：a重赋值，c是新变量
    // a, b := 50, 60 // 非法：a和b均为已存在变量，无新变量
}
```

### 2.2 零值机制

|数据类型|零值|示例|
|---|---|---|
|布尔型（bool）|false|var b bool → b=false|
|整数型（int、int8等）|0|var i int → i=0|
|浮点型（float32、float64）|0.0|var f float64 → f=0.0|
|字符串（string）|""（空字符串）|var s string → s=""|
|指针、切片、映射等引用类型|nil|var ptr *int → ptr=nil|
### 2.3 作用域规则

1. **全局变量**：在所有函数外部声明的变量（如示例中main函数外的name变量），作用域为整个包（包内所有函数均可访问），若首字母大写可跨包访问

2. **局部变量**：在函数内、if/for等代码块内声明，作用域仅限于当前代码块，外部不可访问

3. **同名遮蔽**：局部变量与全局变量同名时，局部作用域内优先使用局部变量（遮蔽全局变量）

```go

// 全局变量
var name = "全局变量"

func main() {
    // 局部变量（遮蔽全局变量）
    name := "局部变量"
    fmt.Println(name) // 输出：局部变量
    
    if true {
        name := "代码块变量"
        fmt.Println(name) // 输出：代码块变量
    }
    fmt.Println(name) // 输出：局部变量
}
```

### 2.4 类型转换

Go无隐式类型转换，需通过**类型(变量)**显式转换，转换需满足兼容性（如整数转浮点兼容，字符串转整数需用strconv包）

```go

// 基础类型兼容转换
var a int = 10
var b float64 = float64(a) // 整数转浮点，合法
var c int = int(b)         // 浮点转整数，会截断小数部分

// 字符串与数值转换（需strconv包）
import "strconv"

func main() {
    num := 20
    str := strconv.Itoa(num) // 整数转字符串
    fmt.Println(str)         // 输出："20"
    
    newNum, err := strconv.Atoi(str) // 字符串转整数
    if err == nil {
        fmt.Println(newNum) // 输出：20
    }
}
```

## 三、变量类型
### 3.1 核心分类

1. **值类型（Value Types）**  

    - **特点**：变量存储的是“实际值”，赋值或传参时会复制完整值。  

    - **包含类型**：  

        - 基础类型：`int`/`uint`（及不同长度变体）、`float32`/`float64`、`bool`、`string`  

        - 复合类型：`struct`、`array`（数组）、`[n]T`（固定长度数组）  

    - **示例**：`var a int = 10`，`a` 直接存储 `10`，赋值 `b := a` 后 `b` 是独立副本。  

2. **引用类型（Reference Types）**  

    - **特点**：变量存储的是“指向底层数据的指针（引用）”，赋值或传参时复制的是引用，共享底层数据。  

    - **包含类型**：  

        - `slice`（切片）、`map`（映射）、`channel`（通道）、`func`（函数）  

    - **示例**：`s := []int{1,2}`，`s` 存储切片头（含底层数组指针），赋值 `s2 := s` 后 `s` 和 `s2` 操作同一底层数组。  


### 3.2 关键区别

|维度|值类型|引用类型|
|---|---|---|
|存储内容|实际值|底层数据的引用（指针）|
|赋值/传参|复制完整值，独立存在|复制引用，共享底层数据|
|零值行为|类型默认零值（如 `0`）|零值为 `nil`（无指向）|
## 四、常量核心用法

### 4.1 什么是常量？

程序运行过程中**不可修改**的固定值，编译期确定值，支持**数值、字符串、布尔**三种基础类型，及派生的枚举类型

### 4.2 常量声明方式

#### 4.2.1 标准声明（指定类型）

语法：`const 常量名 数据类型 = 值`，**值必须是编译期可确定的常量表达式**

```go

// 单个声明
const PI float64 = 3.1415926
const MAX_AGE int = 120
const IS_OPEN bool = true

// 批量声明
const (
    NAME string = "Golang"
    VERSION string = "1.22.0"
)
```

#### 4.2.2 类型推导（省略类型） 

语法：`const 常量名 = 值`，编译器根据值自动推导类型，更简洁

```go

const PI = 3.1415926 // 推导为float64类型
const MAX_COUNT = 100 // 推导为int类型
const GREET = "Hello" // 推导为string类型

// 批量推导（常用）
const (
    MONTH = 12
    DAY   = 365
    HOUR  = 24
)
```

#### 4.2.3 iota枚举（常量计数器）

iota是Go的常量计数器，在const块中从0开始自动递增，常用于定义枚举类型，支持表达式运算

```go

// 基础枚举：iota从0递增
const (
    Sunday    = iota // 0
    Monday           // 1（自动继承上一行的iota）
    Tuesday          // 2
    Wednesday        // 3
)

// 带表达式的枚举
const (
    _ = iota * 10 // 跳过0，iota=0时结果为0
    Ten           // iota=1 → 10
    Twenty        // iota=2 → 20
    Thirty        // iota=3 → 30
)

// 位运算枚举（常用作选项标记）
const (
    FlagRead = 1 << iota // 1 << 0 = 1（二进制0001）
    FlagWrite             // 1 << 1 = 2（二进制0010）
    FlagExec              // 1 << 2 = 4（二进制0100）
)
```

iota特性：每个const块独立重置计数，若需中断递增可显式赋值，后续未赋值项继续从当前值递增

```go

const (
    a = iota // 0
    b        // 1
    c = 100  // 显式赋值，中断iota递增
    d        // 101（继承上一行的值）
)
const e = iota // 0（新const块，iota重置）
```

### 4.3 常量特性

- **编译期确定**：常量值必须是编译期可计算的表达式（如1+2、"a"+"b"），不可使用运行期变量

- **不可修改**：声明后不可通过赋值修改，否则编译报错

- **作用域**：与变量一致，全局常量首字母大写可跨包访问

## 五、实践规范

### 5.1 变量命名规范

- **小驼峰命名**：局部变量、包内私有变量用小驼峰（如userName、totalCount）

- **大驼峰命名**：全局变量、跨包访问变量用大驼峰（如UserName、TotalCount）

- **简洁明确**：避免冗余命名（如不用userNameVariable，直接用userName），禁止使用单字母（临时变量如i、j、k除外）

- **避免关键字**：不可使用Go关键字（如var、func、if等）作为变量名

### 5.2 常量命名规范

- **全大写+下划线**：常量统一用全大写字母，多个单词用下划线分隔（如MAX_AGE、PI_VALUE）

- **枚举命名**：iota枚举的常量名用大驼峰（如Sunday、FlagRead），体现枚举语义

- **语义化**：避免魔法数字，用常量替代（如用const MAX_RETRY = 3替代直接写3）

### 5.3 其他实践要点

- 优先使用短变量声明（局部作用域），代码更简洁；全局变量用var批量声明

- 变量/常量声明后必须使用，未使用会编译报错（可通过 _ 忽略不需要的函数返回变量）

- 复杂类型（如结构体、切片）建议显式声明类型，增强可读性

- 常量优先于变量：固定不变的值（如配置参数、数学常量）必须定义为常量

## 六、常见问题自查

1. Q：短变量声明在函数外使用报错？
A：短变量声明（:=）仅支持局部作用域，函数外需用var声明全局变量

2. Q：变量未初始化为何不报错？
A：Go的零值机制会为未初始化变量赋予默认零值，确保变量始终可用

3. Q：局部变量与全局变量同名时如何访问全局变量？
A：若全局变量首字母大写，可通过“包名.变量名”跨包访问，同包内仍被局部变量遮蔽；若首字母未大写（包内私有），则**完全无法访问**（同包内也被遮蔽，且无法通过包名访问）。核心建议：避免同名遮蔽

4. Q：iota枚举如何跳过某个值？
A：通过空白标识符_显式赋值跳过，如const (a=iota; _; b=iota) → a=0，b=2

5. Q：常量为何不能赋值为运行期变量？
A：常量值需编译期确定，运行期变量的值在编译时未知，不符合常量特性

6. Q：不同类型的变量能否直接运算？
A：不能，需先显式类型转换为同一类型再运算（如int与float64运算需转float64）

7. Q：var obj这种无类型无值的声明是什么情况？
A：该变量默认是`interface{}`（空接口）类型，零值为`nil`，可后续赋值任意类型值（利用空接口兼容性）