# 类型转换与断言

## 一、类型转换基础认知

Golang是**强类型语言**，不同类型的变量之间不能直接赋值或运算，必须通过显式的类型转换实现类型兼容。类型转换的核心是“将一个类型的数值转换为另一个兼容类型的数值”，转换过程可能伴随值的重新编码。

关键原则：Golang仅支持“兼容类型”的转换，不支持无关联类型的隐式转换（如Java的自动装箱/拆箱），所有转换必须显式声明。

### 1.1 类型转换的分类

根据转换的类型关联性，可分为**基本类型转换**、**复合类型转换**和**接口类型断言**（单独成节详细说明），前两者属于“显式类型转换”，后者是接口场景的特殊类型判断机制。

|转换类型|适用场景|核心特点|
|---|---|---|
|基本类型转换|数值类型（int/float/bool等）、字符串与基本类型互转|直接通过“目标类型(源值)”语法实现，可能丢失精度|
|复合类型转换|数组与切片、结构体与接口、指针类型间转换|需满足结构兼容性，部分转换需借助标准库|
|接口类型断言|接口变量获取具体类型值（如空接口转具体类型）|需判断断言结果，避免panic，支持类型分支匹配|
---

## 二、显式类型转换：语法与场景

### 2.1 基本类型转换：数值与字符串

基本类型转换是最常用的场景，核心语法为`目标类型(源变量或值)`，需注意不同类型的兼容性限制。

#### 2.1.1 数值类型间转换

数值类型包括整数（int8/int16/int32/int64/uint等）、浮点数（float32/float64）和复数类型，转换时需关注精度损失和范围溢出问题。

```go

package main

import "fmt"

func main() {
    // 1. 整数类型间转换（不同位数）
    var a int32 = 100
    var b int64 = int64(a) // 小范围转大范围：安全，无精度损失
    var c int8 = int8(a)   // 大范围转小范围：可能溢出（如a=300会溢出int8的-128~127范围）
    fmt.Printf("a=%d, b=%d, c=%d\n", a, b, c) // 输出：a=100, b=100, c=100

    // 2. 整数与浮点数转换
    var d float64 = 3.14159
    var e int = int(d) // 浮点数转整数：直接截断小数部分，非四舍五入
    var f float32 = float32(d) // float64转float32：可能丢失精度
    fmt.Printf("d=%.5f, e=%d, f=%.5f\n", d, e, f) // 输出：d=3.14159, e=3, f=3.14159

    // 3. 布尔值与数值不可直接转换（编译错误）
    // var g bool = true
    // var h int = int(g) // 错误：cannot convert g (type bool) to type int
}

```

风险提示：

① 大范围整数转小范围整数会导致溢出（如int64(300)转int8会得到44，因300-2*128=44）；

② 浮点数转整数会直接截断小数，如需四舍五入需使用`math.Round`函数。

#### 2.1.2 字符串与基本类型互转

字符串与数值、布尔值的转换无法直接通过“目标类型(源值)”实现，需借助`strconv`标准库，转换失败会返回错误信息。

```go

package main

import (
    "fmt"
    "strconv"
)

func main() {
    // 1. 数值转字符串
    num1 := 123
    str1 := strconv.Itoa(num1) // 整数转字符串（等价于strconv.FormatInt(int64(num1), 10)）
    num2 := 3.14159
    str2 := strconv.FormatFloat(num2, 'f', 4, 64) // 浮点数转字符串：保留4位小数
    fmt.Printf("str1=%s, str2=%s\n", str1, str2) // 输出：str1=123, str2=3.1416

    // 2. 字符串转数值
    str3 := "456"
    num3, err := strconv.Atoi(str3) // 字符串转整数
    if err != nil {
        fmt.Println("str3转整数失败：", err)
    } else {
        fmt.Printf("num3=%d\n", num3) // 输出：num3=456
    }

    str4 := "3.1415"
    num4, err := strconv.ParseFloat(str4, 64) // 字符串转float64
    if err != nil {
        fmt.Println("str4转浮点数失败：", err)
    } else {
        fmt.Printf("num4=%.4f\n", num4) // 输出：num4=3.1415
    }

    // 3. 布尔值与字符串互转
    bool1 := true
    str5 := strconv.FormatBool(bool1)
    bool2, _ := strconv.ParseBool(str5)
    fmt.Printf("str5=%s, bool2=%t\n", str5, bool2) // 输出：str5=true, bool2=true
}

```

### 2.2 复合类型转换：数组、切片与结构体

复合类型转换需满足“结构一致性”，即元素类型、长度（数组）等必须完全匹配，部分场景需通过循环或标准库辅助转换。

#### 2.2.1 数组与切片的转换

数组是固定长度的复合类型，切片是动态长度的引用类型，两者可通过“切片表达式”或“显式转换”关联，但需注意长度限制。

```go

package main

import "fmt"

func main() {
    // 1. 数组转切片：直接通过[:]获取切片（引用数组底层数据）
    arr := [3]int{1, 2, 3}
    slice1 := arr[:] // 数组转切片，切片长度和容量均为3
    fmt.Printf("slice1=%v, len=%d, cap=%d\n", slice1, len(slice1), cap(slice1)) // 输出：slice1=[1 2 3], len=3, cap=3

    // 2. 切片转数组：需显式指定数组类型，且切片长度必须与数组长度一致
    slice2 := []int{4, 5, 6}
    var arr2 [3]int = [3]int(slice2) // 切片长度=数组长度：合法
    fmt.Printf("arr2=%v\n", arr2) // 输出：arr2=[4 5 6]

    // slice3 := []int{7, 8}
    // var arr3 [3]int = [3]int(slice3) // 错误：切片长度(2)不等于数组长度(3)

    // 3. 不同元素类型的数组/切片：不可直接转换，需循环复制
    arr4 := [3]int{1, 2, 3}
    var slice4 []float64 = make([]float64, len(arr4))
    for i, v := range arr4 {
        slice4[i] = float64(v) // 逐元素转换类型
    }
    fmt.Printf("slice4=%v\n", slice4) // 输出：slice4=[1 2 3]
}

```

#### 2.2.2 结构体与接口的转换

结构体实现接口后，可直接赋值给接口变量（隐式转换）；若需将接口变量转回结构体，需通过“类型断言”实现（见第三节）。

```go

package main

import "fmt"

// 定义接口
type Speaker interface {
    Speak() string
}

// 定义结构体并实现接口
type Person struct {
    Name string
}

func (p Person) Speak() string {
    return fmt.Sprintf("我是%s", p.Name)
}

func main() {
    // 1. 结构体转接口：隐式转换（因Person实现了Speaker接口）
    p := Person{Name: "张三"}
    var s Speaker = p // 合法：结构体实例赋值给接口变量
    fmt.Println(s.Speak()) // 输出：我是张三

    // 2. 接口转结构体：需通过类型断言（后续章节详细说明）
    p2, ok := s.(Person)
    if ok {
        fmt.Printf("p2.Name=%s\n", p2.Name) // 输出：p2.Name=张三
    }
}

```

#### 2.2.3 指针类型转换

指针类型转换需满足“基类型兼容”，即相同基类型的指针可直接转换，不同基类型的指针需通过`unsafe.Pointer`间接转换（不推荐，破坏类型安全）。

```go

package main

import "fmt"

func main() {
    // 1. 相同基类型的指针转换（如int32指针转int64指针不允许，基类型不同）
    var a int = 100
    var p1 *int = &a
    // var p2 *int64 = (*int64)(p1) // 错误：基类型int与int64不同

    // 2. 通过unsafe.Pointer间接转换（谨慎使用，仅在底层优化场景）
    import "unsafe" // 需导入unsafe包
    var p3 *int64 = (*int64)(unsafe.Pointer(p1))
    *p3 = 200
    fmt.Printf("a=%d\n", a) // 输出：a=200（修改p3间接修改了a的值，存在风险）
}

```

不推荐使用`unsafe.Pointer`：该包会绕过Go的类型安全检查，可能导致内存访问错误，仅在对性能要求极高且明确底层原理时使用。

---

## 三、接口类型断言：获取具体类型值

类型断言是接口变量的特殊操作，用于“判断接口变量的动态类型是否为指定类型，并获取其动态值”，核心解决“接口变量类型模糊”的问题（如空接口存储任意类型后，需还原为具体类型）。

### 3.1 基本语法：带判断与不带判断

类型断言有两种语法形式，推荐使用“带ok的形式”避免panic。

|语法形式|格式|特点|适用场景|
|---|---|---|---|
|带ok的断言（推荐）|`具体类型变量, ok := 接口变量.(具体类型)`|断言失败时ok=false，不panic，返回具体类型的零值|不确定接口变量类型的场景|
|不带ok的断言|`具体类型变量 := 接口变量.(具体类型)`|断言失败时触发panic|确定接口变量类型的场景（如接口是结构体实现的）|
```go

package main

import "fmt"

func main() {
    // 1. 带ok的类型断言（安全）
    var i interface{} = "hello" // 空接口存储字符串
    str, ok := i.(string)
    if ok {
        fmt.Printf("i是字符串类型，值：%s\n", str) // 输出：i是字符串类型，值：hello
    } else {
        fmt.Println("i不是字符串类型")
    }

    num, ok := i.(int)
    if !ok {
        fmt.Printf("i不是int类型，num的零值：%d\n", num) // 输出：i不是int类型，num的零值：0
    }

    // 2. 不带ok的类型断言（风险）
    var j interface{} = 123
    num2 := j.(int) // 断言成功，正常获取值
    fmt.Printf("num2=%d\n", num2) // 输出：num2=123

    // str2 := j.(string) // 断言失败，触发panic：interface conversion: interface {} is int, not string
}

```

### 3.2 进阶用法：类型分支（type switch）

当接口变量可能是多种类型时，使用`type switch`（类型分支）可批量判断类型，无需多次写带ok的断言，语法更简洁。

```go

package main

import "fmt"

// 处理任意类型的函数
func processAny(i interface{}) {
    // 类型分支：判断i的动态类型
    switch v := i.(type) {
    case int:
        fmt.Printf("处理int类型：%d，平方值：%d\n", v, v*v)
    case string:
        fmt.Printf("处理string类型：%s，长度：%d\n", v, len(v))
    case bool:
        fmt.Printf("处理bool类型：%t，取反：%t\n", v, !v)
    case []int:
        fmt.Printf("处理[]int切片：%v，总和：%d\n", v, sumSlice(v))
    default:
        fmt.Printf("不支持的类型：%T\n", v) // %T输出变量的具体类型
    }
}
```

### 3.3 特殊场景：接口类型的断言

当接口变量的动态类型是另一个接口时，可通过断言判断其是否实现了该接口，实现“接口的嵌套校验”。

```go

package main

import "fmt"

// 父接口
type Animal interface {
    Eat()
}

// 子接口（嵌套父接口）
type Pet interface {
    Animal
    Play()
}

// 猫类型实现Pet接口（需实现Eat和Play方法）
type Cat struct{}

func (c Cat) Eat()  { fmt.Println("猫吃鱼") }
func (c Cat) Play() { fmt.Println("猫玩球") }

func main() {
    var p Pet = Cat{}
    var a Animal = p // 子接口转父接口：隐式转换（Pet包含Animal的方法）

    // 断言a是否为Pet类型（判断a的动态类型是否实现了Pet接口）
    p2, ok := a.(Pet)
    if ok {
        fmt.Println("a的动态类型实现了Pet接口")
        p2.Play() // 输出：猫玩球
    } else {
        fmt.Println("a的动态类型未实现Pet接口")
    }
}

```

---

## 四、常见陷阱与避坑技巧

### 4.1 类型转换的精度与溢出问题

- **浮点数转整数**：直接截断小数，如需四舍五入需使用`math.Round`，但需注意返回值是float64类型，需二次转换为整数。

- **大范围转小范围**：整数转整数时，先通过`strconv`包的范围判断函数校验（如`strconv.CanConvertInt`），避免溢出。

- **字符串转数值**：必须判断返回的错误（如字符串包含非数字字符），避免使用空值忽略错误。

```go

// 浮点数四舍五入示例
import "math"

func roundFloat(f float64) int {
    return int(math.Round(f)) // 先四舍五入为float64，再转int
}

func main() {
    fmt.Println(roundFloat(3.4)) // 输出：3
    fmt.Println(roundFloat(3.5)) // 输出：4
}

```

### 4.2 类型断言的nil判断陷阱

接口变量的nil判断需注意：仅当“动态类型”和“动态值”都为nil时，接口变量才等于nil。若动态类型非nil但动态值为nil，直接判断接口变量==nil会返回false，需通过类型断言判断动态值。

```go

package main

import "fmt"

type MyInterface interface {
    Do()
}

type MyStruct struct{}

func (m *MyStruct) Do() {}

func getInterface(ok bool) MyInterface {
    if ok {
        return &MyStruct{}
    }
    return (*MyStruct)(nil) // 动态类型=*MyStruct，动态值=nil
}

func main() {
    var i MyInterface = getInterface(false)
    fmt.Println(i == nil) // 输出：false（动态类型非nil）

    // 正确判断动态值是否为nil
    if m, ok := i.(*MyStruct); ok {
        fmt.Println(m == nil) // 输出：true（动态值为nil）
    }
}

```

### 4.3 复合类型转换的结构一致性问题

- **数组转切片**：切片引用数组的底层数据，修改切片会影响原数组，如需独立切片需使用`copy`函数复制。

- **结构体转换**：不同结构体即使字段完全相同，也不可直接转换，需通过“字段赋值”或“反射”实现（反射需谨慎使用）。

```go

// 不同结构体的转换（字段相同）
type StructA struct {
    Name string
    Age  int
}

type StructB struct {
    Name string
    Age  int
}

func main() {
    a := StructA{Name: "张三", Age: 20}
    // b := StructB(a) // 错误：cannot convert a (type StructA) to type StructB

    // 正确方式：字段赋值
    b := StructB{
        Name: a.Name,
        Age:  a.Age,
    }
    fmt.Printf("b=%+v\n", b) // 输出：b={Name:张三 Age:20}
}

```

---

## 五、常见问题自查

1. **Q：Golang为什么不支持隐式类型转换？** **A：**为了类型安全。隐式转换可能隐藏精度损失、溢出等问题（如Java中int转long安全，但long转int可能溢出），显式转换让开发者明确感知类型变化，减少潜在bug。

2. **Q：空接口（interface{}）如何转具体类型？必须用类型断言吗？** **A：**是的，空接口存储的任意类型只能通过类型断言还原为具体类型。若不确定类型，使用`type switch`批量判断；若确定类型，可使用不带ok的断言（需确保类型正确）。

3. **Q：结构体指针和结构体值类型，在类型断言时有区别吗？** **A：**有区别。若接口变量的动态类型是结构体指针（如*Person），则断言为Person会失败，必须断言为*Person；反之，动态类型是Person时，断言为*Person也会失败，需严格匹配动态类型。

4. **Q：字符串转整数时，如何处理不同进制的字符串（如二进制、十六进制）？** **A：**使用`strconv.ParseInt`函数，指定第三个参数为进制数（如2为二进制、16为十六进制），返回值为int64类型，可根据需要转换为其他整数类型。`// 十六进制字符串转整数
num, _ := strconv.ParseInt("1A", 16, 64)
fmt.Println(num) // 输出：26
`

---

## 六、最佳实践总结

- **显式优先**：所有类型转换必须显式声明，不依赖隐式规则，提高代码可读性。

- **安全断言**：类型断言必须使用“带ok的形式”，或在`type switch`中处理所有可能类型，避免panic。

- **错误校验**：字符串与基本类型互转时，必须校验`strconv`包返回的错误，不可忽略。

- **避免unsafe**：除非有明确的性能优化需求且熟悉底层原理，否则不使用`unsafe.Pointer`进行指针转换。

- **类型清晰**：空接口的使用需谨慎，尽量通过泛型（Go 1.18+）替代空接口，减少类型断言的使用。