# 函数

## 一、函数基础认知

### 1.1 什么是函数？

封装特定逻辑的代码块，通过调用，实现代码复用、模块化拆分。函数在 Go 中是一等公民，支持作为参数、返回值赋值给变量。

### 1.2 核心特性

- **支持多返回值**：无需借助结构体/指针，直接返回多个值（常用于返回结果+错误信息）

- **无默认参数**：函数参数无默认值，调用时需传入所有声明的参数

- **不支持重载**：同一包内不可定义同名函数（无论参数类型/数量是否不同）

- **支持匿名函数**：可定义无名称的函数，直接调用或赋值给变量

## 二、函数核心用法

### 2.1 函数定义语法

基础结构：`func 函数名(参数列表) (返回值列表) { 函数体 }`，参数与返回值需指定类型，支持批量简写同类型参数。**注意**：多返回值时错误（err）放最后（Go惯例）。

```go

// 1. 无参数无返回值
func sayHello() {
    fmt.Println("Hello Golang")
}

// 2. 单参数单返回值（批量简写类型：参数名1,参数名2 类型）
func add(a, b int) int {
    return a + b
}

// 3. 多参数多返回值（常用：结果+错误）
func divide(a, b float64) (float64, error) {
    if b == 0 {
        return 0, errors.New("除数不能为0")
    }
    return a / b, nil
}

// 4. 命名返回值（提前定义返回值变量，函数内直接赋值）
func calculate(a, b int) (sum, diff int) {
    sum = a + b   // 直接给返回值变量赋值
    diff = a - b
    return        // 裸返回，无需指定返回变量
}
```

命名返回值建议：简单函数可使用裸返回简化代码，复杂函数建议显式返回（增强可读性，避免漏返变量）

### 2.2 函数调用方式

通过“函数名(参数)”调用，多返回值需用多个变量接收（或用`_`忽略不需要的返回值）。

```go

func main() {
    // 调用无参数无返回值函数
    sayHello()

    // 调用单返回值函数
    result := add(10, 20)
    fmt.Println(result) // 输出：30

    // 调用多返回值函数（接收所有返回值）
    divResult, err := divide(10, 2)
    if err == nil {
        fmt.Println(divResult) // 输出：5
    }

    // 调用多返回值函数（忽略错误）
    divResult2, _ := divide(10, 5)
    fmt.Println(divResult2) // 输出：2

    // 调用命名返回值函数
    sum, diff := calculate(20, 10)
    fmt.Println(sum, diff) // 输出：30 10
}
```

### 2.3 特殊函数类型

#### 2.3.1 匿名函数

无名称的函数，可直接调用（立即执行函数）或赋值给变量（函数变量），常用于临时逻辑封装。

```go

func main() {
    // 1. 立即执行匿名函数（定义后直接调用）
    func(msg string) {
        fmt.Println("立即执行：", msg)
    }("Hello Anonymous") // 输出：立即执行：Hello Anonymous

    // 2. 赋值给函数变量
    addFunc := func(a, b int) int {
        return a + b
    }
    result := addFunc(5, 3)
    fmt.Println(result) // 输出：8
}
```

#### 2.3.2 高阶函数

接收函数作为参数，或返回函数的函数，是函数式编程的核心。

```go

// 1. 函数作为参数（实现回调逻辑）
func processNum(a, b int, op func(int, int) int) int {
    return op(a, b) // 调用传入的函数参数
}

// 2. 函数作为返回值（实现函数生成器）
func makeAdder(base int) func(int) int {
    // 返回匿名函数，闭包特性：引用外部变量base
    return func(num int) int {
        return base + num
    }
}

func main() {
    // 调用高阶函数：传入add函数作为参数
    sum := processNum(10, 20, add)
    fmt.Println(sum) // 输出：30

    // 调用函数生成器：生成base=5的加法函数
    adder5 := makeAdder(5)
    fmt.Println(adder5(3)) // 输出：8
    fmt.Println(adder5(10))// 输出：15
}
```

#### 2.3.3 闭包

匿名函数与它引用的外部变量共同构成闭包，闭包会“捕获”外部变量，即使外部函数执行结束，仍可访问该变量。

```go

func counter() func() int {
    count := 0 // 外部变量，被闭包捕获
    return func() int {
        count++ // 闭包内修改外部变量
        return count
    }
}

func main() {
    c1 := counter()
    fmt.Println(c1()) // 输出：1
    fmt.Println(c1()) // 输出：2

    c2 := counter() // 新闭包，捕获新的count变量
    fmt.Println(c2()) // 输出：1
}
```

闭包注意：若闭包引用循环变量，需在循环内通过局部变量“快照”循环变量值，避免所有闭包共享同一变量

```Go
循环变量解决
for _, v := range arr {
    temp := v // 局部变量快照，每次迭代新实例
    funcs = append(funcs, func() int {
        return temp
    })
}
```

### 2.4 函数参数传递

Go语言中**仅支持值传递**：调用函数时，会复制参数的“值”传递给函数形参。需根据是否要修改外部变量，选择传递普通值或指针，核心区别在于“复制的是变量值本身，还是变量的地址”。

#### 2.4.1 基础值传递（不可修改外部变量）

传递普通类型（int、string、bool、小结构体等）时，复制的是变量的实际值，函数内修改形参仅改变副本，不影响外部原始变量。

```Plain Text

// 基础值传递：修改形参不影响外部变量
func modifyVal(a int) {
    a = 100 // 仅修改函数内的副本
}

func main() {
    x := 10
    modifyVal(x)       // 传递x的副本
    fmt.Println(x)     // 输出：10（外部变量未变）
}
```

#### 2.4.2 指针传递（可修改外部变量）

若需修改外部变量，需传递变量的**指针（地址）**。此时复制的是地址值，函数内通过解引用（*指针）可操作指针指向的外部原始变量。

```Plain Text

// 指针传递：通过指针修改外部变量
func modifyPtr(a *int) {
    *a = 100 // 解引用，修改指针指向的外部原始值
}

func main() {
    x := 10
    modifyPtr(&x)      // 传递x的地址（指针）
    fmt.Println(x)     // 输出：100（外部变量已修改）

    // 外部给x重新赋值后，需重新传指针才能继续修改
    x = 200
    modifyPtr(&x)      // 传递新值的地址
    fmt.Println(x)     // 输出：100（新值被修改）
}
```

#### 2.4.3 关键注意点

指针参数本身仍是值传递（复制的是地址副本），需注意：

- 外部变量重新赋值后，只要重新传入当前变量的地址，函数仍可修改其值；

- 若外部变量地址变更（如重新赋值引用类型）且未重新传指针，函数内旧指针会指向无效地址，无法关联新值。

**核心结论**：

① 无需修改外部变量 → 基础值传递；

② 需修改外部变量 → 指针传递，函数内通过*指针操作；

③ 外部变量变更后，需重新传指针以关联新值。

## 三、函数进阶特性

### 3.1 函数类型别名

通过`type`定义函数类型别名，简化高阶函数的参数/返回值声明，增强可读性。

```go

// 定义函数类型别名：接收两个int，返回int
type OpFunc func(int, int) int

// 使用别名作为参数，简化声明
func process(a, b int, op OpFunc) int {
    return op(a, b)
}

func main() {
    // 定义符合OpFunc类型的函数
    multiply := func(a, b int) int {
        return a * b
    }
    fmt.Println(process(5, 6, multiply)) // 输出：30
}
```

### 3.2 可变参数函数

通过`参数名 ...类型`声明可变参数，接收0个或多个同类型参数，函数内以切片形式访问。

```go

// 可变参数函数：计算多个int的和
func sum(nums ...int) int {
    total := 0
    // 可变参数在函数内是切片类型
    for _, num := range nums {
        total += num
    }
    return total
}

func main() {
    fmt.Println(sum(1, 2, 3))    // 输出：6（传入多个参数）
    fmt.Println(sum(10, 20))     // 输出：30
    fmt.Println(sum())           // 输出：0（传入0个参数）

    // 传入切片：需在切片后加...
    arr := []int{5, 6, 7}
    fmt.Println(sum(arr...))     // 输出：18
}
```

### 3.3 递归函数

函数调用自身的函数，需明确终止条件（避免死循环），常用于阶乘、斐波那契数列等场景。

```go

// 递归计算阶乘：n! = n * (n-1)!
func factorial(n int) int {
    if n == 0 || n == 1 { // 终止条件
        return 1
    }
    return n * factorial(n-1) // 调用自身
}

func main() {
    fmt.Println(factorial(5)) // 输出：120
}
```

## 四、实践规范

### 4.1 函数命名规范

- **简洁明确**：避免冗余（如不用getUserInfoData，直接用GetUser）

- **动词开头**：函数名体现动作语义（如GetUser、UpdateData、IsValid）

- **大驼峰命名**：跨包访问函数用大驼峰（如CalcSum、CheckParam）

- **小驼峰命名**：包内私有函数用小驼峰（如calcSum、checkParam）

### 4.2 函数设计规范

- **单一职责**：一个函数只做一件事，避免“万能函数”（建议函数行数不超过50行）

- **错误优先返回**：多返回值时，错误信息（err）放最后一个返回值（Go语言核心惯例，便于接收和判断）

- **参数精简**：参数个数控制在3个以内，过多时用结构体封装

- **避免副作用**：非必要不修改外部变量，通过返回值传递结果；需修改时优先用指针传递并明确标注

### 4.3 其他实践要点

- 匿名函数仅用于临时逻辑，复杂逻辑建议定义具名函数

- 递归深度较大时（如超过1万层）需注意栈溢出，可改用迭代实现

- 函数参数为切片/映射时，虽为值传递，但复制的是引用，函数内修改会影响外部（需谨慎）

## 五、常见问题自查

1. Q：同一包内能否定义同名函数？
A：不能，Go不支持函数重载，同名函数会编译报错

2. Q：函数返回值未使用会报错吗？
A：会，未使用的返回值需用`_`忽略（如`_, err := func()`）

3. Q：闭包引用循环变量为何会出现异常？
A：循环变量在循环中被复用，闭包捕获的是变量引用，需在循环内定义局部变量快照（如`for _, v := range arr { temp := v; 闭包引用temp }`）

4. Q：值传递和指针传递如何选择？
A：基础类型、小结构体用值传递；大结构体、需修改外部值时用指针传递（减少复制开销）。补充：多返回值时错误（err）放最后是Go惯例，便于判断

5. Q：可变参数函数能否接收不同类型的参数？
A：不能，可变参数仅支持同类型参数；需接收不同类型时可使用空接口（`interface{}`）

6. Q：init函数执行顺序是什么？
A：先执行依赖包的init函数，再执行当前包的init函数；同一包内多个init函数按声明顺序执行
> （注：文档部分内容可能由 AI 生成）