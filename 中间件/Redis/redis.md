## 数据类型
### 基础数据结构
- string：可以存储字符串、数字、二进制数据，容量为 2M。Redis 中所有的 key 均为 string 类型
- list：列表，元素可重复，可以当成一个简单的消息队列，元素最多为 2^32 -1。
- hash：哈希表实现，元素最多为 2^32 -1.
- set：无序不可重复，支持多个 set 间做并、交、差集合运算，元素最多为 2^32 -1。
- zset 有序不可重复，通过每个元素设置分数作为排序依据，元素最多为 2^32 -1.
### 高级数据结构(基于上述数据结构实现)
- Bitmap
- HyperLogLog
- Geo
### Streams
- 是一个可持久化支持广播的消息队列。(5.0 后新增)

## String
### 实现编码
- int：底层为 long。数据为整数型并可以用 long 类型表示时使用
- embstr：底层为占用一块内存的 SDS 结构。字符串长度不超过 32 字节时使用
- raw：底层为占用两块内存的 SDS 结构，字符串超度超过 32 字节时使用，两块内存中分别存储元数据和值

list：编码分为ziplist、linkedlist和quicklist（3.2以前版本没有quicklist）。ziplist底层实现为压缩列表,当元素数量小于2且所有元素长度都小于64字节时,使用这种结构来存储；linkedlist底层实现为双端链表,当数据不符合ziplist条件时,使用这种结构存储；3.2版本之后list一般采用quicklist的快速列表结构来代替前两种。
## list
### 实现编码
- ziplist：底层为压缩列表，元素数量小于 2 且元素长度小于 64 字节时使用
- linkedlist：底层为双端链表，当不能使用 ziplist 时使用 linkedlist。
- quicklist(3.2 后)：3.2 版本后一版采用该结构代替前两种

## hash
### 实现编码
- ziplist：底层为压缩列表，KV 对数量小于 2，KV 长度均小于 64 字节时使用该数据结构
- hashtable：底层为哈希表实现，当 ziplist 条件不符合时使用该结构

   set：编码分为inset和hashtable,intset底层实现为整数集合,当所有元素都是整数值且数量不超过2个时使用该结构存储,否则使用字典结构存储。 
## set
- 内部元素为 string
- 时间复杂度为 O(1)
### 实现编码
- intset：底层实现为整数集合，所有元素为整数且数量不超过 2 时使用
- hashtable：不满足 intset 的条件则使用 hashtable

zset：编码分为ziplist和skiplist,当元素数量小于128,并且每个元素长度都小于64字节时,使用ziplist压缩列表结构存储,否则使用skiplist的字典+跳表的结构存储。
## zset
- 内部元素为 string，会关联一个 double 类型的分数，通过分数为 zset 中的元素从小到大排序, 使用 dict 来保存元素和分数的映射关系
- 时间复杂度 O(1)
### 实现编码
- ziplist：压缩列表元素数量小于 128 且元素长度小于 64 字节时使用
- skiplist：不满足 ziplist 的条件时使用 skiplist

## 持久化
### RDB
- 将当前进程数据以快照的方式保存到硬盘，Redis 默认的持久化机制。
- 会创建一个 .rdb 文件，存储数据库的所有 KV 信息。
- 手动触发：通过 SAVE、BGSAVE 命令触发，并创建 .rdb 文件，save 会阻塞当前 Redis 服务器到 RDB 结束，bgsave 会在 fork 阶段发生阻塞，阻塞时间不会很长。
- 自动触发：通过配置让服务器在一定条件下执行 BGSAVE 命令。配置：save m n(m 秒内数据存在 n 次修改，自动触发 bgsave)
- 主从同步：主阶段自动执行 bgsave 并发送给从节点
- debug reload 命令（重新加载 redis），也会触发 save 操作
- shutdown 命令，没哟开启 AOF 的情况下默认执行 bgsave
- 优点：生成的 .rdb 文件较小，通过文件恢复数据的速度非常快
- 缺点：BGSAVE 需要 fork 创建子进程，操作较重，不宜频繁执行，所有无法做到实时持久化
### AOF
- 通过日志记录每次写入命令，重启时执行 AOF 中的命令来恢复数据。
- 默认不开启，通过配置启动：appendonly yes（启动AOF），qppendfilename “name.aof”(设置文件名)
- 优点：安全性高，通过 everysec 配置，可以将数据丢失时间降低在 1s 之内。
- 缺点：存储的是协议文呗，文件比 .rdb 大很多，需要执行 AOF 中的命令来恢复，恢复速度比 RDB 慢。在重写时也需要 fork 子进程。数据库体积较大时占用较多系统资源，会导致服务器堵塞。
- AOF 文件文本协议优点：具有可读性
- AOF 记录过程：调用 write 进行文件写入时，数据先写入缓存区，缓存区满 or 时间周期到时，系统执行 flush 操作，数据写到硬盘。优点是提高了性能，缺点是给 AOF 带来了不确定性。可以通过 appendfsync 配置控制 AOF flush 频率，基于 Linux 的 glibc 提供的 fsync 实现。
### RDB-AOF 混合持久化
- Redis4.0 增加，基于 AOF 持久化实现。
- 通过配置 aof-use-rdb-preamble 为 yes 开启 AOF 混合持久化
- 在执行 AOF 重写时，会像 BGSAVE 一样生成 RDB 数据并写入 AOF 中，对于SAVE 后的写入命令则像 AOF 一样追加在 AOF 文件的末尾。
- 同时有 RDB、AOF 的优点。且避免了实时持久化及恢复速度慢的问题。

## 分布式锁
- 概念：多个 server 对同一个资源产生依赖，且产生死锁，在程序语言的设计中无法解决，需要通过分布式锁设计解决该问题。
- redis 中使用 key 作为 lock，val 为使用方服务信息及 start 时间，KV 有过期时间
- 向服务方提供资源使用的 SDK，资源使用的所有操作需要通过 SDK 进行实现，SDK 中设定资源可使用时间，通过 start 时间及过期时间计算该服务方资源可使用时间，到期后服务方所有操作需要对 redis 中的 lock 进行检查，当不再有该 lock 的权限时，服务方所有对于该资源的操作禁止。
- Redis 集群情况下，需要向集群中所有 Redis 进行加锁操作，一半以上加锁成功，则认为加锁成功。（但是这种情况还是会有问题，所以还是采用 DB 实现分布式锁吧，毕竟数据唯一）

## 缓存穿透、击穿、雪崩
### 缓存穿透：
- 缓存穿透：查询根本不存在的数据流量打到 DB，导致 DB 负载过大宕机，可以通过缓存控对象、布龙过滤器解决该问题
- 缓存空对象：DB 中未查询到后，仍然在缓存中为该类型请求增加空对象缓存，从缓存层返回空值，以减少缓存穿透现象。
- 布龙过滤器：访问缓存前校验其是否可能存在，若不可能存在则返回空值。
### 缓存击穿
- 缓存击穿：访问量很大的热点数据缓存失效，大量请求打到 DB，导致服务崩溃。可以在 key 过期前使用后端线程对其进行更新，保证其数据可更新且缓存不过期。
### 缓存雪崩：
- 缓存雪崩：缓存层无法提供服务，导致请求打到 DB，导致 DB 宕机。可能是大量数据同时过期，也可能是 Redis 节点故障，可以控制过期时间为固定等级的范围内的随机值，防止大量key 过期，也可以启用降级、熔断机制，发生雪崩时，如果不是核心数据则返回空值 or 错误信息。也可以构建高可用的 Redis 服务，采用哨兵 or 集群模式，部署多个 Reids 实例。

## Redis 的单线程架构
Redis的网络IO和键值对读写是由一个线程来完成的
- 网络 ID 和 KV 读写通过一个线程完成
- 持久化、异步删除、集群数据同步依赖其它线程实现
- 单线程可以避免一部分线程切换、竞争造成的消耗，但是单个命令执行时间过程会阻塞
- 采用了io多路复用机制,提供了并发处理大量客户端请求的能力。

## Redis 哨兵
- 由多个 Sentinel 实例组成 Sentinel 系统，可监视所有 Redis 服务器是否可达，如果大多数 Sentinel 认为 Redis 主节点不可达时，会从中选取一个阶段作为主节点，同时将变化通知给应用方
 1. 哨兵节点会定期监控数据节点,其他哨兵节点是否可达；
 2. 哨兵节点会将故障转移的结果通知给应用方；
 3. 哨兵节点可以将从节点晋升为主节点,并维护后续正确的主从关系；
 4. 哨兵模式下,客户端连接的是哨兵节点集合,从中获取主节点信息；
 5. 节点的故障判断是由多个哨兵节点共同完成的,可有效地防止误判；
 6. 哨兵节点集合是由多个哨兵节点组成的,即使个别哨兵节点不可用,整个集合依然是健壮的；
 7. 哨兵节点也是独立的Redis节点,是特殊的Redis节点,它们不存储数据,只支持部分命令。 集群： Redis集群采用虚拟槽分区来实现数据分片,它把所有的键根据哈希函数映射到`0-16383`整数槽内,计算公式为`slot=CRC16(key)&16383`,每一个节点负责维护一部分槽以及槽所映射的键值数据。虚拟槽分区具有如下特点：。
 1. 解耦数据和节点之间的关系,简化了节点扩容和收缩的难度；
 2. 节点自身维护槽的映射关系,不需要客户端或者代理服务维护槽分区元数据；
 3. 支持节点、槽、键之间的映射查询,用于数据路由,在线伸缩等场景。

 ## Redis 主从同步机制
- 所用从节点都可以从主节点同步数据。
- slave 节点启动时会发送 PSYNC 命令到 master node，如果是第一次连接则会触发一次全量复制。
- 后续同步为部分复制

## Redis 的缓存淘汰策略（过期策略）
### 惰性过期：
- 访问一个 K 时， redis 检查其过期时间，如果已经过期则立马删除。
### 定期删除：
- 将设置了过期时间的 K 放到一个字典中，每秒 10 次进行扫描（采用一种贪心策略），
- 贪心策略：1. 从过期字典中随机选择20个key； 2. 删除这20个key中已过期的key； 3. 如果已过期key的比例超过25%,则重复步骤1
- 写入数据超出 maxmemory 时，采用 maxmemory-policy 指定的策略进行数据淘汰。
