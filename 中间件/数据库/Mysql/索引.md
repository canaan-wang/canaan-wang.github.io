# 索引

# 一、索引简介

## 1.1 基本定义

索引是MySQL中用于**加速数据查询**的一种数据结构，通过对数据表中的一列或多列值进行排序，形成高效的查询路径，避免全表扫描，提升查询效率。类比书籍的目录，通过目录可快速定位章节，而非逐页翻阅。

## 1.2 核心作用

- **加速查询**：核心价值，针对WHERE条件查询、JOIN关联查询等场景大幅提升效率；

- **保证数据唯一性**：如唯一索引可强制列值不重复，实现数据完整性约束；

- **优化排序**：若查询包含ORDER BY、GROUP BY，合理的索引可避免额外排序操作（Using filesort）。

## 1.3 优缺点

|优点|缺点|
|---|---|
|查询速度显著提升|占用额外磁盘空间（索引文件）|
|减少排序/分组开销|增删改（INSERT/DELETE/UPDATE）效率下降（需同步维护索引）|
|实现数据唯一性约束|过多索引会增加MySQL优化器选择成本|
# 二、索引分类（按功能划分）

MySQL索引按功能可划分为以下核心类型，不同类型对应不同的使用场景，且多数基于B+树数据结构实现（MySQL默认索引结构）：

## 2.1 主键索引（PRIMARY KEY）

- **核心特性**：唯一标识数据行，默认强制非空且值唯一；InnoDB中主键索引为“聚簇索引”，叶子节点直接存储完整数据行，是索引体系的核心；

- **数据结构**：基于B+树实现，插入时需保证有序性（推荐自增主键）；

- **使用场景**：用于唯一标识记录，是表的必选索引（无显式指定时，MySQL会隐式生成隐藏主键）。

## 2.2 唯一索引（UNIQUE）

- **核心特性**：保证索引列值唯一，允许存在一个NULL值（NULL不与任何值相等）；可实现数据完整性约束，避免重复数据；

- **数据结构**：基于B+树实现，与普通索引结构类似，仅多了唯一性校验；

- **使用场景**：用于需唯一约束的列，如用户手机号、邮箱（非主键场景）。

## 2.3 普通索引（INDEX）

- **核心特性**：无任何约束条件，仅用于加速查询，是最常用的索引类型；

- **数据结构**：基于B+树实现，InnoDB中作为二级索引，叶子节点存储主键值（需回表获取完整数据）；

- **使用场景**：用于WHERE条件、JOIN关联、ORDER BY等高频查询列，如用户姓名、商品分类。

## 2.4 复合索引（联合索引）

- **核心特性**：基于多列组合创建（如INDEX idx_name_age (name, age)），核心遵循“最左前缀匹配原则”；可匹配多列组合查询，比多个单列索引更高效，减少索引冗余。

- **数据结构**：基于B+树实现，索引树优先按第一列排序，第一列值相同则按第二列排序，第二列相同再按第三列排序，以此类推，形成层级排序结构。

- **使用场景**：适用于多列组合查询或包含左侧列的单/多列查询场景，例如：
1. 全列匹配：WHERE name = ? AND age = ?（使用完整索引）；
2. 左前缀单列匹配：WHERE name = ?（使用索引的name列部分）；
3. 左前缀多列匹配：WHERE name = ? AND age = ? AND gender = ?（若索引为idx_name_age_gender，使用完整索引）。

## 2.5 前缀索引

- **核心特性**：对字符串列的前N个字符创建索引（如INDEX idx_email (email(10))），减少索引存储空间，平衡查询精度和性能；

- **数据结构**：基于B+树实现，仅存储字符串前缀作为索引键；

- **使用场景**：用于长字符串列（如VARCHAR(200)、TEXT），如邮箱、文章摘要。

## 2.6 其他特殊索引

- **全文索引（FULLTEXT）**：针对文本内容（如VARCHAR、TEXT）的分词索引，支持模糊匹配（需用MATCH AGAINST语法），InnoDB 5.6+支持；非B+树结构，基于分词倒排索引实现；适用于文章内容、商品描述等全文检索场景；

- **哈希索引**：基于哈希表实现，等值查询（=、IN）极快，但不支持范围查询和排序；MySQL中仅Memory引擎支持显式创建，InnoDB有自适应哈希索引（自动为热点索引构建，不可手动创建）；

- **R树索引**：用于空间数据类型（如GEOMETRY），支持空间范围查询，较少实际应用。

# 三、索引创建与删除

## 3.1 创建索引

### 3.1.1 建表时创建

```sql

-- 主键索引（建表时）
CREATE TABLE user (
    id INT PRIMARY KEY AUTO_INCREMENT,  -- 主键索引
    username VARCHAR(50) NOT NULL,
    email VARCHAR(100) UNIQUE,  -- 唯一索引
    age INT,
    INDEX idx_username (username),  -- 普通索引
    INDEX idx_username_age (username, age),  -- 复合索引
    FULLTEXT INDEX ft_idx_username (username)  -- 全文索引
);

-- 前缀索引（建表时）
CREATE TABLE article (
    id INT PRIMARY KEY,
    content VARCHAR(2000),
    INDEX idx_content (content(50))  -- 对content前50个字符建索引
);
```

### 3.1.2 建表后创建（ALTER TABLE / CREATE INDEX）

```sql

-- 普通索引
ALTER TABLE user ADD INDEX idx_age (age);
-- 或
CREATE INDEX idx_age ON user(age);

-- 唯一索引
ALTER TABLE user ADD UNIQUE INDEX idx_email (email);

-- 复合索引
ALTER TABLE user ADD INDEX idx_name_age (username, age);

-- 全文索引
ALTER TABLE user ADD FULLTEXT INDEX ft_idx_username (username);
```

## 3.2 删除索引

```sql

-- ALTER TABLE 方式（通用）
ALTER TABLE user DROP INDEX idx_age;

-- 删除主键索引（需先移除AUTO_INCREMENT，若有）
ALTER TABLE user MODIFY id INT;  -- 移除自增
ALTER TABLE user DROP PRIMARY KEY;

-- CREATE INDEX 创建的索引也可用DROP INDEX删除
DROP INDEX idx_username ON user;
```

# 四、核心原理与规则

## 4.1 B+树索引原理（以InnoDB聚簇索引为例）

1. 主键索引树的叶子节点存储完整数据行，非叶子节点存储主键值；

2. 查询时，从根节点开始比较索引键，逐层定位到叶子节点，获取数据；

3. 若查询的列均在二级索引中（如SELECT name, age FROM user WHERE name='张三'，且有idx_name_age索引），则无需回表，直接从二级索引获取数据（“覆盖索引”）。

> 二级索引（非主键索引的统称）：指除主键索引外的所有索引。
> 
> 

## 4.2 最左前缀匹配原则（复合索引核心）

复合索引（a, b, c）的索引树按a排序，a相同则按b排序，b相同则按c排序，查询时需从最左列开始匹配，否则无法使用索引。

**注意事项**：
1. 跳过左侧列不触发索引：如索引idx_name_age，WHERE age = ? 无法使用索引，因跳过了最左列name；
2. 中间列缺失仅匹配左侧部分：如WHERE name = ? AND gender = ?（索引idx_name_age_gender），仅name列使用索引，gender列不触发；
3. 索引列顺序影响匹配效果：需将查询频率高、区分度高的列放左侧，如高频查询WHERE user_id = ? AND order_id = ?，应建idx_userid_orderid而非idx_orderid_userid；
4. 范围查询后列不触发索引：如WHERE name = ? AND age > ? AND gender = ?（索引idx_name_age_gender），age为范围查询后，gender列无法使用索引；
5. 避免函数/运算破坏前缀：如WHERE SUBSTR(name,1,2) = ? AND age = ?，name列函数运算导致左前缀失效，无法使用索引。

## 4.3 索引失效场景（重点）

- **索引列参与函数运算**：如WHERE SUBSTR(name, 1, 3) = '张'（可用前缀索引替代）；
**核心原因**：索引树存储的是索引列原始值，函数运算会改变原始值，MySQL无法直接匹配索引键，需全表计算后对比；

- **索引列使用运算符**：如WHERE age + 1 = 10（改为age = 9即可使用索引）；
**核心原因**：运算在执行期，sql 不清楚 age 应该匹配的具体值。

- **模糊匹配以%开头**：如WHERE name LIKE '%三'（%在开头无法使用索引，%在结尾可使用：LIKE '张%'）；

- **OR** ** ** **连接非索引列**：如WHERE a = 1 OR b = 2（若b无索引，整个查询不使用索引）；

- **隐式类型转换**：如索引列是VARCHAR类型，查询时用WHERE name = 123（字符串与数字比较，触发类型转换）；

- **MySQL优化器判断全表扫描更快**：如数据量极少（表行数<10）或查询结果占表数据30%以上。

# 五、索引设计最佳实践

- **优先给WHERE、JOIN、ORDER BY/GROUP BY列建索引**：这些场景是索引的核心优化点；

- **合理使用复合索引**：将查询频率高、区分度高的列放在前面（如idx_userid_orderid比idx_orderid_userid更合理，若userid查询更频繁）；

- **避免过度索引**：仅给必要列建索引，减少增删改时的索引维护成本；

- **使用覆盖索引减少回表**：查询列尽量包含在索引中（如SELECT id, name FROM user WHERE name='张三'，建idx_name_id索引）；

- **长字符串用前缀索引**：如邮箱列建INDEX idx_email (email(10))，平衡索引大小和查询精度；

- **主键尽量用自增INT**：自增主键可保证B+树索引有序插入，减少页分裂，提升写入效率；避免用UUID（无序，易导致页分裂）；

- **定期优化索引**：通过EXPLAIN分析慢查询，删除冗余索引、无效索引。

# 六、索引分析工具：EXPLAIN

通过EXPLAIN关键字分析SQL执行计划，判断索引是否被使用：

```sql

EXPLAIN SELECT * FROM user WHERE username = '张三' AND age = 20;
```

## 核心字段解读

- **type**：索引使用类型，从好到差为：system > const > eq_ref > ref > range > index > ALL（ALL表示全表扫描，需优化）；

- **key**：实际使用的索引名（NULL表示未使用索引）；

- **key_len**：使用的索引长度（越长说明使用的索引列越多）；

- **rows**：MySQL预估扫描的行数（越少越好）；

- **Extra**：额外信息，如“Using index”表示覆盖索引，“Using filesort”表示需额外排序（无合适索引），“Using temporary”表示需临时表（需优化）。

# 七、常见问题

- **为什么主键推荐自增？**：自增主键插入时B+树节点有序，无需频繁页分裂；非自增主键（如UUID）插入时需频繁调整索引结构，写入效率低；

- **复合索引和多个单列索引哪个好？**：复合索引更优，可匹配多列查询，减少索引文件大小；多个单列索引在多列查询时，MySQL通常仅使用一个最优索引；

- **索引越多查询越快？**：不是。过多索引会增加优化器选择成本，且增删改时需同步维护所有索引，降低写入效率；

- **NULL值是否影响索引？**：普通索引和唯一索引允许NULL值，会占用索引空间；查询时WHERE column IS NULL可使用索引。
> （注：文档部分内容可能由 AI 生成）